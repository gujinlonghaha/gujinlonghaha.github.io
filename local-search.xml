<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>公司文档生成利器</title>
    <link href="/2021/04/10/docsify/"/>
    <url>/2021/04/10/docsify/</url>
    
    <content type="html"><![CDATA[<p>个人使用过hexo 等生成器但是这个是真厉害 因为他<strong>不需要</strong>把makdown 转化html 的编译过程<strong>启动极快</strong></p><p>还有几个独特的优势</p><ol><li>离线缓存</li><li>不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD </li><li>支持vue</li></ol><p>花了半小时测测试效果如下  真好看  即使是公司的人不会代码也是轻而易举搞定</p><p><img src="/2021/04/10/docsify/1618050136294.png" alt="1618050136294"></p><p><img src="/2021/04/10/docsify/1618050169962.png" alt="1618050169962"></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%BC%80%E5%A7%8B">开始</a></h1><p>首选全局安装<code>docsify-cli</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i docsify-cli -g<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></h2><p>初始化会自动生成<code>./docs</code>文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docsify init ./docs<br><br>// 如果不想新建一个文件夹，可以直接进行初始化操作<br><br>docsify init<br></code></pre></td></tr></table></figure><h2 id="建立第一个文档"><a href="#建立第一个文档" class="headerlink" title="建立第一个文档"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3">建立第一个文档</a></h2><p>初始化之后目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">|—— docs<br>    |—— index.html 入口<br>    |—— README.md 主页<br>    |—— .nojekyll 防止Github忽视下划线开头文件<br></code></pre></td></tr></table></figure><h2 id="预览网站"><a href="#预览网站" class="headerlink" title="预览网站"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E9%A2%84%E8%A7%88%E7%BD%91%E7%AB%99">预览网站</a></h2><p>执行以下命令，预览网站就在<code>http://localhost:3000</code>网址打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> docs<br>docsify serve<br></code></pre></td></tr></table></figure><h1 id="离线缓存（PWA）"><a href="#离线缓存（PWA）" class="headerlink" title="离线缓存（PWA）"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%EF%BC%88pwa%EF%BC%89">离线缓存（PWA）</a></h1><h2 id="1-创建一个-servieWorker"><a href="#1-创建一个-servieWorker" class="headerlink" title="1. 创建一个 servieWorker"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=_1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-servieworker">1. 创建一个 servieWorker</a></h2><blockquote><p>根目录下创建<code>sw.js</code>文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* ===========================================================</span><br><span class="hljs-comment"> * docsify sw.js</span><br><span class="hljs-comment"> * ===========================================================</span><br><span class="hljs-comment"> * Copyright 2016 @huxpro</span><br><span class="hljs-comment"> * Licensed under Apache 2.0</span><br><span class="hljs-comment"> * Register service worker.</span><br><span class="hljs-comment"> * ========================================================== */</span><br><br><span class="hljs-keyword">const</span> RUNTIME = <span class="hljs-string">&quot;docsify&quot;</span>;<br><span class="hljs-keyword">const</span> HOSTNAME_WHITELIST = [self.location.hostname, <span class="hljs-string">&quot;fonts.gstatic.com&quot;</span>, <span class="hljs-string">&quot;fonts.googleapis.com&quot;</span>, <span class="hljs-string">&quot;cdn.jsdelivr.net&quot;</span>];<br><br><span class="hljs-comment">// The Util Function to hack URLs of intercepted requests</span><br><span class="hljs-keyword">const</span> getFixedUrl = <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(req.url);<br><br>  <span class="hljs-comment">// 1. fixed http URL</span><br>  <span class="hljs-comment">// Just keep syncing with location.protocol</span><br>  <span class="hljs-comment">// fetch(httpURL) belongs to active mixed content.</span><br>  <span class="hljs-comment">// And fetch(httpRequest) is not supported yet.</span><br>  url.protocol = self.location.protocol;<br><br>  <span class="hljs-comment">// 2. add query for caching-busting.</span><br>  <span class="hljs-comment">// Github Pages served with Cache-Control: max-age=600</span><br>  <span class="hljs-comment">// max-age on mutable content is error-prone, with SW life of bugs can even extend.</span><br>  <span class="hljs-comment">// Until cache mode of Fetch API landed, we have to workaround cache-busting with query string.</span><br>  <span class="hljs-comment">// Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190</span><br>  <span class="hljs-keyword">if</span> (url.hostname === self.location.hostname) &#123;<br>    url.search += (url.search ? <span class="hljs-string">&quot;&amp;&quot;</span> : <span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-string">&quot;cache-bust=&quot;</span> + now;<br>  &#125;<br>  <span class="hljs-keyword">return</span> url.href;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Lifecycle <span class="hljs-variable">Activate</span></span></span><br><span class="hljs-comment"> *  New one activated when old isnt being used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  waitUntil(): activating ====&gt; activated</span><br><span class="hljs-comment"> */</span><br>self.addEventListener(<span class="hljs-string">&quot;activate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.waitUntil(self.clients.claim());<br>&#125;);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  <span class="hljs-doctag">@Functional <span class="hljs-variable">Fetch</span></span></span><br><span class="hljs-comment"> *  All network requests are being intercepted here.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  void respondWith(Promise&lt;Response&gt; r)</span><br><span class="hljs-comment"> */</span><br>self.addEventListener(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// Skip some of cross-origin requests, like those for Google Analytics.</span><br>  <span class="hljs-keyword">if</span> (HOSTNAME_WHITELIST.indexOf(<span class="hljs-keyword">new</span> URL(event.request.url).hostname) &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Stale-while-revalidate</span><br>    <span class="hljs-comment">// similar to HTTP&#x27;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale</span><br>    <span class="hljs-comment">// Upgrade from Jake&#x27;s to Surma&#x27;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1</span><br>    <span class="hljs-keyword">const</span> cached = caches.match(event.request);<br>    <span class="hljs-keyword">const</span> fixedUrl = getFixedUrl(event.request);<br>    <span class="hljs-keyword">const</span> fetched = fetch(fixedUrl, &#123; <span class="hljs-attr">cache</span>: <span class="hljs-string">&quot;no-store&quot;</span> &#125;);<br>    <span class="hljs-keyword">const</span> fetchedCopy = fetched.then(<span class="hljs-function">(<span class="hljs-params">resp</span>) =&gt;</span> resp.clone());<br><br>    <span class="hljs-comment">// Call respondWith() with whatever we get first.</span><br>    <span class="hljs-comment">// If the fetch fails (e.g disconnected), wait for the cache.</span><br>    <span class="hljs-comment">// If there’s nothing in cache, wait for the fetch.</span><br>    <span class="hljs-comment">// If neither yields a response, return offline pages.</span><br>    event.respondWith(<br>      <span class="hljs-built_in">Promise</span>.race([fetched.catch(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> cached), cached])<br>        .then(<span class="hljs-function">(<span class="hljs-params">resp</span>) =&gt;</span> resp || fetched)<br>        .catch(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">/* eat any errors */</span><br>        &#125;)<br>    );<br><br>    <span class="hljs-comment">// Update the cache with the version we fetched (only for ok status)</span><br>    event.waitUntil(<br>      <span class="hljs-built_in">Promise</span>.all([fetchedCopy, caches.open(RUNTIME)])<br>        .then(<span class="hljs-function">(<span class="hljs-params">[response, cache]</span>) =&gt;</span> response.ok &amp;&amp; cache.put(event.request, response))<br>        .catch(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-comment">/* eat any errors */</span><br>        &#125;)<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-在index-html文件中注册"><a href="#2-在index-html文件中注册" class="headerlink" title="2. 在index.html文件中注册"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=_2-%E5%9C%A8indexhtml%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B3%A8%E5%86%8C">2. 在<code>index.html</code>文件中注册</a></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> navigator.serviceWorker !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;</span><br><span class="javascript">    navigator.serviceWorker.register(<span class="hljs-string">&quot;sw.js&quot;</span>);</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docsify  文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docsify  文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易版exe 打包</title>
    <link href="/2021/04/01/ahk/"/>
    <url>/2021/04/01/ahk/</url>
    
    <content type="html"><![CDATA[<h1 id="AHK自动热键"><a href="#AHK自动热键" class="headerlink" title="AHK自动热键"></a><strong>AHK</strong>自动热键</h1><p>强大的Windows的终极自动化脚本语言。</p><p><a href="https://www.autohotkey.com/docs/Hotkeys.htm#Intro"><img src="/2021/04/01/ahk/features-bootstrap.png" alt="img"></a></p><h3 id="键绑定"><a href="#键绑定" class="headerlink" title="键绑定"></a>键绑定</h3><p>定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！</p><p><a href="https://en.wikipedia.org/wiki/AutoHotkey"><img src="/2021/04/01/ahk/features-blocks.png" alt="img"></a></p><h3 id="什么是自动热键"><a href="#什么是自动热键" class="headerlink" title="什么是自动热键"></a>什么是自动热键</h3><p>AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等</p><p><a href="https://autohotkey.com/download/ahk-install.exe">下载地址</a></p><p>安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器</p><p><img src="/2021/04/01/ahk/1617959488146.png" alt="1617959488146"></p><p>窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！</p><p><img src="/2021/04/01/ahk/1617959539175.png" alt="1617959539175"></p><p>随便编写个脚本如下</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#z<span class="hljs-type">::Run</span> https:<span class="hljs-comment">//autohotkey.com  ; Win+Z</span><br><br></code></pre></td></tr></table></figure><p><img src="/2021/04/01/ahk/1617959708823.png" alt="1617959708823"></p><p>右键可以编译脚本为exe   如上图</p><p>tets.exe  双击启动 按下winow+z 就会自动打开   <a href="https://autohotkey.com/">https://autohotkey.com</a>    网址 </p><p>其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe  对方得安装ahk 才可以    虽然是exe 可能底层还是需要ahk 的运行环境吧）</p>]]></content>
    
    
    <categories>
      
      <category>ahk exe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ahk exe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓应用控件获取方法</title>
    <link href="/2021/03/20/app/"/>
    <url>/2021/03/20/app/</url>
    
    <content type="html"><![CDATA[<h2 id="网上随便搜索都是需要java-sdk-等安卓adb-工具才能实现"><a href="#网上随便搜索都是需要java-sdk-等安卓adb-工具才能实现" class="headerlink" title="网上随便搜索都是需要java sdk  等安卓adb 工具才能实现"></a>网上随便搜索都是需要java sdk  等安卓adb 工具才能实现</h2><h3 id="要不然就是Appium-手机自动化工具"><a href="#要不然就是Appium-手机自动化工具" class="headerlink" title="要不然就是Appium 手机自动化工具"></a>要不然就是Appium 手机自动化工具</h3><p><img src="/2021/03/20/app/1617953614313.png" alt="1617953614313"></p><p><img src="/2021/03/20/app/1617953651490.png" alt="1617953651490"></p><p>不懂的人直接头皮发麻 直接劝退</p><h4 id="而且有效信息只有一页-差点放弃"><a href="#而且有效信息只有一页-差点放弃" class="headerlink" title="而且有效信息只有一页 差点放弃"></a><strong>而且有效信息只有一页 差点放弃</strong></h4><p><img src="/2021/03/20/app/1617953729754.png" alt="1617953729754"></p><p>之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式）</p><p><img src="/2021/03/20/app/1617954307011.png" alt="1617954307011"></p><p>针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现</p><h4 id="特此记录-（踏破铁鞋无匿处）-真是难者不会-会者不难-一个知识和工具就是巨大鸿沟"><a href="#特此记录-（踏破铁鞋无匿处）-真是难者不会-会者不难-一个知识和工具就是巨大鸿沟" class="headerlink" title="特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难  一个知识和工具就是巨大鸿沟"></a><strong>特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难  一个知识和工具就是巨大鸿沟</strong></h4><p><a href="https://www.coolapk.com/apk/com.toshiba_dealin.developerhelper">1地址</a>      开发者工具简单好用</p><p><img src="/2021/03/20/app/1617953969262.png" alt="1617953969262"></p><p><a href="https://app.mi.com/details?id=com.yichuang.quickerapp&ref=search">地址</a></p><p>效果</p><p><img src="/2021/03/20/app/1617954371068.png" alt="1617954371068"></p><p>2手机版quicker  <img src="/2021/03/20/app/1617954121135.png" alt="1617954121135"></p><p>效果如下</p><p><img src="/2021/03/20/app/1617954143390.png" alt="1617954143390"></p><p>从此以后你就可以编写自动化手机脚本无压力了   解放你的双手</p><ol><li> 自动打卡</li><li> 自动抢购</li><li>自动导航</li></ol>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs+Selenium环境搭建以及深坑</title>
    <link href="/2021/03/09/sele/"/>
    <url>/2021/03/09/sele/</url>
    
    <content type="html"><![CDATA[<h1 id="“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”"><a href="#“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”" class="headerlink" title="“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”"></a><em>“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”</em></h1><p>这个sologan 还是够硬的，不过确实如此。</p><p>Selenium有以下功能特性:</p><ul><li>Selenium是一个开源和可移植的Web测试框架。</li><li>Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。</li><li>它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。</li><li>Selenium支持各种操作系统，浏览器和编程语言。如下列表:<ul><li><strong>编程语言</strong>: C# ，Java，Python，PHP，Ruby，Perl和JavaScript</li><li><strong>操作系统</strong>:Android，iOS，Windows，Linux，Mac，Solaris。</li><li><strong>浏览器</strong>:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。</li></ul></li><li>它还支持并行测试执行，从而减少了时间并提高了测试效率。</li><li>Selenium可以与Ant和Maven等框架集成，用于源代码编译。</li><li>Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。</li><li>与其他自动化测试工具相比，Selenium需要的资源更少。</li><li>WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。</li><li>Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。</li><li>Selenium命令根据不同的类进行分类，使其更易于理解和实现。</li><li>Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。</li></ul><p>局限性主要如下：</p><ul><li>Selenium不支持桌面应用程序的自动化测试。</li><li>Selenium需要高技能才能更有效地自动化测试。</li><li>由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。</li><li>无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。</li><li>使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。</li><li>它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。</li><li>Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。</li><li>无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。</li><li>与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。</li><li>新功能没有人可能少人使用，它们可能会也可能不会正常工作。</li><li>Selenium不为测试管理提供任何测试工具集成。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="1-安装-Nodejs"><a href="#1-安装-Nodejs" class="headerlink" title="1.安装 Nodejs"></a>1.安装 Nodejs</h4><p>到<a href="https://nodejs.org/en/download/">Nodejs</a>官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。</p><blockquote><p>node -v</p></blockquote><h4 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2.项目初始化"></a>2.项目初始化</h4><p>创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令：</p><blockquote><p>npm init</p></blockquote><h4 id="3-配置selenium运行环境"><a href="#3-配置selenium运行环境" class="headerlink" title="3.配置selenium运行环境"></a>3.配置selenium运行环境</h4><p>在上一步相同的命令行下运行以下命令至其运行安装完成。</p><blockquote><p>npm install selenium-webdriver –save</p></blockquote><h4 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h4><ul><li><p>安装Chrome驱动</p><blockquote><p>npm install chromedriver –save</p></blockquote></li><li><p>安装Firefox驱动</p><blockquote><p>npm install geckodriver –save</p></blockquote></li><li><p>安装IE驱动</p><blockquote><p>npm install iedriver –save</p></blockquote></li></ul><p>说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：<a href="http://www.seleniumhq.org/download/">http://www.seleniumhq.org/download/</a></p><h3 id="可能会碰到问题"><a href="#可能会碰到问题" class="headerlink" title="可能会碰到问题"></a>可能会碰到问题</h3><p>1）“The ChromeDriver could not be found on the current PATH”</p><p>需要将 ChromeDriver 添加到系统的环境变量 Path 中   也是就是你下载的exe 路径  自行更改</p><p>我本地还是失败 最终直接把exe  与脚本相同的目录下 运行正常   这个折腾了半天 </p><p><img src="/2021/03/09/sele/1617945126154.png" alt="1617945126154"></p><p>2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url</p><p>解决方案  自己的浏览器和下载版本对应</p><p><img src="/2021/03/09/sele/1617945212686.png" alt="1617945212686"></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="一-初始化"><a href="#一-初始化" class="headerlink" title="一.初始化"></a>一.初始化</h4><p>初始化一个浏览器并打开一个网页，如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> webdriver = require(<span class="hljs-string">&#x27;selenium-webdriver&#x27;</span>);<span class="hljs-keyword">var</span> driver = <span class="hljs-keyword">new</span> <span class="hljs-type">webdriver</span>.Builder()    .forBrowser(<span class="hljs-string">&#x27;ie&#x27;</span>)    .build();driver.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="二-常用方法"><a href="#二-常用方法" class="headerlink" title="二.常用方法"></a>二.常用方法</h4><h5 id="1-元素定位"><a href="#1-元素定位" class="headerlink" title="1.元素定位"></a>1.元素定位</h5><ul><li><p>根据id定位</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">driver<span class="hljs-selector-class">.findElement</span>(By<span class="hljs-selector-class">.id</span>(<span class="hljs-string">&#x27;ID&#x27;</span>))；<span class="hljs-comment">//类似于jquery的$(&quot;#id&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>根据className定位</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">driver<span class="hljs-selector-class">.findElement</span>(By<span class="hljs-selector-class">.className</span>(<span class="hljs-string">&#x27;Class&#x27;</span>))；<span class="hljs-comment">//类似于jquery的$(&quot;.class&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>更多定位方式可参考：<a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html">http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html</a></p></li></ul><h5 id="2-设置元素的值"><a href="#2-设置元素的值" class="headerlink" title="2.设置元素的值"></a>2.设置元素的值</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">driver.findElement(By.id(<span class="hljs-string">&#x27;ID&#x27;</span>)).sendKeys(<span class="hljs-string">&#x27;value&#x27;</span>);<span class="hljs-regexp">//</span>类似于jquery的$(<span class="hljs-string">&quot;.id&quot;</span>).val(<span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-清空元素的值"><a href="#3-清空元素的值" class="headerlink" title="3.清空元素的值"></a>3.清空元素的值</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">driver</span><span class="hljs-selector-class">.findElement</span>(By.id(<span class="hljs-string">&#x27;id&#x27;</span>))<span class="hljs-selector-class">.clear</span>();<br></code></pre></td></tr></table></figure><h5 id="4-单击按钮"><a href="#4-单击按钮" class="headerlink" title="4.单击按钮"></a>4.单击按钮</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">driver</span><span class="hljs-selector-class">.findElement</span>(By.id(<span class="hljs-string">&#x27;id&#x27;</span>))<span class="hljs-selector-class">.click</span>();<br></code></pre></td></tr></table></figure><h5 id="5-元素等待"><a href="#5-元素等待" class="headerlink" title="5.元素等待"></a>5.元素等待</h5><p>有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-keyword">until</span> = webdriver.<span class="hljs-keyword">until</span>;driver.wait(<span class="hljs-keyword">until</span>.elementLocated(By.<span class="hljs-symbol">id</span>(<span class="hljs-string">&#x27;id&#x27;</span>), <span class="hljs-number">10000</span>));...<br></code></pre></td></tr></table></figure><h5 id="6-程序睡眠"><a href="#6-程序睡眠" class="headerlink" title="6.程序睡眠"></a>6.程序睡眠</h5><p>睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">driver</span>.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">500</span>);<span class="hljs-comment">//毫秒</span><br></code></pre></td></tr></table></figure><h5 id="7-执行JavaScript"><a href="#7-执行JavaScript" class="headerlink" title="7.执行JavaScript"></a>7.执行JavaScript</h5><p>在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">driver.execute<span class="hljs-constructor">Script(&#x27;<span class="hljs-params">location</span>.<span class="hljs-params">href</span>=<span class="hljs-string">&quot;/xx.html&quot;</span> &#x27;)</span>;<br></code></pre></td></tr></table></figure><p>或者需要给元素设置值时可以使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">driver.execute<span class="hljs-constructor">Script(&#x27;<span class="hljs-params">document</span>.<span class="hljs-params">getElementById</span>(<span class="hljs-string">&quot;id&quot;</span>)</span>.value=<span class="hljs-string">&quot;value&quot;</span>&#x27;);<span class="hljs-comment">//$(&quot;#id&quot;).val(&quot;value&quot;);</span><br></code></pre></td></tr></table></figure><h5 id="8-执行JavaScript并获取返回值"><a href="#8-执行JavaScript并获取返回值" class="headerlink" title="8.执行JavaScript并获取返回值"></a>8.执行JavaScript并获取返回值</h5><p>在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">driver.executeScript(<span class="hljs-string">&#x27;return $(&quot;#id&quot;).val()&#x27;</span>).then(<span class="hljs-keyword">function</span>(obj)&#123;    <span class="hljs-regexp">//</span>obj即为返回值    <span class="hljs-keyword">if</span>(obj&gt;<span class="hljs-number">100</span>)&#123;        <span class="hljs-regexp">//</span>操作    &#125;<span class="hljs-keyword">else</span>&#123;       <span class="hljs-regexp">//</span>其他操作    &#125;&#125;)<br></code></pre></td></tr></table></figure><h5 id="9-切换作用域（switchTo）"><a href="#9-切换作用域（switchTo）" class="headerlink" title="9.切换作用域（switchTo）"></a>9.切换作用域（switchTo）</h5><ul><li><p>切换到iframe<br>网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">driver.switch<span class="hljs-constructor">To()</span>.frame(driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;iframe-id&quot;</span>)</span>));  <span class="hljs-comment">//iframe-id为iframe元素的id</span><br></code></pre></td></tr></table></figure></li><li><p>切换到弹出框<br>有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">driver.switchTo().alert().then(<span class="hljs-keyword">function</span>(alert) &#123;     <span class="hljs-regexp">//</span>检测到弹出框时执行     <span class="hljs-regexp">//</span>关闭alert     return alert.dismiss();&#125;,<span class="hljs-keyword">function</span>()&#123;    <span class="hljs-regexp">//</span>没有检测到弹出框时执行&#125;);<br></code></pre></td></tr></table></figure></li><li><p>切换回主页面</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">driver</span><span class="hljs-selector-class">.switchTo</span>()<span class="hljs-selector-class">.defaultContent</span>();<br></code></pre></td></tr></table></figure></li></ul><h5 id="10-网页最大化（全屏）"><a href="#10-网页最大化（全屏）" class="headerlink" title="10.网页最大化（全屏）"></a>10.网页最大化（全屏）</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">driver</span><span class="hljs-selector-class">.manage</span>()<span class="hljs-selector-class">.window</span>()<span class="hljs-selector-class">.maximize</span>();<br></code></pre></td></tr></table></figure><h5 id="11-网页截图-定位"><a href="#11-网页截图-定位" class="headerlink" title="11.网页截图(定位)"></a>11.网页截图(定位)</h5><p>网页截图看上去很简单，就一行代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">driver</span><span class="hljs-selector-class">.takeScreenshot</span>()；<br></code></pre></td></tr></table></figure><p>截图后的结果为base64格式，可自行处理。类似这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">driver.takeScreenshot().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">d</span>)</span>&#123;    <span class="hljs-comment">//此处d即为截图结果base64字符串，可在此自行处理&#125;);</span><br></code></pre></td></tr></table></figure><p>但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。<br>在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">driver.findElement(<span class="hljs-meta">By</span>.className(<span class="hljs-string">&#x27;yanzheng&#x27;</span>)).th<span class="hljs-meta">en(</span>functi<span class="hljs-meta">on(</span>obj)&#123;        obj.getSize().th<span class="hljs-meta">en(</span>functi<span class="hljs-meta">on(</span>size)&#123;                      obj.getLocati<span class="hljs-meta">on(</span>).th<span class="hljs-meta">en(</span>functi<span class="hljs-meta">on(</span>loc)&#123;                driver.takeScreenshot().th<span class="hljs-meta">en(</span>functi<span class="hljs-meta">on(</span>d)&#123;                      var data=&#123;                            d:d,                            width:size.width,                            height:size.height,                            <span class="hljs-meta">x</span>:loc.<span class="hljs-meta">x</span>,                            y:loc.y                      &#125;;                    //此处省略以下两步                    //1.提交data信息到服务器处理图片                    //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置<span class="hljs-meta">x</span>,y以及长宽width,height截取相应的图片                &#125;)           &#125;        &#125;&#125;)<br></code></pre></td></tr></table></figure><h5 id="12-退出程序（关闭网页）"><a href="#12-退出程序（关闭网页）" class="headerlink" title="12.退出程序（关闭网页）"></a>12.退出程序（关闭网页）</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">driver.quit()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>更多详细文档可参考官方文档：<a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/">http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/</a></p><h4 id="下面是不错的资源"><a href="#下面是不错的资源" class="headerlink" title="下面是不错的资源"></a>下面是不错的资源</h4><p><a href="https://www.selenium.dev/documentation/zh-cn/webdriver/locating_elements/">中文文档</a></p><p><a href="https://www.yiibai.com/selenium/selenium-webdriver-first-test-case.html">易百教程</a> </p>]]></content>
    
    
    <categories>
      
      <category>Selenium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs Selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小试尤大大vuepress vue 文档神器</title>
    <link href="/2020/08/01/vuepress/"/>
    <url>/2020/08/01/vuepress/</url>
    
    <content type="html"><![CDATA[<h1 id="没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。"><a href="#没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。" class="headerlink" title="没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。"></a>没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。</h1><h2 id="个人觉得如果是vue-组件文档应该是最优选择-毕竟是vue文档工具-深度定制"><a href="#个人觉得如果是vue-组件文档应该是最优选择-毕竟是vue文档工具-深度定制" class="headerlink" title="个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)"></a>个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)</h2><h2 id="简洁至上"><a href="#简洁至上" class="headerlink" title="简洁至上"></a>简洁至上</h2><p>以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</p><h2 id="Vue-驱动"><a href="#Vue-驱动" class="headerlink" title="Vue 驱动"></a>Vue 驱动</h2><p>享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。</p><h2 id="为什么不是…"><a href="#为什么不是…" class="headerlink" title="#为什么不是…?"></a><a href="https://vuepress.vuejs.org/zh/guide/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF">#</a>为什么不是…?</h2><h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="#Nuxt"></a><a href="https://vuepress.vuejs.org/zh/guide/#nuxt">#</a>Nuxt</h3><p>VuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。</p><h3 id="Docsify-Docute"><a href="#Docsify-Docute" class="headerlink" title="#Docsify / Docute"></a><a href="https://vuepress.vuejs.org/zh/guide/#docsify-docute">#</a>Docsify / Docute</h3><p>这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="#Hexo"></a><a href="https://vuepress.vuejs.org/zh/guide/#hexo">#</a>Hexo</h3><p>Hexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。</p><h3 id="GitBook"><a href="#GitBook" class="headerlink" title="#GitBook"></a><a href="https://vuepress.vuejs.org/zh/guide/#gitbook">#</a>GitBook</h3><p>我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。</p><p>个人小试如下</p><h1 id="很快就搭建了架子-部署在了gitee-上-配置如下"><a href="#很快就搭建了架子-部署在了gitee-上-配置如下" class="headerlink" title="很快就搭建了架子 部署在了gitee 上  配置如下"></a>很快就搭建了架子 部署在了gitee 上  <strong>配置如下</strong></h1><p><img src="/2020/08/01/vuepress/1618111576451.png" alt="1618111576451"></p><p>注意配置这才会展示 官方文档有介绍  和部署域名后缀一样就ok了</p><p><img src="/2020/08/01/vuepress/1618111629200.png" alt="1618111629200"></p><p>测试效果如下</p><p><img src="/2020/08/01/vuepress/1618111726401.png" alt="1618111726401"></p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>codepen 如何引入到文档显得高大上？？？<br>如下</p><iframe height="265" style="width: 100%;" scrolling="no" title="QWdaRMR" src="https://codepen.io/gujinlonghaha/embed/preview/QWdaRMR?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/gujinlonghaha/pen/QWdaRMR'>QWdaRMR</a> by gujinlong  (<a href='https://codepen.io/gujinlonghaha'>@gujinlonghaha</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>先保存</p><p><img src="/2020/08/01/vuepress/1618111961002.png" alt="1618111961002"></p><p>然后获取iframe</p><p><img src="/2020/08/01/vuepress/1618111992615.png" alt="1618111992615"></p><p>最后直接放在md 源文件</p><p><img src="/2020/08/01/vuepress/1618112040814.png" alt="1618112040814"></p>]]></content>
    
    
    <categories>
      
      <category>vuepress</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vuepress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pupeteer自动化加版本测试</title>
    <link href="/2020/04/08/pup/"/>
    <url>/2020/04/08/pup/</url>
    
    <content type="html"><![CDATA[<h1 id="多版本谷歌测试如何进行"><a href="#多版本谷歌测试如何进行" class="headerlink" title="多版本谷歌测试如何进行"></a>多版本谷歌测试如何进行</h1><p>没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决</p><h2 id="puppeteerjs"><a href="#puppeteerjs" class="headerlink" title="puppeteerjs"></a>puppeteerjs</h2><p>你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例：</p><ul><li>生成页面 PDF。</li><li>抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。</li><li>自动提交表单，进行 UI 测试，键盘输入等。</li><li>创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。</li><li>捕获网站的 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference">timeline trace</a>，用来帮助分析性能问题。</li><li>测试浏览器扩展。</li></ul><h3 id="他其中有个模块"><a href="#他其中有个模块" class="headerlink" title="他其中有个模块"></a>他其中有个模块</h3><p><img src="/2020/04/08/pup/1617851125113.png" alt="1617851125113"></p><p>那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的   <a href="https://omahaproxy.appspot.com/">地址</a>   需要fq</p><p><img src="/2020/04/08/pup/1617851262264.png" alt="1617851262264"></p><p>是第二个箭头也就是分支切换出来的版本号码</p><p>那他支持哪些版本呢  <a href="https://npm.taobao.org/mirrors/chromium-browser-snapshots/Win_x64/">地址</a>   淘宝给出了镜像地址   下面号码拿来直接用</p><p><img src="/2020/04/08/pup/1617851479500.png" alt="1617851479500"></p><p>现在谷歌浏览器都是下载安装器然后在线安装有没离线包 </p><p><a href="https://www.chromedownloads.net/chrome64win-stable/">福利</a></p><p><img src="/2020/04/08/pup/1617851464105.png" alt="1617851464105"></p><p>自己写的部分常用脚本 以防忘记</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">const puppeteer = require(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<br>let operte=async(t) =&gt; &#123;<br><br>    <span class="hljs-regexp">//</span> 开启 browser<br>   const browserFetcher = puppeteer.createBrowserFetcher();<br>   const revisionInfo = await browserFetcher.download(<span class="hljs-string">&#x27;533271&#x27;</span>);  <span class="hljs-regexp">//</span>指定版本<br>    const vesion= await browserFetcher.localRevisions()<br>    console.log(vesion)<br>    let browser = await puppeteer.launch(&#123;<br>        executablePath: revisionInfo.executablePath,<br>        headless: false,<br>        defaultViewport: &#123;<br>            height: <span class="hljs-number">1080</span>,<br>            width: <span class="hljs-number">1920</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-regexp">//</span> 新增分页<br>    console.log(browser)<br>    let page = await browser.newPage();<br>    <span class="hljs-regexp">//</span> 到自己的网站<br>    await page.goto(`<span class="hljs-variable">$&#123;t&#125;</span>`);<br><br>     <span class="hljs-regexp">//</span> 等待订阅按钮出现<br>    <span class="hljs-regexp">//</span>  await page.waitForSelector(<span class="hljs-string">&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;</span>);<br>    <span class="hljs-regexp">//</span>  page.type(<span class="hljs-string">&#x27;#mytextarea&#x27;</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, &#123; delay: <span class="hljs-number">100</span> &#125;); <span class="hljs-regexp">//</span> 立即输入<br>    <span class="hljs-regexp">//</span>  page.type(<span class="hljs-string">&#x27;#mytextarea&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>, &#123; delay: <span class="hljs-number">100</span> &#125;); <span class="hljs-regexp">//</span> 输入变慢，像一个用户<br>    <span class="hljs-regexp">//</span>  <span class="hljs-regexp">//</span> 点击订阅按钮<br>    <span class="hljs-regexp">//</span>  await page.click(<span class="hljs-string">&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;</span>);<br>    <span class="hljs-regexp">//</span>   关闭标签页<br>    <span class="hljs-regexp">//</span> page.close()<br>    <span class="hljs-regexp">//</span> 关闭浏览器<br>    <span class="hljs-regexp">//</span> await browser.close();<br>&#125;<br><br>let arr=[<br>    <span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#x27;</span>,<br>]<br>arr.forEach(t =&gt; &#123;<br>    operte(t)<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pupeteer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pupeteer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 锁定用户版本</title>
    <link href="/2018/05/07/exe/"/>
    <url>/2018/05/07/exe/</url>
    
    <content type="html"><![CDATA[<h2 id="当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢"><a href="#当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢" class="headerlink" title="当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢?"></a>当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢?</h2><ol><li><p>升级用户浏览器 （备份用户数据 书签收藏夹）</p></li><li><p> 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑  数据独立）</p></li><li><p>  使用electron 包装应用 最简单 便捷 </p></li></ol><h3 id="前两种就不说了-这里介绍下第三种electron"><a href="#前两种就不说了-这里介绍下第三种electron" class="headerlink" title="前两种就不说了 这里介绍下第三种electron"></a>前两种就不说了 这里介绍下第三种electron</h3><p>​    先使用 </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">yarn create electron-<span class="hljs-keyword">app</span> my-<span class="hljs-keyword">app</span><br></code></pre></td></tr></table></figure><p> 然后 </p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> my-app<br>yarn <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>接着把这里</p><p><img src="/2018/05/07/exe/1617783333020.png" alt="1617783333020"></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">const</span> mainWindow = <span class="hljs-keyword">new</span> BrowserWindow(&#123;<br>    <span class="hljs-built_in">width</span>: <span class="hljs-number">1920</span>,<br>    <span class="hljs-built_in">height</span>: <span class="hljs-number">1080</span>,<br>    fullscreen:<span class="hljs-keyword">true</span>,<span class="hljs-comment">//全屏展示</span><br>    center: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 窗口居中</span><br>    resizable: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 窗口大小是否可改变</span><br>    maximizable: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 窗口是否可以最大化</span><br>    autoHideMenuBar:<span class="hljs-keyword">true</span>  <span class="hljs-comment">//关掉原始操作 重要</span><br>  &#125;);<br><br>  <span class="hljs-comment">// and load the index.html of the app.</span><br>  <span class="hljs-comment">// mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;));</span><br>  mainWindow.loadURL(<span class="hljs-string">&#x27;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#x27;</span>)<br><br>  <span class="hljs-comment">// Open the DevTools.  开发者工具</span><br>  <span class="hljs-comment">// mainWindow.webContents.openDevTools();</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>最后打包</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> publish<br></code></pre></td></tr></table></figure><p>在目录下exe 就生成了</p><p><img src="/2018/05/07/exe/1617783408979.png" alt="1617783408979"></p><p>看下效果</p><p><img src="/2018/05/07/exe/1.gif" alt="1"></p><p>好处呢 不言而喻 直接给客户exe  </p><ol><li>文件简单直接  </li><li>运行默认全屏 干净整洁</li><li> 同时内核版本自己控制</li><li>不会有其他标签页尤其适合大屏演示</li></ol>]]></content>
    
    
    <categories>
      
      <category>谷歌浏览器  electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谷歌浏览器  electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好,朋友！</title>
    <link href="/2015/07/13/hellow/"/>
    <url>/2015/07/13/hellow/</url>
    
    <content type="html"><![CDATA[<p>我是GJL,一名前端程序猿</p><p>我的博客园地址  <a href="https://www.cnblogs.com/byksj/">查看</a></p><p>个人vscode 插件开发   <a href="https://marketplace.visualstudio.com/search?term=gjl&target=VSCode&category=All%20categories&sortBy=Relevance/">查看</a></p><p><img src="/2015/07/13/hellow/cj.png"></p><p>个人开发quicker 插件地址</p><p><img src="/2015/07/13/hellow/qk.png"></p><p>自动化部署脚本<a href="https://www.npmjs.com/package/depoly-gjl">查看</a></p><p><img src="/2015/07/13/hellow/1617784176762.png" alt="1617784176762"></p><p>个人小米自动化抢购脚本  <a href="https://www.cnblogs.com/byksj/p/14504972.html">查看</a></p><p><img src="/2015/07/13/hellow/1321821-20210309131947639-1780952264.gif"></p><p>这是一些过往欢快时刻<br><img src="/2015/07/13/hellow/1.png"></p><p><img src="/2015/07/13/hellow/ps2.jpg"></p><p>2020年<br><img src="/2015/07/13/hellow/tq.jpg"><br><img src="/2015/07/13/hellow/rb.jpg"></p><p><img src="/2015/07/13/hellow/ps.jpg"></p><p>2019年</p><p><img src="/2015/07/13/hellow/wl.jpg"><br>2016年</p><p><img src="/2015/07/13/hellow/lw.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自己</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
