<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>人生的思考+追更（2021/8/4）+结更（2021/9/9）</title>
    <link href="/2021/06/21/yudong/"/>
    <url>/2021/06/21/yudong/</url>
    
    <content type="html"><![CDATA[<h2 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a><strong>关于读书</strong></h2><p>​      计划一年读12本书的，到目前为止已经读了20本书了。有些超出目标。</p><p>​     之前认为读书很难，后来发现其实也很简单，8万多字的白话文，在没有干扰的情况下可以两个小时读完，用别人的故事寻找自己的人生。人总是在前行，很少去思考，由于时间，由于精力，由于认知，但是你可以用别人多年专业总结的思考来启发你的人生。</p><ul><li> <strong>初听不知曲中意，再听已是曲中人</strong>  书不是看过就懂了，很多书只有了经历了才明白，哪怕你以前反对的也开始认同了</li><li><strong>一千个读者眼里有一千个哈姆雷特</strong>   我们能看到同样的东西，也会有不一样的见解，每个人的世界是不一样的</li><li><strong>温故而知新</strong>    即使旧的东西 也因为时间变化你的感觉在变化</li></ul><p>​     </p><h2 id="关于运动"><a href="#关于运动" class="headerlink" title="关于运动"></a><strong>关于运动</strong></h2><p>​      你必须承认的身体机能确实开始退化，身体是最宝贵的财富，他是前面的1，其他都是后面的0000，看到很多keep上用户100天挑战计划够的身体变化确实震惊了。</p><p>​     自己也开始100天锻炼计划，目前是第7天，每天100多个胸部运动 ，100多个肩部运动，100多个腹部运动</p><h4 id="读书-运动-饮食休息-情绪健康-是一生的良药，但是他要终身服用，不要想着一劳永逸，靠运气得来的东西，你别去羡慕"><a href="#读书-运动-饮食休息-情绪健康-是一生的良药，但是他要终身服用，不要想着一劳永逸，靠运气得来的东西，你别去羡慕" class="headerlink" title="读书 运动 饮食休息  情绪健康  是一生的良药，但是他要终身服用，不要想着一劳永逸，靠运气得来的东西，你别去羡慕"></a><strong>读书 运动 饮食休息  情绪健康</strong>  是一生的良药，但是他要终身服用，不要想着一劳永逸，靠运气得来的东西，你别去羡慕</h4><h2 id="人是很健忘的"><a href="#人是很健忘的" class="headerlink" title="人是很健忘的"></a><strong>人是很健忘的</strong></h2><p>  <strong>即使是自己亲自做过的事也会忘记，用进废退，只有这样你才有可能超越别人，别人也有可能超越你，一切都是动态的</strong></p><p>如果可以，希望自己每年至少锻炼100天和读12本书，多记录现在的自己，当你多年后回头看的时候就可以与现在的自己对话，可以是文字，可以是图片   </p><p><strong>8年前的自己</strong></p><p><img src="/2021/06/21/yudong/1624243910724.png" alt="1624243910724"></p><p>  <strong>现在的自己</strong></p><p><img src="/2021/06/21/yudong/1624243895885.png" alt="1624243895885"></p><p><strong>期待未来的自己</strong></p><p><strong>faq:永远不要忘了去爱你自己的身边人</strong></p><h1 id="2021-8-4-追更（50多天过去了）"><a href="#2021-8-4-追更（50多天过去了）" class="headerlink" title="2021/8/4 追更（50多天过去了）"></a><strong>2021/8/4 追更（50多天过去了）</strong></h1><p>​    100天计划目前时间过去了一半，三伏天确实够热，呼吸都会出汗的天气，但是还在坚持锻炼，可能是本身体脂率很低，效果不是特别明显，汇报下战况吧，应该做了5000+俯卧撑   10000+卷腹  效果如下</p><p><img src="/2021/06/21/yudong/1628043398119.png" alt="1628043398119"></p><p>读的书从20本目前到了快40本 如图：</p><p><img src="/2021/06/21/yudong/1628043461724.png" alt="1628043461724"></p><p>思考：即使目标是对的但是在坚持中也会有迷茫，彷徨，放弃的念头，但是人生就是对抗的过程，需要自我大旗，需要环境鼓励，回首的时候一切都值得</p><h1 id="2021-9-9-结更（100天）"><a href="#2021-9-9-结更（100天）" class="headerlink" title="2021/9/9 结更（100天）"></a><strong>2021/9/9 结更（100天）</strong></h1><p>从6月初到现在100天了，俯卧撑达到了10000+，卷腹达到了20000+，从之前俯卧撑一组10个到20到30到40到50，一天100个到最多时候480个俯卧撑。</p><p>书也是越来读的越顺，半天十万左右字的书，一天可以读20万左右的书。目前已经74本了，用几个小时去把作者一生的人生哲学浏览一遍是非常有价值的事情。</p><p><img src="/2021/06/21/yudong/56.png" alt="56"></p><p>感悟：没有繁荣稳定的大环境一切都是空中楼阁，稳定的作息和生活确实是基础条件，否则计划就是空中楼阁</p>]]></content>
    
    
    <categories>
      
      <category>思考 运动</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考 运动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为你插上翅膀的离线文档</title>
    <link href="/2021/06/14/deaddoc/"/>
    <url>/2021/06/14/deaddoc/</url>
    
    <content type="html"><![CDATA[<h3 id="因为工作或者生活导致脱离互联网"><a href="#因为工作或者生活导致脱离互联网" class="headerlink" title="因为工作或者生活导致脱离互联网"></a><strong>因为工作或者生活导致脱离互联网</strong></h3><h4 id="比如政府或者内网办公环境和国家防火墙的看不了文档怎么办"><a href="#比如政府或者内网办公环境和国家防火墙的看不了文档怎么办" class="headerlink" title="比如政府或者内网办公环境和国家防火墙的看不了文档怎么办"></a><strong>比如政府或者内网办公环境和国家防火墙的看不了文档怎么办</strong></h4><p><strong>你失去了地图</strong></p><p>大脑善于运算不善于记忆，很多文档你只需要查找不需要记忆的，而且你也记不住</p><p>你可已使用离线文档</p><p><a href="https://www.w3cschool.cn/java/">传送门</a></p><p><img src="/2021/06/14/deaddoc/1624245050916.png" alt="1624245050916"></p><p>本人之前使用如下</p><p><img src="/2021/06/14/deaddoc/1624245082444.png" alt="1624245082444"></p><p><img src="/2021/06/14/deaddoc/1624245107351.png" alt="1624245107351"></p><p>基本涵盖的主流文档</p><p><strong>如果是一些私有文档可以使用浏览器右键另存为pdf 这样你就可以复制粘贴了</strong></p><h2 id="一个小技也许就能让你重新展翅飞翔"><a href="#一个小技也许就能让你重新展翅飞翔" class="headerlink" title="一个小技也许就能让你重新展翅飞翔"></a><strong>一个小技也许就能让你重新展翅飞翔</strong></h2>]]></content>
    
    
    <categories>
      
      <category>w3c doc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>w3c doc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>亲手搭建node自动发送邮件和祝福语</title>
    <link href="/2021/05/20/eamil/"/>
    <url>/2021/05/20/eamil/</url>
    
    <content type="html"><![CDATA[<h3 id="适合场景：node-自动发送邮件-祝福语-日志-授权码-大家可以随意把玩"><a href="#适合场景：node-自动发送邮件-祝福语-日志-授权码-大家可以随意把玩" class="headerlink" title="适合场景：node 自动发送邮件  祝福语 日志 授权码  大家可以随意把玩"></a><strong>适合场景：node 自动发送邮件  祝福语 日志 授权码  大家可以随意把玩</strong></h3><p>搭建环境</p><pre><code>node init -ynpm  install  node-schedule axios nodemailer -D</code></pre><p>新建 index.js</p><pre><code class="js">var nodemailer = require(&#39;nodemailer&#39;);const axios = require(&#39;axios&#39;);const schedule = require(&quot;node-schedule&quot;);var transporter = nodemailer.createTransport(&#123;  host: &#39;smtp.qq.com&#39;,  auth: &#123;    user: &#39;自己邮箱&#39;,    pass: &#39;自己邮箱授权码&#39; //授权码,通过QQ获取   &#125;  &#125;);  var mailOptions = &#123;    from: &#39;&#39;, // 发送者    to: &#39;&#39;, // 接受者,可以同时发送多个,以逗号隔开    subject: &#39;邮件发送&#39;, // 标题    text: &#39;Hello world&#39;, // 文本    html: `&lt;h2&gt;nodemailer基本测试:&lt;/h2&gt;&lt;h3&gt;gjl测试`   &#125;;   //   网上开放api   https://api.muxiaoguo.cn/doc/caihongpi.html   function getUserAccount() &#123;    //   随机文字    return axios.get(&#39;https://api.muxiaoguo.cn/api/caihongpi&#39;);  &#125;    function getUserPermissions() &#123;    //   随机图片  https://api.loli.bj/    return axios.get(&#39;https://api.loli.bj/api/?type=json&#39;);  &#125;  function init()&#123;    axios.all([getUserAccount(), getUserPermissions()])    .then(axios.spread(function (response, imgpon) &#123;        console.log(response?.data?.data?.comment);        console.log(imgpon?.data?.url);        // 文本        mailOptions.html=response?.data?.data?.comment            // 图片        mailOptions.html=  mailOptions.html + &#39;&lt;img src=&quot;cid:ingurl&quot;/&gt;&#39;        mailOptions.attachments=[&#123;            filename: &#39;image.png&#39;,            path: imgpon?.data?.url,            cid: &#39;ingurl&#39; //same cid value as in the html img src        &#125;,        &#123;   // filename and content type is derived from path            path: &#39;./file.txt&#39;        &#125;,    ]        // 发送邮件          transporter.sendMail(mailOptions, function (err, info) &#123;          if (err) &#123;            console.log(err);            return;          &#125;          console.log(&#39;发送成功&#39;);        &#125;);      // 两个请求现在都执行完成    &#125;)).catch(function (error) &#123;        console.log(&quot;接口异常&quot;);      &#125;);;&#125;// 每格一分钟发送邮件const job = schedule.scheduleJob(&#39; */1 * * * *&#39;, function()&#123;    console.log(&#39;The answer to life, the universe, and everything!&#39;);    init()  &#125;);// 单词发送//   init()</code></pre><p>效果如下</p><p><img src="/2021/05/20/eamil/1619758351206.png" alt="1619759161403"></p><p><img src="/2021/05/20/eamil/1619758370409.png" alt="1619759161403"></p><p>faq :授权码获得</p><p> <img src="/2021/05/20/eamil/1619758513964.png" alt="1619759161403"> </p><p>部分想要拓展的配置 <img src="/2021/05/20/eamil/1619758573724.png" alt="1619759161403"> </p>]]></content>
    
    
    <categories>
      
      <category>nodemailer eamil qq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodemailer eamil qq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端不知道接口就不能爬到数据吗？直接爬html</title>
    <link href="/2021/04/25/pachong/"/>
    <url>/2021/04/25/pachong/</url>
    
    <content type="html"><![CDATA[<h4 id="一般前端都是调用接口，但是有时候碰到服务端页面一展示就是页面没有接口，怎么办呢？直接爬"><a href="#一般前端都是调用接口，但是有时候碰到服务端页面一展示就是页面没有接口，怎么办呢？直接爬" class="headerlink" title="一般前端都是调用接口，但是有时候碰到服务端页面一展示就是页面没有接口，怎么办呢？直接爬"></a>一般前端都是调用接口，但是有时候碰到服务端页面一展示就是页面没有接口，怎么办呢？直接爬</h4><p>今天的主角</p><p><img src="/2021/04/25/pachong/1619768989419.png" alt="1619768989419"></p><p>比如随便找一个网站测试</p><p><img src="/2021/04/25/pachong/1619769044711.png" alt="1619769044711"></p><p>分析html</p><p><img src="/2021/04/25/pachong/1619769095924.png" alt="1619769095924"></p><p>编写代码</p><pre><code class="js">const axios = require(&quot;axios&quot;);const cheerio = require(&quot;cheerio&quot;);const fs = require(&quot;fs&quot;);axios.get(&#39;https://www.taptap.com/top/download&#39;,&#123;&#125;).then((res)=&gt;&#123;    // console.log(res.data)  const $ = cheerio.load(res.data);  let hotList = [];//   console.log($(&quot;#topList&quot;))  $(&quot;#topList .taptap-top-card&quot;).each(function (index) &#123;    if (index !== 0) &#123;      const $td = $(this).children(&#39;.top-card-middle&#39;).eq(0);      console.log($td)      const link = $td.find(&quot;h4&quot;).text();      const text = $td.find(&quot;.card-middle-author&quot;).find(&#39;a&#39;).text();      const hotValue = $td.find(&quot;.card-middle-author&quot;).find(&#39;a&#39;).attr(&#39;herf&#39;);      hotList.push(&#123;        index,        link,        text,        hotValue,      &#125;);    &#125;  &#125;);  fs.writeFileSync(    `$&#123;__dirname&#125;/hotSearch.json`,    JSON.stringify(hotList),    &quot;utf-8&quot;  );&#125;)</code></pre><p>结果输出</p><p><img src="/2021/04/25/pachong/1619769160692.png" alt="1619769160692"></p>]]></content>
    
    
    <categories>
      
      <category>cheerio html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cheerio html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>淘宝auto抢购脚本的逆向解析尝试</title>
    <link href="/2021/04/24/autojs/"/>
    <url>/2021/04/24/autojs/</url>
    
    <content type="html"><![CDATA[<p><strong>从淘宝搜索抢购脚本发现很多黑产很多都是用auto开发的</strong></p><p><img src="/2021/04/24/autojs/1619421725035.png" alt="1619421725035"></p><p><img src="/2021/04/24/autojs/1619421753231.png" alt="1619421753231"></p><p><strong>auto 的原理他是把js 打包成apk的  咱们可以破解以后二次修改吗</strong>?</p><p>我搜索了很多方法摸索一些时间进行了尝试 （如果有更好的方法可以联系我（除了付费方案  付费方案一大堆没意义））</p><p>1 先使用开发助手将安装的apk 反编译 （本人使用破解版）</p><p><img src="/2021/04/24/autojs/1619421901755.png" alt="1619421901755"></p><p>2 使用破解工具导入project目录  <a href="https://www.anxz.com/down/98617.html">传送门</a></p><p><img src="/2021/04/24/autojs/1619422008667.png" alt="1619422008667"></p><p>结果我测试了两个软件</p><p> 一个是基本版的</p><p><img src="/2021/04/24/autojs/1619422141660.png" alt="1619422141660"></p><p>左侧是破解后基本ok  右侧是源文件 可能打包处理了 看不懂</p><p>一个是网上的付费版 破解失败 （毕竟网上靠这个吃饭 ）</p><p><img src="/2021/04/24/autojs/1619422254039.png" alt="1619422254039"></p><p><strong>结论：流程是OK的 对于未加密和混淆的软件确实可以还原解密 但是对于专业团队研发的确实破解不了</strong></p><p><strong>毕竟解密和加密都是在相互博弈</strong></p>]]></content>
    
    
    <categories>
      
      <category>脚本破解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚本 破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线魔改百度和任意定制</title>
    <link href="/2021/04/23/jsrun/"/>
    <url>/2021/04/23/jsrun/</url>
    
    <content type="html"><![CDATA[<h3 id="有时候你想改一些网站的样式，当然这个网站不属于你。甚至还向操作一些js。但是大家操作完以后些给丢掉掉。那怎么办呢？"><a href="#有时候你想改一些网站的样式，当然这个网站不属于你。甚至还向操作一些js。但是大家操作完以后些给丢掉掉。那怎么办呢？" class="headerlink" title="有时候你想改一些网站的样式，当然这个网站不属于你。甚至还向操作一些js。但是大家操作完以后些给丢掉掉。那怎么办呢？"></a><strong>有时候你想改一些网站的样式，当然这个网站不属于你。甚至还向操作一些js。但是大家操作完以后些给丢掉掉。那怎么办呢？</strong></h3><p> 其实有一款很好的插件已经解决了上述的问题，它可以安装别的依赖库，诸如代码读取页面上的变量。这样的话你就可以魔改任何网站了。当然你也可以发现更多的玩法，比如说演示类的网站在不不改源码的情况下，只对固定客户端页面的展示。</p><p><img src="/2021/04/23/jsrun/1619247682786.png" alt="1619247682786"></p><p>  <strong>在线编写js  css</strong> <strong>而且有代码提示</strong> <strong>和网站过滤规则</strong></p><p><img src="/2021/04/23/jsrun/1619246850976.png" alt="1619246850976"></p><p><strong>引入第三方库</strong></p><p><img src="/2021/04/23/jsrun/1619246912116.png" alt="1619246912116"></p><p>改完后</p><p><img src="/2021/04/23/jsrun/1619247227296.png" alt="1619247227296"></p><p>目前测试不支持跨域请求 但是需要的话可以使用我博客园推荐的插件去解决页面查询结果修改的问题</p><p><a href="https://www.cnblogs.com/byksj/p/14267026.html">我的博客园讲解地址</a></p><p>拓展：</p><p><img src="/2021/04/23/jsrun/1619247626333.png" alt="1619247626333"></p><p>大家都喜欢使用console.log  调试代码  这样代码经常容易丢</p><p>可以使用代码段执行比较好</p>]]></content>
    
    
    <categories>
      
      <category>恶搞 演示 好玩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>恶搞 演示 好玩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密你的代码和ctx可以转rar</title>
    <link href="/2021/04/20/ctxFile/"/>
    <url>/2021/04/20/ctxFile/</url>
    
    <content type="html"><![CDATA[<p>虽然自己的电脑装了一大堆谷歌插件，之前也看过谷歌插件的部分文章，但是也没有真真切切的去搞过。当真正去去使用时候还是有很多问题，也花费了很多时间，摸索了。</p><p><strong>站在巨人肩膀上虽然资料不是很多常常比较划算的一种方式，毕竟生命有限，且用且珍贵</strong>。</p><p>本人电脑插件如图：（有时候自己都不知道浏览器能不能抗住 目前我认识的人中还没有见到比我多的）</p><p>为了展示全貌，我把它缩小了，看到右边的滚动条处，直到我电脑上装了的插件不少了。</p><p><img src="/2021/04/20/ctxFile/1619245273590.png" alt="1619245273590"></p><p>自己编写的脚本如下</p><p><img src="/2021/04/20/ctxFile/1619245415928.png" alt="1619245415928"></p><p>一个源文件  一个安装后的效果  脚本作用用来抢购 基于二次封装修改</p><p><img src="/2021/04/20/ctxFile/1619245501310.png" alt="1619245501310"></p><p>遇到的问题</p><p><img src="/2021/04/20/ctxFile/1619245589252.png" alt="1619245589252"></p><p><strong>网上的文章说这两个文件不支持跨域域的，大家电脑可以自行测试。</strong></p><p>content scipt 文件你想要获取页面中原有的变量，比如说windows上面的变量。是获取不到的本人测试，</p><p>但是可以通过injected script 可以直接获取到和操作。同时使用的文件需要放到安全区域里边。</p><p><img src="/2021/04/20/ctxFile/1619245766398.png" alt="1619245766398"></p><p>这里是动态插入脚本</p><p><img src="/2021/04/20/ctxFile/1619245828392.png" alt="1619245828392"></p><p>自己可以打包成ctx文件，但是直接拖入谷歌的话。谷歌为了安全考虑，其实是启用不了的，然后会报红色的错误，咱们的话可以把ctx文件后缀直接改成rar。然后再将RAR文件解压直接拖入就可以解决了。</p><p><img src="/2021/04/20/ctxFile/1619246019326.png" alt="1619246019326"></p><p>当人们解压了这个文件的时候，其实你的源码就已经被暴露了。如何处理这个问题呢？咱们可以将关键的核心代码文件进行加密。</p><p><a href="https://www.json.cn/json/jshx.html">传送门</a></p><p><img src="/2021/04/20/ctxFile/1619246278516.png" alt="1619246278516"></p><p><img src="/2021/04/20/ctxFile/1619246267043.png" alt="1619246267043"></p>]]></content>
    
    
    <categories>
      
      <category>ctx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破解和逆向生成谷歌拓展ctx</title>
    <link href="/2021/04/18/ctx/"/>
    <url>/2021/04/18/ctx/</url>
    
    <content type="html"><![CDATA[<h2 id="当你需要给被人ctx谷歌拓展的时候怎么办"><a href="#当你需要给被人ctx谷歌拓展的时候怎么办" class="headerlink" title="当你需要给被人ctx谷歌拓展的时候怎么办"></a><strong>当你需要给被人ctx谷歌拓展的时候怎么办</strong></h2><p>   众所周知原因一般人上不去谷歌商店，同时大家也不会保存ctx原文件怎么办？（大家也可以通过国内镜像网站下载）</p><p>​    其实可以使用谷歌的逆向生成</p><p>先打开谷歌已安装插件目录一般如下：（不对自行按照路径修改）</p><pre><code>C:\Users\user\AppData\Local\Google\Chrome\User Data\Default\Extensions</code></pre><p><img src="/2021/04/18/ctx/1619074387095.png" alt="1619074387095"></p><p>这些不是认识的代码不要怕  用我的为例子</p><p><img src="/2021/04/18/ctx/1619074432211.png" alt="1619074432211"></p><p>其实就是id 代码</p><p><img src="/2021/04/18/ctx/1619074464869.png" alt="1619074464869"></p><p>点击打包程序</p><p><img src="/2021/04/18/ctx/1619074549993.png" alt="1619074549993"></p><p>输入对应拓展目录 点击打包就会生成</p><p>注意：</p><p>目录必须指向内部文件</p><p><img src="/2021/04/18/ctx/1619074634791.png" alt="1619074634791"></p><p>结果</p><p><img src="/2021/04/18/ctx/1619074674643.png" alt="1619074674643"></p><p>上层目录crx 文件生成</p><h2 id="你找到了插件目录其实就可以魔改别人代码-比如去掉广告等"><a href="#你找到了插件目录其实就可以魔改别人代码-比如去掉广告等" class="headerlink" title="你找到了插件目录其实就可以魔改别人代码  比如去掉广告等"></a><strong>你找到了插件目录其实就可以魔改别人代码  比如去掉广告等</strong></h2>]]></content>
    
    
    <categories>
      
      <category>chrome crx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chrome crx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改你的ntp服务器</title>
    <link href="/2021/04/16/ntp/"/>
    <url>/2021/04/16/ntp/</url>
    
    <content type="html"><![CDATA[<h2 id="一、NTP-是什么？"><a href="#一、NTP-是什么？" class="headerlink" title="一、NTP 是什么？"></a><strong>一、NTP 是什么？</strong></h2><p>网络时间协议，英文名称：Network Time Protocol（NTP）是用来使计算机<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5">时间同步</a>化的一种协议，它可以使<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>对其<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>或<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E6%BA%90/3219811">时钟源</a>（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE/670528">协议</a>攻击。NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务。 </p><h2 id="二、NTP-实现什么目的？"><a href="#二、NTP-实现什么目的？" class="headerlink" title="二、NTP 实现什么目的？"></a>二、NTP 实现什么目的？</h2><p>目的很简单，就是为了提供准确时间。因为我们的手表、手机、电脑等设备，经常会跑着跑着时间就出现了误差，或快或慢的少几秒，时间长了甚至误差过分钟。</p><h2 id="三、NTP-服务器列表"><a href="#三、NTP-服务器列表" class="headerlink" title="三、NTP 服务器列表"></a>三、NTP 服务器列表</h2><p>Windows系统上自带的两个：<code>time.windows.com</code> 和 <code>time.nist.gov</code><br>MacOS上自带的两个：<code>time.apple.com</code> 和 <code>time.asia.apple.com</code><br>NTP授时快速域名服务：<code>cn.ntp.org.cn</code></p><p>但是上面的基本上同步起来很慢，甚至直接同步超时，毕竟国外的服务器。所以推荐大家用国内的服务器同步。</p><h3 id="1、阿里云授时服务器"><a href="#1、阿里云授时服务器" class="headerlink" title="1、阿里云授时服务器"></a>1、阿里云授时服务器</h3><pre><code class="css">#NTP服务器ntp.aliyun.com             ntp1.aliyun.comntp2.aliyun.comntp3.aliyun.comntp4.aliyun.comntp5.aliyun.comntp6.aliyun.comntp7.aliyun.com#Time服务器time1.aliyun.comtime2.aliyun.comtime3.aliyun.comtime4.aliyun.comtime5.aliyun.comtime6.aliyun.comtime7.aliyun.com</code></pre><h3 id="2、国内大学授时服务器"><a href="#2、国内大学授时服务器" class="headerlink" title="2、国内大学授时服务器"></a>2、国内大学授时服务器</h3><pre><code class="css">s1c.time.edu.cn       北京大学 s2m.time.edu.cn       北京大学s1b.time.edu.cn       清华大学s1e.time.edu.cn       清华大学s2a.time.edu.cn       清华大学s2b.time.edu.cn       清华大学</code></pre><h3 id="3、国外授时服务器"><a href="#3、国外授时服务器" class="headerlink" title="3、国外授时服务器"></a>3、国外授时服务器</h3><pre><code class="css">#苹果提供的授时服务器   time1.apple.comtime2.apple.comtime3.apple.comtime4.apple.comtime5.apple.comtime6.apple.comtime7.apple.com#Google提供的授时服务器   time1.google.comtime2.google.comtime3.google.com</code></pre><p><a href="https://jingyan.baidu.com/article/4dc40848556be9c8d846f17d.html"><strong>window修改ntp 方法 参考百度经验</strong></a></p><p>或者工具直接修 自行搜索</p><p><img src="/2021/04/16/ntp/1618556011733.png" alt="1618556011733"></p><p>需要同步系统时间，这里分享两个时间服务器接口api给大家：</p><p>1.淘宝时间服务器时间接口</p><p><a href="http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp">http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp</a></p><p>返回json数据</p><pre><code>&#123;&quot;api&quot;:&quot;mtop.common.getTimestamp&quot;,&quot;v&quot;:&quot;*&quot;,&quot;ret&quot;:[&quot;SUCCESS::接口调用成功&quot;],&quot;data&quot;:&#123;&quot;t&quot;:&quot;1586519130440&quot;&#125;&#125;</code></pre><p>2.苏宁时间服务器接口api：</p><p><a href="http://quan.suning.com/getSysTime.do">http://quan.suning.com/getSysTime.do</a></p><p>返回json数据</p><pre><code>&#123;&quot;sysTime2&quot;:&quot;2020-04-10 19:46:50&quot;,&quot;sysTime1&quot;:&quot;20200410194650&quot;&#125;</code></pre><p>demo： 自己修改如下</p><p><img src="/2021/04/16/ntp/1618556100576.png" alt="1618556100576"></p>]]></content>
    
    
    <categories>
      
      <category>ntp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ntp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索地铁行程卡快速通过</title>
    <link href="/2021/04/16/xingcheng/"/>
    <url>/2021/04/16/xingcheng/</url>
    
    <content type="html"><![CDATA[<h1 id="探索地铁行程卡快速通过"><a href="#探索地铁行程卡快速通过" class="headerlink" title="探索地铁行程卡快速通过"></a><a href="https://www.cnblogs.com/byksj/p/14666257.html">探索地铁行程卡快速通过</a></h1><p><img src="/2021/04/16/xingcheng/1321821-20210416111317793-313987114-1618553241009.png" alt="img"></p><p> <strong>程序是方法论的流程化 让你流出更多的时间做重要的事 拓展了生命长度</strong></p><p><em><strong>*<img src="/2021/04/16/xingcheng/1321821-20210416112158970-73329117-1618553241027.png" alt="img">*</strong></em></p><p><strong>地铁入口前总是一堆人停下脚步做准备：</strong></p><ol><li><strong>低头拿出手机</strong></li><li><strong>找到通信行程卡</strong></li><li><strong>勾选同意授权</strong></li><li><strong>点击查询</strong></li><li><strong>走过去排队</strong></li><li><strong>展示绿色行程卡</strong></li></ol><p><strong>整个过程持续一分钟左右</strong></p><p><strong>有没有更好的办法呢 ？ 效果如下 只点击了一次通行图标（通行是自己写的脚本）其他都是自动化</strong></p><p><strong><img src="/2021/04/16/xingcheng/1321821-20210416112808227-97536646-1618553241067.gif" alt="img"></strong></p><p> 这样你只需点一下不需要停下脚步就可以大步流星快速通过安检</p><p><img src="/2021/04/16/xingcheng/1321821-20210416113321539-1341606448-1618553241074.png" alt="img"></p><p><strong>方法： 不会编程不要紧</strong></p><p><strong>你可以下载手机版按键精灵 <a href="http://www.anjian.com/">http://www.anjian.com/</a></strong></p><p><strong>直接把操作录制一遍 就可以播放了</strong></p><p><strong>FAQ: 录制虽然简单但是他是基于坐标（x，y）来确定的 也就是说你要保证你的网络环境和图标位置不变 对于小白来说录制确实十分简单粗暴又友好</strong></p><p><strong>如果会编程以上问题可以忽略</strong></p>]]></content>
    
    
    <categories>
      
      <category>行程卡</category>
      
    </categories>
    
    
    <tags>
      
      <tag>行程卡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>帮运维快速切换内外网(二网双选一) 另附bat 转exe</title>
    <link href="/2021/04/12/bat/"/>
    <url>/2021/04/12/bat/</url>
    
    <content type="html"><![CDATA[<h2 id="运维同事因为客户环境而发愁"><a href="#运维同事因为客户环境而发愁" class="headerlink" title="运维同事因为客户环境而发愁"></a>运维同事因为客户环境而发愁</h2><ol><li>因为客户(政府 电信等)环境是内网，</li><li>平时通信查问题是外网</li><li>来回切换网线 切换网卡 </li></ol><p>我想在网上检索个工具应该能解决吧？ 结果却不尽人意  没有合适的工具</p><p><img src="/2021/04/12/bat/1618388010418.png" alt="1618388010418"></p><p>不是根本不起作用就是只能切换ip 难道没有办法了吗？</p><h3 id="最终自己编写bat-解决-完美撒花"><a href="#最终自己编写bat-解决-完美撒花" class="headerlink" title="最终自己编写bat 解决 完美撒花"></a><strong>最终自己编写bat 解决 完美撒花</strong></h3><p>汉字 专网  WLAN 分别是是网卡对应名称  记得修改</p><pre><code class="bat">@echo offtitle gjl切换网络脚本:stillAnswerset /p switch=1切换为专网，2切换为WLAN，3切换为双网卡，4退出：if %switch% == 1 (netsh interface set interface name=&quot;专网&quot; admin=enablednetsh interface set interface name=&quot;WLAN&quot; admin=disabledecho -------------------当前网络为专网---------------------goto stillAnswer)else if %switch% == 2 (netsh interface set interface name=&quot;专网&quot; admin=disablednetsh interface set interface name=&quot;WLAN&quot; admin=enabledecho -------------------当前网络为WLAN---------------------goto stillAnswer)else if %switch% == 3 (netsh interface set interface name=&quot;专网&quot; admin=enablednetsh interface set interface name=&quot;WLAN&quot; admin=enabledecho -------------------双网卡同时启动---------------------goto stillAnswer)else if %switch% == 4 (exit)::netsh interface set interface name=&quot;WLAN&quot; admin=disabled::netsh interface set interface name=&quot;专网&quot; admin=enabled::netsh interface set interface name=&quot;WLAN&quot; admin=enabled::netsh interface set interface name=&quot;专网&quot; admin=disabled</code></pre><p>新建bat文件保存后<strong>管理员身份</strong>运行 效果如下：</p><p><img src="/2021/04/12/bat/1618388625946.png" alt="1618388625946"></p><p>这样还不够完美 我有用bat 转为exe </p><p><img src="/2021/04/12/bat/1618388732373.png" alt="1618388732373"></p><p>如何bat转exe?   工具我上传了</p><p>下载:<a href="https://wws.lanzous.com/iVXwko1hiqb">https://wws.lanzous.com/iVXwko1hiqb</a> 密码:9qtj</p><p>我也发布到了quicker</p><p><img src="/2021/04/12/bat/1618389340230.png" alt="1618389340230"></p><p>FAQ:  <a href="https://blog.csdn.net/qq_35038153/article/details/78430359">中文乱码解决方案</a></p><p>讲解：</p>]]></content>
    
    
    <categories>
      
      <category>网卡 bat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网卡 bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白嫖域名体验之旅</title>
    <link href="/2021/04/11/yuming/"/>
    <url>/2021/04/11/yuming/</url>
    
    <content type="html"><![CDATA[<h1 id="vercel"><a href="#vercel" class="headerlink" title="vercel"></a><strong>vercel</strong></h1><p><a href="https://vercel.com/">传送门</a></p><p><img src="/2021/04/11/yuming/1618308519425.png" alt="1618308519425"></p><p><img src="/2021/04/11/yuming/1618308573346.png" alt="1618308573346"></p><p>登陆完导入仓库就完事了</p><p><img src="/2021/04/11/yuming/1618308603421.png" alt="1618308603421"></p><p><a href="https://docsify-test-khaki.vercel.app/#/test">效果地址</a>  </p><p><img src="/2021/04/11/yuming/1618308702879.png" alt="1618308702879"></p><h1 id="netlify"><a href="#netlify" class="headerlink" title="netlify"></a><strong>netlify</strong></h1><p><img src="/2021/04/11/yuming/1618308822537.png" alt="1618308822537"></p><p><img src="/2021/04/11/yuming/1618308889528.png" alt="1618308889528"></p><p><a href="https://kind-yalow-4fec17.netlify.app/#/test">效果地址</a></p><p><img src="/2021/04/11/yuming/1618308758717.png" alt="1618308758717"></p><h3 id="说白了个gitee-差不多-只不过是国外的罢了-都是github-登录-然如导入仓库-next-毕竟多了两个选择"><a href="#说白了个gitee-差不多-只不过是国外的罢了-都是github-登录-然如导入仓库-next-毕竟多了两个选择" class="headerlink" title="说白了个gitee 差不多 只不过是国外的罢了 都是github 登录  然如导入仓库  next    毕竟多了两个选择"></a>说白了个gitee 差不多 只不过是国外的罢了 都是github 登录  然如导入仓库  next    毕竟多了两个选择</h3><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><h1 id="jsorg"><a href="#jsorg" class="headerlink" title="jsorg"></a><strong><a href="https://js.org/">jsorg</a></strong></h1><p><img src="/2021/04/11/yuming/1618308972875.png" alt="1618308972875"></p><p><img src="/2021/04/11/yuming/1618309067875.png" alt="1618309067875"></p><h3 id="如果你的项目足够优秀可以使用jsorg"><a href="#如果你的项目足够优秀可以使用jsorg" class="headerlink" title="如果你的项目足够优秀可以使用jsorg"></a><strong>如果你的项目足够优秀可以使用jsorg</strong></h3>]]></content>
    
    
    <categories>
      
      <category>netlify vercel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域名  测试  netlify vercel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的图床</title>
    <link href="/2021/04/09/imgurl/"/>
    <url>/2021/04/09/imgurl/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是图床"><a href="#1-什么是图床" class="headerlink" title="1. 什么是图床"></a>1. 什么是图床</h2><p>简单来说就是存储图片的服务器，将图片上传至该服务器中后，可以在公网中通过指定的URL获取此图片。</p><h2 id="2-图床的意义"><a href="#2-图床的意义" class="headerlink" title="2. 图床的意义"></a>2. 图床的意义</h2><ul><li>减轻服务器带宽压力：图片资源可以由单独的服务器来存储、访问，例如腾讯云的COS、阿里云的OSS、七牛云等产品。</li><li>提供CDN加速：可以通过CDN的就近访问原则加快图片的访问速度。</li><li>第三条也就是最重要的一条，就是方便写文章。</li></ul><h2 id="3-搭建图床"><a href="#3-搭建图床" class="headerlink" title="3. 搭建图床"></a>3. 搭建图床</h2><blockquote><p>这里采用gitee作为图片仓库有两点原因，第一点是因为它是免费的，省去了自己维护服务器的费用。第二是因为它是国内的一个网站，所以相比与github来说，访问速度会更快一些。（后来试了一下github感觉也挺快的，差别并不明显，应该是使用了jsdelivr CDN的缘故）</p></blockquote><h3 id="码云图床限制如下"><a href="#码云图床限制如下" class="headerlink" title="码云图床限制如下"></a>码云图床限制如下</h3><blockquote><table><thead><tr><th align="left">功能特性</th><th align="left">社区版</th><th align="left">企业版</th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">使用场景</td><td align="left">开源项目</td><td align="left">个人私有仓库</td><td align="left">免费版</td><td align="left">协作开发</td></tr><tr><td align="left">总计协作人数</td><td align="left">不限</td><td align="left">≦ 5 人</td><td align="left">≦ 5 人</td><td align="left">20 ~ 100 人+</td></tr><tr><td align="left">仓库总容量</td><td align="left">5G</td><td align="left">5G</td><td align="left">5G</td><td align="left">20 ~ 100G</td></tr><tr><td align="left">单仓库大小</td><td align="left">1G</td><td align="left">500M</td><td align="left">500M</td><td align="left">1 ~ 3G</td></tr><tr><td align="left">单文件大小</td><td align="left">50M</td><td align="left">50M</td><td align="left">50M</td><td align="left">100 ~ 300M</td></tr><tr><td align="left">附件总容量</td><td align="left">3G</td><td align="left">3G</td><td align="left">3G</td><td align="left">10 ~ 50G +</td></tr></tbody></table></blockquote><h3 id="创建图片仓库"><a href="#创建图片仓库" class="headerlink" title="创建图片仓库"></a>创建图片仓库</h3><p><img src="/2021/04/09/imgurl/1618304402333.png" alt="1618304402333"></p><p>大部分是用  <a href="https://github.com/Molunerfinn/PicGo/releases">传送门</a></p><p><img src="/2021/04/09/imgurl/1618304505269.png" alt="1618304505269"></p><p>我用的是utool的图床</p><p><img src="/2021/04/09/imgurl/1618304605851.png" alt="1618304605851"></p><h2 id="从此你就有了自己的图床了"><a href="#从此你就有了自己的图床了" class="headerlink" title="从此你就有了自己的图床了"></a>从此你就有了自己的图床了</h2>]]></content>
    
    
    
    <tags>
      
      <tag>图床 图片 gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多端同步验证方案汇总</title>
    <link href="/2021/04/06/chormeText/"/>
    <url>/2021/04/06/chormeText/</url>
    
    <content type="html"><![CDATA[<p>BrowserShots</p><p>地址：</p><p><a href="http://browsershots.org/">http://browsershots.org</a></p><p>作为首批跨浏览器测试网站之一，支持多种浏览器，包括一些旧浏览器，如 Lynx、Konqueror 和 Seamonkey。</p><p>它会生成屏幕截图，显示你的网站在不同浏览器中的渲染表现，唯一的缺点是需要在线使用该工具。</p><p><img src="/2021/04/06/chormeText/640.png" alt="图片"></p><p>Browser Sandbox</p><p>地址：</p><p><a href="https://turbo.net/browsers">https://turbo.net/browsers</a></p><p>它是一款可运行在桌面和平板上的应用程序，可以像运行原生浏览器那样运行多种浏览器。</p><p>它支持的浏览器种类很多，包括旧版本的 IE、Canary 及开发版的 IE。</p><p><img src="/2021/04/06/chormeText/1618298424509.png" alt="1618298424509"></p><p>MultiBrowser</p><p>地址：</p><p><a href="https://www.multibrowser.com/">https://www.multibrowser.com</a></p><p>一款桌面应用程序，支持 IE7 到 IE11、Edge、Firefox 和 Chrome。你可以用它来测试网站的桌面版本和移动版本，可以进行手动测试或自动化测试。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p><p>LambdaTest</p><p>地址：</p><p><a href="https://www.lambdatest.com/">https://www.lambdatest.com</a></p><p>一个在线服务，可用来进行不同平台的跨浏览器测试。例如，你可以测试网站在 Windows、Linux、macOS 上的不同浏览器（Firefox 或 Chrome）中的表现。</p><p>它还提供了一个集成调试工具、地理位置工具，可以用来测试本地站点。</p><p><img src="/2021/04/06/chormeText/640.png" alt="图片"></p><p>Experitest Cross Browser Testing</p><p>地址：</p><p><a href="https://experitest.com/cross-browser-testing">https://experitest.com/cross-browser-testing</a></p><p>这个工具可以用来测试网站在不同环境下的兼容性和性能。它还可以与其他服务集成起来，比如 Github、Gitlab、Jenkins、TravisCI 和 CircleCI 等，把网站的部署流程流水线化。</p><p><img src="/2021/04/06/chormeText/640-1618298248548.png" alt="图片"></p><p>BrowserStack</p><p>地址：</p><p><a href="https://www.browserstack.com/">https://www.browserstack.com</a></p><p>跨浏览器测试领域响当当的一款工具，被一些大型开源项目采用，比如 jQuery 和 React.js。BrowserStack 列出了数百种浏览器、设备和测试策略，确保你的网站可以在尽可能多的环境中正常运行。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>SauceLabs</p><p>地址：</p><p><a href="https://saucelabs.com/">https://saucelabs.com</a></p><p>SauceLabs 为各种规模的网站提供了完整的浏览器兼容性测试工具，不管是企业级的、中小型公司还是开源项目。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p><p>CrossBrowserTesting</p><p>地址：</p><p><a href="https://crossbrowsertesting.com/">https://crossbrowsertesting.com</a></p><p>使用这个工具，可以不写代码进行自动化浏览器兼容性测试，可以测试线上或本地站点，还可以截取屏幕快照和视频。</p><p><img src="/2021/04/06/chormeText/640-1618298248490.png" alt="图片"></p><p>TestingBot</p><p>地址：</p><p><a href="https://testingbot.com/">https://testingbot.com</a></p><p>TestingBot 为网站和原生移动 App 提供了完整的测试策略，可以在真实的 iOS 或 Android 设备上运行测试。</p><p><img src="/2021/04/06/chormeText/640-1618298248633.png" alt="图片"></p><p>Browserling</p><p>地址：</p><p><a href="https://www.browserling.com/">https://www.browserling.com</a></p><p>如果你想要在 IE 上进行快速测试，BrowserLing 或许是个不错的选择。</p><p>你可以用它进行简单的交互式测试，支持一些旧浏览器，比如 IE 10、IE 11 和 Safari 4、Safari 5。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p><p>Comparium</p><p>地址：</p><p><a href="https://comparium.app/">https://comparium.app</a></p><p>Comparium 提供了一个免费的工具，可以截取不同环境下的屏幕快照，并进行比对。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p><p>Puppeteer</p><p>地址：</p><p><a href="https://github.com/puppeteer/puppeteer">https://github.com/puppeteer/puppeteer</a></p><p>Puppeteer 是一个 Node.js 模块，提供了与 Chrome 和 Firefox 交互的 API。</p><p>你可以用它提供的 API 来截取屏幕快照、生成 PDF、进行自动化交互式测试（比如自动填写表单、键盘输入），整体上可以进行自动化网站测试。</p><p><img src="/2021/04/06/chormeText/640-1618298248541.png" alt="图片"></p><p>Playwright</p><p>地址：</p><p><a href="https://github.com/microsoft/playwright">https://github.com/microsoft/playwright</a></p><p>Playwright 是微软设计的一个项目，用于执行自动化浏览器测试。它提供了一个简单的 API。除了可以模拟用户交互，还可以拦截网络请求、模拟移动设备、支持地理位置数据和权限控制。</p><p>Playwright 支持基于 Chromium 的浏览器、Firefox 和 Webkit（比如 Safari）。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p><p>Nightwatch.js</p><p>地址：</p><p><a href="https://nightwatchjs.org/">https://nightwatchjs.org</a></p><p>NightWatch.js 是一个用于进行端到端侧二十的 Node.js 模块。它提供了简单易用的 API，可用它检查某个元素是否包含了特定的文本或是否可见，甚至是可以用来测试 CSS 类、CSS ID 和属性。</p><p><img src="/2021/04/06/chormeText/640-1618298248649.png" alt="图片"></p><p>Cypress</p><p>地址：</p><p><a href="https://www.cypress.io/">https://www.cypress.io</a></p><p>Cypress 是一个端到端测试套件，可用来测试和调试现代 Web 应用程序。</p><p>它在执行测试的同时还能记录下每一个测试的状态。你可以回溯每一个状态，并比较状态之间都发生了什么变化，这让 Web 应用程序的调试变得很直观。</p><p><img src="/2021/04/06/chormeText/640-1618298248526.png" alt="图片"></p><p>WebDriverIO</p><p>地址：</p><p><a href="https://webdriver.io/">https://webdriver.io</a></p><p>这是一款 Node.js 自动化测试框架，支持很多 JavaScript 库，比如 React.js、Vue 和 Angular。</p><p>因为它是基于 W3C WebDriver 和 Chrome DevTools 的，所以可以在本地运行，也可以在云端运行，就像 SauceLab、BrowserStack 和 TestingBot 那样。</p><p><img src="/2021/04/06/chormeText/640-1618298248370.png" alt="图片"></p><p>Selenium</p><p>地址：</p><p><a href="https://www.selenium.dev/">https://www.selenium.dev</a></p><p>Selenium 是一款浏览器自动化测试工具。实际上，它并没有提供现成的测试框架，但可以通过扩展来实现。</p><p>很多测试框架、App 或服务，包括上述的一些工具都是基于 Selenium 的。</p><p><img src="/2021/04/06/chormeText/640.webp" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>展示  预览  浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>展示  预览  浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公司文档生成利器</title>
    <link href="/2021/04/04/docsify/"/>
    <url>/2021/04/04/docsify/</url>
    
    <content type="html"><![CDATA[<p>个人使用过hexo 等生成器但是这个是真厉害 因为他<strong>不需要</strong>把makdown 转化html 的编译过程<strong>启动极快</strong></p><p>还有几个独特的优势</p><ol><li>离线缓存</li><li>不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD </li><li>支持vue</li></ol><p>花了半小时测测试效果如下  真好看  即使是公司的人不会代码也是轻而易举搞定</p><p><img src="/2021/04/04/docsify/1618050136294.png" alt="1618050136294"></p><p><img src="/2021/04/04/docsify/1618050169962.png" alt="1618050169962"></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%BC%80%E5%A7%8B">开始</a></h1><p>首选全局安装<code>docsify-cli</code></p><pre><code class="bash"> npm i docsify-cli -g</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></h2><p>初始化会自动生成<code>./docs</code>文件夹</p><pre><code class="bash">docsify init ./docs// 如果不想新建一个文件夹，可以直接进行初始化操作docsify init</code></pre><h2 id="建立第一个文档"><a href="#建立第一个文档" class="headerlink" title="建立第一个文档"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3">建立第一个文档</a></h2><p>初始化之后目录结构如下</p><pre><code class="text">|—— docs    |—— index.html 入口    |—— README.md 主页    |—— .nojekyll 防止Github忽视下划线开头文件</code></pre><h2 id="预览网站"><a href="#预览网站" class="headerlink" title="预览网站"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/%E5%BC%80%E5%A7%8B?id=%E9%A2%84%E8%A7%88%E7%BD%91%E7%AB%99">预览网站</a></h2><p>执行以下命令，预览网站就在<code>http://localhost:3000</code>网址打开</p><pre><code class="bash">cd docsdocsify serve</code></pre><h1 id="离线缓存（PWA）"><a href="#离线缓存（PWA）" class="headerlink" title="离线缓存（PWA）"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%EF%BC%88pwa%EF%BC%89">离线缓存（PWA）</a></h1><h2 id="1-创建一个-servieWorker"><a href="#1-创建一个-servieWorker" class="headerlink" title="1. 创建一个 servieWorker"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=_1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-servieworker">1. 创建一个 servieWorker</a></h2><blockquote><p>根目录下创建<code>sw.js</code>文件</p></blockquote><pre><code class="js">/* =========================================================== * docsify sw.js * =========================================================== * Copyright 2016 @huxpro * Licensed under Apache 2.0 * Register service worker. * ========================================================== */const RUNTIME = &quot;docsify&quot;;const HOSTNAME_WHITELIST = [self.location.hostname, &quot;fonts.gstatic.com&quot;, &quot;fonts.googleapis.com&quot;, &quot;cdn.jsdelivr.net&quot;];// The Util Function to hack URLs of intercepted requestsconst getFixedUrl = (req) =&gt; &#123;  var now = Date.now();  var url = new URL(req.url);  // 1. fixed http URL  // Just keep syncing with location.protocol  // fetch(httpURL) belongs to active mixed content.  // And fetch(httpRequest) is not supported yet.  url.protocol = self.location.protocol;  // 2. add query for caching-busting.  // Github Pages served with Cache-Control: max-age=600  // max-age on mutable content is error-prone, with SW life of bugs can even extend.  // Until cache mode of Fetch API landed, we have to workaround cache-busting with query string.  // Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190  if (url.hostname === self.location.hostname) &#123;    url.search += (url.search ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;cache-bust=&quot; + now;  &#125;  return url.href;&#125;;/** *  @Lifecycle Activate *  New one activated when old isnt being used. * *  waitUntil(): activating ====&gt; activated */self.addEventListener(&quot;activate&quot;, (event) =&gt; &#123;  event.waitUntil(self.clients.claim());&#125;);/** *  @Functional Fetch *  All network requests are being intercepted here. * *  void respondWith(Promise&lt;Response&gt; r) */self.addEventListener(&quot;fetch&quot;, (event) =&gt; &#123;  // Skip some of cross-origin requests, like those for Google Analytics.  if (HOSTNAME_WHITELIST.indexOf(new URL(event.request.url).hostname) &gt; -1) &#123;    // Stale-while-revalidate    // similar to HTTP&#39;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale    // Upgrade from Jake&#39;s to Surma&#39;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1    const cached = caches.match(event.request);    const fixedUrl = getFixedUrl(event.request);    const fetched = fetch(fixedUrl, &#123; cache: &quot;no-store&quot; &#125;);    const fetchedCopy = fetched.then((resp) =&gt; resp.clone());    // Call respondWith() with whatever we get first.    // If the fetch fails (e.g disconnected), wait for the cache.    // If there’s nothing in cache, wait for the fetch.    // If neither yields a response, return offline pages.    event.respondWith(      Promise.race([fetched.catch((_) =&gt; cached), cached])        .then((resp) =&gt; resp || fetched)        .catch((_) =&gt; &#123;          /* eat any errors */        &#125;)    );    // Update the cache with the version we fetched (only for ok status)    event.waitUntil(      Promise.all([fetchedCopy, caches.open(RUNTIME)])        .then(([response, cache]) =&gt; response.ok &amp;&amp; cache.put(event.request, response))        .catch((_) =&gt; &#123;          /* eat any errors */        &#125;)    );  &#125;&#125;);</code></pre><h2 id="2-在index-html文件中注册"><a href="#2-在index-html文件中注册" class="headerlink" title="2. 在index.html文件中注册"></a><a href="https://jingping-ye.github.io/docsify-docs-zh/#/%E6%8C%87%E5%8D%97/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98?id=_2-%E5%9C%A8indexhtml%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B3%A8%E5%86%8C">2. 在<code>index.html</code>文件中注册</a></h2><pre><code class="html">&lt;script&gt;  if (typeof navigator.serviceWorker !== &quot;undefined&quot;) &#123;    navigator.serviceWorker.register(&quot;sw.js&quot;);  &#125;&lt;/script&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>docsify  文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docsify  文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易版exe 打包</title>
    <link href="/2021/04/01/ahk/"/>
    <url>/2021/04/01/ahk/</url>
    
    <content type="html"><![CDATA[<h1 id="AHK自动热键"><a href="#AHK自动热键" class="headerlink" title="AHK自动热键"></a><strong>AHK</strong>自动热键</h1><p>强大的Windows的终极自动化脚本语言。</p><p><a href="https://www.autohotkey.com/docs/Hotkeys.htm#Intro"><img src="/2021/04/01/ahk/features-bootstrap.png" alt="img"></a></p><h3 id="键绑定"><a href="#键绑定" class="headerlink" title="键绑定"></a>键绑定</h3><p>定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！</p><p><a href="https://en.wikipedia.org/wiki/AutoHotkey"><img src="/2021/04/01/ahk/features-blocks.png" alt="img"></a></p><h3 id="什么是自动热键"><a href="#什么是自动热键" class="headerlink" title="什么是自动热键"></a>什么是自动热键</h3><p>AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等</p><p><a href="https://autohotkey.com/download/ahk-install.exe">下载地址</a></p><p>安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器</p><p><img src="/2021/04/01/ahk/1617959488146.png" alt="1617959488146"></p><p>窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！</p><p><img src="/2021/04/01/ahk/1617959539175.png" alt="1617959539175"></p><p>随便编写个脚本如下</p><pre><code>#z::Run https://autohotkey.com  ; Win+Z</code></pre><p><img src="/2021/04/01/ahk/1617959708823.png" alt="1617959708823"></p><p>右键可以编译脚本为exe   如上图</p><p>tets.exe  双击启动 按下winow+z 就会自动打开   <a href="https://autohotkey.com/">https://autohotkey.com</a>    网址 </p><p>其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe  对方得安装ahk 才可以    虽然是exe 可能底层还是需要ahk 的运行环境吧）</p>]]></content>
    
    
    <categories>
      
      <category>ahk exe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ahk exe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记：网页调用app 启动并打开固定地址</title>
    <link href="/2021/03/30/qidong/"/>
    <url>/2021/03/30/qidong/</url>
    
    <content type="html"><![CDATA[<p>我们能在浏览器内跳转网页是http、https协议，能打开本地文件是file协议，调用APP用的是scheme协议或者intent协议，其实都是发送请求，获得响应，只是网页和APP是使用这两个协议通信的。scheme协议不仅仅用于ios端，也适用于安卓。但intent只适用于安卓。</p><h2 id="1、scheme协议"><a href="#1、scheme协议" class="headerlink" title="1、scheme协议"></a>1、scheme协议</h2><p>在 iOS 里，程序之间都是相互隔离，目前并没有一个有效的方式来做程序间通信，幸好 iOS 程序可以很方便的注册自己的 URL Scheme，这样就可以通过打开特定 URL 的方式来传递参数给另外一个程序。原生的APP和网页通过这种协议可以互相通信，safari或者APP的webView都可以识别该协议（一些浏览器如微信内置浏览器和QQ浏览器不支持，据后台技术哥哥介绍这是腾讯有意屏蔽，默认的webview控件是支持的）.</p><p>如果是自己的APP想被网页调用，需要自己在app中注册scheme，这不是我研究的范畴。。。</p><p>我们一般是调用别人的APP，会使用scheme协议就行,其实特简单，<strong>通过链接就可以</strong>。</p><h3 id="常用APP的scheme"><a href="#常用APP的scheme" class="headerlink" title="常用APP的scheme"></a>常用APP的scheme</h3><p>QQ mqq://<br>微信 weixin://<br>淘宝 taobao://<br>大众点评 dianping:// dianping://search<br>新浪微博 sinaweibo://<br>支付宝 alipay://<br>豆瓣fm doubanradio://<br>美团 imeituan://<br>1号店 wccbyihaodian://<br>有道词典yddictproapp://<br>知乎 zhihu://<br>优酷 youku://</p><p>见知乎上的整理：<a href="http://www.zhihu.com/question/19907735">http://www.zhihu.com/question/19907735</a></p><h2 id="2、intent协议"><a href="#2、intent协议" class="headerlink" title="2、intent协议"></a>2、intent协议</h2><p>“在一个Android应用中，主要是由四种组件组成的，这四种组件可参考“Android应用的构成”。而这四种组件是独立的，它们之间可以互相调用，协调工作，最终组成一个真正的Android应用。在这些组件之间的通讯中，主要是由Intent协助完成的。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。”所以说intent是协议是不准确的，intent实际上是一种在不同组件之间传递的请求信息。</p><h1 id="示例：网页调取百度地图、高德地图"><a href="#示例：网页调取百度地图、高德地图" class="headerlink" title="示例：网页调取百度地图、高德地图"></a>示例：网页调取百度地图、高德地图</h1><p>官方文档：</p><p>1、高德地图：<a href="http://lbs.amap.com/api/uri-api/ios-uri-explain/">http://lbs.amap.com/api/uri-api/ios-uri-explain/</a></p><p>2、百度地图：<a href="http://developer.baidu.com/map/index.php?title=uri/api/ios">http://developer.baidu.com/map/index.php?title=uri/api/ios</a></p><p>测试：</p><pre><code>&lt;a href=&quot;taobao://detail.m.tmall.com/item.htm?spm=a2141.8971817.50003458.1&amp;id=612053462785&amp;scm=1007.15522.117270.cat:50003458_industry:_cattype:cat_id:612053462785&amp;pvid=0982d09f-d63f-438f-af91-5434a11305f4&amp;scene=5522&quot;&gt;大萨达撒&lt;/a&gt;</code></pre><p>手机端调用页面 </p><p>页面地址获取</p><p><img src="/2021/03/30/qidong/1619772927650.png" alt="1619772927650"></p>]]></content>
    
    
    <categories>
      
      <category>app</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓应用控件获取方法</title>
    <link href="/2021/03/20/app/"/>
    <url>/2021/03/20/app/</url>
    
    <content type="html"><![CDATA[<h2 id="网上随便搜索都是需要java-sdk-等安卓adb-工具才能实现"><a href="#网上随便搜索都是需要java-sdk-等安卓adb-工具才能实现" class="headerlink" title="网上随便搜索都是需要java sdk  等安卓adb 工具才能实现"></a>网上随便搜索都是需要java sdk  等安卓adb 工具才能实现</h2><h3 id="要不然就是Appium-手机自动化工具"><a href="#要不然就是Appium-手机自动化工具" class="headerlink" title="要不然就是Appium 手机自动化工具"></a>要不然就是Appium 手机自动化工具</h3><p><img src="/2021/03/20/app/1617953614313.png" alt="1617953614313"></p><p><img src="/2021/03/20/app/1617953651490.png" alt="1617953651490"></p><p>不懂的人直接头皮发麻 直接劝退</p><h4 id="而且有效信息只有一页-差点放弃"><a href="#而且有效信息只有一页-差点放弃" class="headerlink" title="而且有效信息只有一页 差点放弃"></a><strong>而且有效信息只有一页 差点放弃</strong></h4><p><img src="/2021/03/20/app/1617953729754.png" alt="1617953729754"></p><p>之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式）</p><p><img src="/2021/03/20/app/1617954307011.png" alt="1617954307011"></p><p>针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现</p><h4 id="特此记录-（踏破铁鞋无匿处）-真是难者不会-会者不难-一个知识和工具就是巨大鸿沟"><a href="#特此记录-（踏破铁鞋无匿处）-真是难者不会-会者不难-一个知识和工具就是巨大鸿沟" class="headerlink" title="特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难  一个知识和工具就是巨大鸿沟"></a><strong>特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难  一个知识和工具就是巨大鸿沟</strong></h4><p><a href="https://www.coolapk.com/apk/com.toshiba_dealin.developerhelper">1地址</a>      开发者工具简单好用</p><p><img src="/2021/03/20/app/1617953969262.png" alt="1617953969262"></p><p><a href="https://app.mi.com/details?id=com.yichuang.quickerapp&ref=search">地址</a></p><p>效果</p><p><img src="/2021/03/20/app/1617954371068.png" alt="1617954371068"></p><p>2手机版quicker  <img src="/2021/03/20/app/1617954121135.png" alt="1617954121135"></p><p>效果如下</p><p><img src="/2021/03/20/app/1617954143390.png" alt="1617954143390"></p><p>从此以后你就可以编写自动化手机脚本无压力了   解放你的双手</p><ol><li> 自动打卡</li><li> 自动抢购</li><li>自动导航</li></ol>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不克隆仓库也可以迅速学习 git神技巧</title>
    <link href="/2021/03/20/git/"/>
    <url>/2021/03/20/git/</url>
    
    <content type="html"><![CDATA[<p>很多人都是在git 找到优秀仓库学习<br>先下载下来<br>但是网络慢不说<br>只是初步浏览没必要</p><p>优秀的人是是装浏览器git 树组件</p><p>但是vscoe + git 才是真香定律</p><p>比如 </p><p><a href="https://github.com/PanJiaChen/vue-element-admin/">这个仓库</a></p><p><img src="/2021/03/20/git/1635234648271.png" alt="1635234648271"></p><p>只需要地址栏加上 1s 就可以欢快学习源码</p><p><img src="/2021/03/20/git/1635234742696.png" alt="1635234742696"></p><p><img src="/2021/03/20/git/1635234797207.png" alt="1635234797207"></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nodejs+Selenium环境搭建以及深坑</title>
    <link href="/2021/03/09/sele/"/>
    <url>/2021/03/09/sele/</url>
    
    <content type="html"><![CDATA[<h1 id="“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”"><a href="#“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”" class="headerlink" title="“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”"></a><em>“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”</em></h1><p>这个sologan 还是够硬的，不过确实如此。</p><p>Selenium有以下功能特性:</p><ul><li>Selenium是一个开源和可移植的Web测试框架。</li><li>Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。</li><li>它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。</li><li>Selenium支持各种操作系统，浏览器和编程语言。如下列表:<ul><li><strong>编程语言</strong>: C# ，Java，Python，PHP，Ruby，Perl和JavaScript</li><li><strong>操作系统</strong>:Android，iOS，Windows，Linux，Mac，Solaris。</li><li><strong>浏览器</strong>:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。</li></ul></li><li>它还支持并行测试执行，从而减少了时间并提高了测试效率。</li><li>Selenium可以与Ant和Maven等框架集成，用于源代码编译。</li><li>Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。</li><li>与其他自动化测试工具相比，Selenium需要的资源更少。</li><li>WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。</li><li>Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。</li><li>Selenium命令根据不同的类进行分类，使其更易于理解和实现。</li><li>Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。</li></ul><p>局限性主要如下：</p><ul><li>Selenium不支持桌面应用程序的自动化测试。</li><li>Selenium需要高技能才能更有效地自动化测试。</li><li>由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。</li><li>无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。</li><li>使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。</li><li>它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。</li><li>Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。</li><li>无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。</li><li>与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。</li><li>新功能没有人可能少人使用，它们可能会也可能不会正常工作。</li><li>Selenium不为测试管理提供任何测试工具集成。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="1-安装-Nodejs"><a href="#1-安装-Nodejs" class="headerlink" title="1.安装 Nodejs"></a>1.安装 Nodejs</h4><p>到<a href="https://nodejs.org/en/download/">Nodejs</a>官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。</p><blockquote><p>node -v</p></blockquote><h4 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2.项目初始化"></a>2.项目初始化</h4><p>创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令：</p><blockquote><p>npm init</p></blockquote><h4 id="3-配置selenium运行环境"><a href="#3-配置selenium运行环境" class="headerlink" title="3.配置selenium运行环境"></a>3.配置selenium运行环境</h4><p>在上一步相同的命令行下运行以下命令至其运行安装完成。</p><blockquote><p>npm install selenium-webdriver –save</p></blockquote><h4 id="4-安装浏览器驱动"><a href="#4-安装浏览器驱动" class="headerlink" title="4.安装浏览器驱动"></a>4.安装浏览器驱动</h4><ul><li><p>安装Chrome驱动</p><blockquote><p>npm install chromedriver –save</p></blockquote></li><li><p>安装Firefox驱动</p><blockquote><p>npm install geckodriver –save</p></blockquote></li><li><p>安装IE驱动</p><blockquote><p>npm install iedriver –save</p></blockquote></li></ul><p>说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：<a href="http://www.seleniumhq.org/download/">http://www.seleniumhq.org/download/</a></p><h3 id="可能会碰到问题"><a href="#可能会碰到问题" class="headerlink" title="可能会碰到问题"></a>可能会碰到问题</h3><p>1）“The ChromeDriver could not be found on the current PATH”</p><p>需要将 ChromeDriver 添加到系统的环境变量 Path 中   也是就是你下载的exe 路径  自行更改</p><p>我本地还是失败 最终直接把exe  与脚本相同的目录下 运行正常   这个折腾了半天 </p><p><img src="/2021/03/09/sele/1617945126154.png" alt="1617945126154"></p><p>2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url</p><p>解决方案  自己的浏览器和下载版本对应</p><p><img src="/2021/03/09/sele/1617945212686.png" alt="1617945212686"></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="一-初始化"><a href="#一-初始化" class="headerlink" title="一.初始化"></a>一.初始化</h4><p>初始化一个浏览器并打开一个网页，如下：</p><pre><code>var webdriver = require(&#39;selenium-webdriver&#39;);var driver = new webdriver.Builder()    .forBrowser(&#39;ie&#39;)    .build();driver.get(&#39;http://www.baidu.com&#39;);</code></pre><h4 id="二-常用方法"><a href="#二-常用方法" class="headerlink" title="二.常用方法"></a>二.常用方法</h4><h5 id="1-元素定位"><a href="#1-元素定位" class="headerlink" title="1.元素定位"></a>1.元素定位</h5><ul><li><p>根据id定位</p><pre><code>driver.findElement(By.id(&#39;ID&#39;))；//类似于jquery的$(&quot;#id&quot;)</code></pre></li><li><p>根据className定位</p><pre><code>driver.findElement(By.className(&#39;Class&#39;))；//类似于jquery的$(&quot;.class&quot;)</code></pre></li><li><p>更多定位方式可参考：<a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html">http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html</a></p></li></ul><h5 id="2-设置元素的值"><a href="#2-设置元素的值" class="headerlink" title="2.设置元素的值"></a>2.设置元素的值</h5><pre><code>driver.findElement(By.id(&#39;ID&#39;)).sendKeys(&#39;value&#39;);//类似于jquery的$(&quot;.id&quot;).val(&quot;value&quot;);</code></pre><h5 id="3-清空元素的值"><a href="#3-清空元素的值" class="headerlink" title="3.清空元素的值"></a>3.清空元素的值</h5><pre><code>driver.findElement(By.id(&#39;id&#39;)).clear();</code></pre><h5 id="4-单击按钮"><a href="#4-单击按钮" class="headerlink" title="4.单击按钮"></a>4.单击按钮</h5><pre><code>driver.findElement(By.id(&#39;id&#39;)).click();</code></pre><h5 id="5-元素等待"><a href="#5-元素等待" class="headerlink" title="5.元素等待"></a>5.元素等待</h5><p>有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作：</p><pre><code>var until = webdriver.until;driver.wait(until.elementLocated(By.id(&#39;id&#39;), 10000));...</code></pre><h5 id="6-程序睡眠"><a href="#6-程序睡眠" class="headerlink" title="6.程序睡眠"></a>6.程序睡眠</h5><p>睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。</p><pre><code>driver.sleep(500);//毫秒</code></pre><h5 id="7-执行JavaScript"><a href="#7-执行JavaScript" class="headerlink" title="7.执行JavaScript"></a>7.执行JavaScript</h5><p>在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转：</p><pre><code>driver.executeScript(&#39;location.href=&quot;/xx.html&quot; &#39;);</code></pre><p>或者需要给元素设置值时可以使用：</p><pre><code>driver.executeScript(&#39;document.getElementById(&quot;id&quot;).value=&quot;value&quot;&#39;);//$(&quot;#id&quot;).val(&quot;value&quot;);</code></pre><h5 id="8-执行JavaScript并获取返回值"><a href="#8-执行JavaScript并获取返回值" class="headerlink" title="8.执行JavaScript并获取返回值"></a>8.执行JavaScript并获取返回值</h5><p>在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。</p><pre><code>driver.executeScript(&#39;return $(&quot;#id&quot;).val()&#39;).then(function(obj)&#123;    //obj即为返回值    if(obj&gt;100)&#123;        //操作    &#125;else&#123;       //其他操作    &#125;&#125;)</code></pre><h5 id="9-切换作用域（switchTo）"><a href="#9-切换作用域（switchTo）" class="headerlink" title="9.切换作用域（switchTo）"></a>9.切换作用域（switchTo）</h5><ul><li><p>切换到iframe<br>网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。</p><pre><code>driver.switchTo().frame(driver.findElement(By.id(&quot;iframe-id&quot;)));  //iframe-id为iframe元素的id</code></pre></li><li><p>切换到弹出框<br>有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。</p><pre><code>driver.switchTo().alert().then(function(alert) &#123;     //检测到弹出框时执行     //关闭alert     return alert.dismiss();&#125;,function()&#123;    //没有检测到弹出框时执行&#125;);</code></pre></li><li><p>切换回主页面</p><pre><code>driver.switchTo().defaultContent();</code></pre></li></ul><h5 id="10-网页最大化（全屏）"><a href="#10-网页最大化（全屏）" class="headerlink" title="10.网页最大化（全屏）"></a>10.网页最大化（全屏）</h5><pre><code>driver.manage().window().maximize();</code></pre><h5 id="11-网页截图-定位"><a href="#11-网页截图-定位" class="headerlink" title="11.网页截图(定位)"></a>11.网页截图(定位)</h5><p>网页截图看上去很简单，就一行代码如下：</p><pre><code>driver.takeScreenshot()；</code></pre><p>截图后的结果为base64格式，可自行处理。类似这样：</p><pre><code>driver.takeScreenshot().then(function(d)&#123;    //此处d即为截图结果base64字符串，可在此自行处理&#125;);</code></pre><p>但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。<br>在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下：</p><pre><code>driver.findElement(By.className(&#39;yanzheng&#39;)).then(function(obj)&#123;        obj.getSize().then(function(size)&#123;                      obj.getLocation().then(function(loc)&#123;                driver.takeScreenshot().then(function(d)&#123;                      var data=&#123;                            d:d,                            width:size.width,                            height:size.height,                            x:loc.x,                            y:loc.y                      &#125;;                    //此处省略以下两步                    //1.提交data信息到服务器处理图片                    //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置x,y以及长宽width,height截取相应的图片                &#125;)           &#125;        &#125;&#125;)</code></pre><h5 id="12-退出程序（关闭网页）"><a href="#12-退出程序（关闭网页）" class="headerlink" title="12.退出程序（关闭网页）"></a>12.退出程序（关闭网页）</h5><pre><code>driver.quit();</code></pre><p>更多详细文档可参考官方文档：<a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/">http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/</a></p><h4 id="下面是不错的资源"><a href="#下面是不错的资源" class="headerlink" title="下面是不错的资源"></a>下面是不错的资源</h4><p><a href="https://www.selenium.dev/documentation/zh-cn/webdriver/locating_elements/">中文文档</a></p><p><a href="https://www.yiibai.com/selenium/selenium-webdriver-first-test-case.html">易百教程</a> </p>]]></content>
    
    
    <categories>
      
      <category>Selenium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nodejs Selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vacode让表单更简单</title>
    <link href="/2021/03/01/form/"/>
    <url>/2021/03/01/form/</url>
    
    <content type="html"><![CDATA[<p>大多数开发无非就是表格 表单怎删改 </p><p>很多时候就是去element  官方文档 挨个加属性  搬砖</p><p><img src="/2021/03/01/form/1635906947657.png" alt="1635906947657"></p><p>如何降本增效 方法论流程化工具化</p><p> Element UI表单设计及代码生成器，可将生成的代码直接运行在基于Element的vue项目中；也可导出JSON表单，使用配套的解析器将JSON解析成真实的表单。 </p><p>网页地址</p><p><a href="https://mrhj.gitee.io/form-generator/#/">https://mrhj.gitee.io/form-generator/#/</a></p><p><img src="/2021/03/01/form/1635907010952.png" alt="1635907010952"></p><p>但是每次开网页也很烦</p><p>可以更简单</p><p>能在vscode 中坚决不出去</p><p>用插件</p><p>地址<a href="https://marketplace.visualstudio.com/items?itemName=jakHuang.form-generator-plugin!%5B1635907058620%5D(1635907058620.png)">https://marketplace.visualstudio.com/items?itemName=jakHuang.form-generator-plugin![1635907058620](1635907058620.png)</a></p><p>效果</p><p><img src="/2021/03/01/form/1635907094438.png" alt="1635907094438"></p><p>等下班</p><p><img src="/2021/03/01/form/1635907131273.png" alt="1635907131273"></p>]]></content>
    
    
    <categories>
      
      <category>form   vacode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>form  vacode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档中代码编辑加预览</title>
    <link href="/2020/10/13/code/"/>
    <url>/2020/10/13/code/</url>
    
    <content type="html"><![CDATA[<h2 id="好文档是什么呢？（其实有人已经回答）"><a href="#好文档是什么呢？（其实有人已经回答）" class="headerlink" title="好文档是什么呢？（其实有人已经回答）"></a>好文档是什么呢？（其实有人已经回答）</h2><p>我一直在思考 🤔 怎么的 Vue 文档交互才是好的 👍, 后来得出的结论是:</p><ul><li>能看代码</li><li>能看效果</li><li>能在线编辑代码, 并实时预览结果</li></ul><p>能做到前 2 点的 Vue 组件不少, 但能做到第 3 点, 并对文档的 DEMO 编写做优化处理的并不多</p><p>找了好久功夫不负有心人  还是有大神造就出了轮子   轮子总是能效率提升百倍</p><p>以 docsify 为例子     （v-charts  展示源码同时 可预览 编辑  就是用的这个做的文档 虽然线上目前出故障了到是 ）  <a href="https://v-charts.js.org/#/line">地址</a></p><p>原理使用vuep  这是个好东西</p><p><img src="/2020/10/13/code/1618296154343.png" alt="1618296154343"></p><p>随后又找到另一个类似网站  <a href="https://vueblocks.github.io/ve-charts/#/chart-pie">ve-charts</a></p><ol><li>有源码  </li><li>有demo</li><li>源码编辑 demo 联动  </li></ol><p><img src="/2020/10/13/code/1618296377359.png" alt="1618296377359"></p><p>以上都是vuep 技术实现</p><h3 id="还没有没别的方式呢"><a href="#还没有没别的方式呢" class="headerlink" title="还没有没别的方式呢"></a>还没有没别的方式呢</h3><h4 id="vue-run-sfc-你值得拥有"><a href="#vue-run-sfc-你值得拥有" class="headerlink" title="vue-run-sfc  你值得拥有"></a><strong>vue-run-sfc</strong>  你值得拥有</h4><h2 id="🍎-使用"><a href="#🍎-使用" class="headerlink" title="🍎 使用"></a>🍎 使用</h2><pre><code>&lt;script&gt;  window.$docsify = &#123;    // 配置, 更多属性解释请往下面翻 ↓    run: &#123;      themeColor: &#39;green&#39;,      themeBorderColor: &#39;#eee&#39;,      reverse: true,      // ...    &#125;  &#125;&lt;/script&gt;&lt;!-- 引入Vue --&gt;&lt;script src=&quot;//unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入 vue-run-sfc --&gt;&lt;script src=&quot;//unpkg.com/vue-run-sfc&quot;&gt;&lt;/script&gt;&lt;!-- 引入 docsify-plugin-run --&gt;&lt;script src=&quot;https://unpkg.com/docsify-plugin-run/src/index.js&quot;&gt;&lt;/script&gt;&lt;!-- 指定版本 --&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/docsify-plugin-run@xx.xx.xx/src/index.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- docsify --&gt;&lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="🍊示例"><a href="#🍊示例" class="headerlink" title="🍊示例"></a>🍊示例</h2><h3 id="全局配置-运行-element-ui"><a href="#全局配置-运行-element-ui" class="headerlink" title="全局配置: 运行 element-ui"></a>全局配置: 运行 element-ui</h3><pre><code>&lt;script&gt;  window.$docsify = &#123;    run: &#123;      jsLabs: [&#39;https://unpkg.com/element-ui/lib/index.js&#39;],      cssLabs: [&#39;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#39;],    &#125;  &#125;&lt;/script&gt;``html run&lt;template&gt;  &lt;el-tabs type=&quot;border-card&quot;&gt;    &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;``  &lt;== 这里和上面的 ` 有 3 个</code></pre><h3 id="最终效果我放在了码云地址"><a href="#最终效果我放在了码云地址" class="headerlink" title="最终效果我放在了码云地址"></a>最终效果我放在了<a href="http://gujinlong_705.gitee.io/docsifytest/#/test">码云地址</a></h3><p>简单测试效果如图 </p><p><img src="/2020/10/13/code/1618296592012.png" alt="1618296592012"></p>]]></content>
    
    
    <categories>
      
      <category>docsify vuepres code run</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docsify vuepres code run</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小试尤大大vuepress vue 文档神器</title>
    <link href="/2020/08/01/vuepress/"/>
    <url>/2020/08/01/vuepress/</url>
    
    <content type="html"><![CDATA[<h1 id="没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。"><a href="#没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。" class="headerlink" title="没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。"></a>没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。</h1><h2 id="个人觉得如果是vue-组件文档应该是最优选择-毕竟是vue文档工具-深度定制"><a href="#个人觉得如果是vue-组件文档应该是最优选择-毕竟是vue文档工具-深度定制" class="headerlink" title="个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)"></a>个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)</h2><h2 id="简洁至上"><a href="#简洁至上" class="headerlink" title="简洁至上"></a>简洁至上</h2><p>以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。</p><h2 id="Vue-驱动"><a href="#Vue-驱动" class="headerlink" title="Vue 驱动"></a>Vue 驱动</h2><p>享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。</p><h2 id="为什么不是…"><a href="#为什么不是…" class="headerlink" title="#为什么不是…?"></a><a href="https://vuepress.vuejs.org/zh/guide/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF">#</a>为什么不是…?</h2><h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="#Nuxt"></a><a href="https://vuepress.vuejs.org/zh/guide/#nuxt">#</a>Nuxt</h3><p>VuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。</p><h3 id="Docsify-Docute"><a href="#Docsify-Docute" class="headerlink" title="#Docsify / Docute"></a><a href="https://vuepress.vuejs.org/zh/guide/#docsify-docute">#</a>Docsify / Docute</h3><p>这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="#Hexo"></a><a href="https://vuepress.vuejs.org/zh/guide/#hexo">#</a>Hexo</h3><p>Hexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。</p><h3 id="GitBook"><a href="#GitBook" class="headerlink" title="#GitBook"></a><a href="https://vuepress.vuejs.org/zh/guide/#gitbook">#</a>GitBook</h3><p>我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。</p><p>个人小试如下</p><h1 id="很快就搭建了架子-部署在了gitee-上-配置如下"><a href="#很快就搭建了架子-部署在了gitee-上-配置如下" class="headerlink" title="很快就搭建了架子 部署在了gitee 上  配置如下"></a>很快就搭建了架子 部署在了gitee 上  <strong>配置如下</strong></h1><p><img src="/2020/08/01/vuepress/1618111576451.png" alt="1618111576451"></p><p>注意配置这才会展示 官方文档有介绍  和部署域名后缀一样就ok了</p><p><img src="/2020/08/01/vuepress/1618111629200.png" alt="1618111629200"></p><p>测试效果如下</p><p><img src="/2020/08/01/vuepress/1618111726401.png" alt="1618111726401"></p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>codepen 如何引入到文档显得高大上？？？<br>如下</p><iframe height="265" style="width: 100%;" scrolling="no" title="QWdaRMR" src="https://codepen.io/gujinlonghaha/embed/preview/QWdaRMR?height=265&theme-id=dark&default-tab=js,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">  See the Pen <a href='https://codepen.io/gujinlonghaha/pen/QWdaRMR'>QWdaRMR</a> by gujinlong  (<a href='https://codepen.io/gujinlonghaha'>@gujinlonghaha</a>) on <a href='https://codepen.io'>CodePen</a>.</iframe><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>先保存</p><p><img src="/2020/08/01/vuepress/1618111961002.png" alt="1618111961002"></p><p>然后获取iframe</p><p><img src="/2020/08/01/vuepress/1618111992615.png" alt="1618111992615"></p><p>最后直接放在md 源文件</p><p><img src="/2020/08/01/vuepress/1618112040814.png" alt="1618112040814"></p>]]></content>
    
    
    <categories>
      
      <category>vuepress</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vuepress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速删除nodemoudles</title>
    <link href="/2020/06/01/delte/"/>
    <url>/2020/06/01/delte/</url>
    
    <content type="html"><![CDATA[<p>删除nodemoudles 文件又大又碎 怎么办呢  ？</p><p>不要用delete 删除了 太慢了</p><p><img src="/2020/06/01/delte/1635839100525.png" alt="1635839100525"></p><pre><code>  cnpm install rimraf -g   rimraf node_modules</code></pre><p><img src="/2020/06/01/delte/1635839243450.png" alt="1635839243450"></p><p>如果是固态 你的删除速度超快的</p>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单屏变双屏 vscode 内置浏览器可更换网页地址</title>
    <link href="/2020/05/01/preview/"/>
    <url>/2020/05/01/preview/</url>
    
    <content type="html"><![CDATA[<p>大部分都知道用liveserve 实时保存页面就会更新（不允许随便修改地址）</p><p>如果双屏电脑还好 但是单屏电脑想要写代码 或者看别的网页怎么办</p><p><img src="/2020/05/01/preview/1635838128970.png" alt="1635838128970"></p><p>hbuliter 就有此功能</p><p><img src="/2020/05/01/preview/1635838171770.png" alt="1635838171770"></p><p>强大的vscode 就没有办法了吗 我找了一下还真有 特此记录</p><p>地址 <a href="https://marketplace.visualstudio.com/items?itemName=auchenberg.vscode-browser-preview">https://marketplace.visualstudio.com/items?itemName=auchenberg.vscode-browser-preview</a></p><p><img src="/2020/05/01/preview/1635838351517.png" alt="1635838351517"></p><p>配置项 地址可以更改 也可以有默认地址    也可以执行对应脚本</p><p>这样就省去了买双屏幕得钱了</p><p><img src="/2020/05/01/preview/1635838412327.png" alt="1635838412327"></p>]]></content>
    
    
    <categories>
      
      <category>vscode vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>json在线编辑器在字典很适合</title>
    <link href="/2020/04/23/json/"/>
    <url>/2020/04/23/json/</url>
    
    <content type="html"><![CDATA[<h3 id="有时候字典的业务场景手动录入很麻烦-我们直接当做JSON-字符串来处理好处"><a href="#有时候字典的业务场景手动录入很麻烦-我们直接当做JSON-字符串来处理好处" class="headerlink" title="有时候字典的业务场景手动录入很麻烦  我们直接当做JSON 字符串来处理好处"></a>有时候字典的业务场景手动录入很麻烦  我们直接当做JSON 字符串来处理好处</h3><p><strong>很快录入 不需要1个1个点击页面添加</strong></p><p><strong>坏处 之前有人录入搞进去了/r /n  换车 换行导致 解析错误 json.parse()</strong></p><p><img src="/2020/04/23/json/1635302321909.png" alt="1635302321909"></p><p>原来是这样的   很粗暴</p><p><img src="/2020/04/23/json/1635302347871.png" alt="1635302347871"></p><p>现在增加了 json 编辑器 就可以校验json 了</p><p><img src="/2020/04/23/json/1635302734394.png" alt="1635302734394"></p><p>用法</p><pre><code>npm install vue-json-editor --save</code></pre><p>官方文档不全</p><p><img src="/2020/04/23/json/1635302806720.png" alt="1635302806720"></p><p>真正的配置大全</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;p&gt;vue-json-editor&lt;/p&gt;    &lt;vue-json-editor    v-model=&quot;json&quot;     :show-btns=&quot;true&quot;  // 是否显示保存按钮    :mode=&quot;&#39;code&#39;&quot; // 默认编辑模式    lang=&quot;zh&quot;  // 显示中文，默认英文    @json-change=&quot;onJsonChange&quot;  // 数据改变事件    @json-save=&quot;onJsonSave&quot;     @has-error=&quot;onError&quot;&gt;&lt;/vue-json-editor&gt;  &lt;/div&gt;&lt;/template&gt; &lt;script&gt;  import vueJsonEditor from &#39;vue-json-editor&#39;   export default &#123;    data () &#123;      return &#123;        json: &#123;          msg: &#39;demo of jsoneditor&#39;        &#125;      &#125;    &#125;,     components: &#123;      vueJsonEditor    &#125;,     methods: &#123;      onJsonChange (value) &#123;        // 异常时不会打印            console.log(&#39;value:&#39;, value);        &#125;,      onJsonSave (value) &#123;            console.log(&#39;value:&#39;, value);        &#125;,       onError (value) &#123;                       console.log(&#39;value:&#39;, value);        &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><pre><code>model：bind the [json object] :show-btns: boolean, show the save button, default: true :expandedOnStart: boolean, expand the JSON editor on start for the modes &#39;tree&#39;, &#39;view&#39;, and &#39;form&#39;, default: false :mode: string, default: tree :lang: string, default:en @json-change: on json changed@json-save: on json save@has-error: on error</code></pre>]]></content>
    
    
    <categories>
      
      <category>js vue json</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js vue json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pupeteer自动化加版本测试</title>
    <link href="/2020/04/08/pup/"/>
    <url>/2020/04/08/pup/</url>
    
    <content type="html"><![CDATA[<h1 id="多版本谷歌测试如何进行"><a href="#多版本谷歌测试如何进行" class="headerlink" title="多版本谷歌测试如何进行"></a>多版本谷歌测试如何进行</h1><p>没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决</p><h2 id="puppeteerjs"><a href="#puppeteerjs" class="headerlink" title="puppeteerjs"></a>puppeteerjs</h2><p>你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例：</p><ul><li>生成页面 PDF。</li><li>抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。</li><li>自动提交表单，进行 UI 测试，键盘输入等。</li><li>创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。</li><li>捕获网站的 <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference">timeline trace</a>，用来帮助分析性能问题。</li><li>测试浏览器扩展。</li></ul><h3 id="他其中有个模块"><a href="#他其中有个模块" class="headerlink" title="他其中有个模块"></a>他其中有个模块</h3><p><img src="/2020/04/08/pup/1617851125113.png" alt="1617851125113"></p><p>那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的   <a href="https://omahaproxy.appspot.com/">地址</a>   需要fq</p><p><img src="/2020/04/08/pup/1617851262264.png" alt="1617851262264"></p><p>是第二个箭头也就是分支切换出来的版本号码</p><p>那他支持哪些版本呢  <a href="https://npm.taobao.org/mirrors/chromium-browser-snapshots/Win_x64/">地址</a>   淘宝给出了镜像地址   下面号码拿来直接用</p><p><img src="/2020/04/08/pup/1617851479500.png" alt="1617851479500"></p><p>现在谷歌浏览器都是下载安装器然后在线安装有没离线包 </p><p><a href="https://www.chromedownloads.net/chrome64win-stable/">福利</a></p><p><img src="/2020/04/08/pup/1617851464105.png" alt="1617851464105"></p><p>自己写的部分常用脚本 以防忘记</p><pre><code>const puppeteer = require(&#39;puppeteer&#39;);let operte=async(t) =&gt; &#123;    // 开启 browser   const browserFetcher = puppeteer.createBrowserFetcher();   const revisionInfo = await browserFetcher.download(&#39;533271&#39;);  //指定版本    const vesion= await browserFetcher.localRevisions()    console.log(vesion)    let browser = await puppeteer.launch(&#123;        executablePath: revisionInfo.executablePath,        headless: false,        defaultViewport: &#123;            height: 1080,            width: 1920        &#125;    &#125;);    // 新增分页    console.log(browser)    let page = await browser.newPage();    // 到自己的网站    await page.goto(`$&#123;t&#125;`);     // 等待订阅按钮出现    //  await page.waitForSelector(&quot;button[class=&#39;subscribe-button pill-button&#39;]&quot;);    //  page.type(&#39;#mytextarea&#39;, &#39;Hello&#39;, &#123; delay: 100 &#125;); // 立即输入    //  page.type(&#39;#mytextarea&#39;, &#39;World&#39;, &#123; delay: 100 &#125;); // 输入变慢，像一个用户    //  // 点击订阅按钮    //  await page.click(&quot;button[class=&#39;subscribe-button pill-button&#39;]&quot;);    //   关闭标签页    // page.close()    // 关闭浏览器    // await browser.close();&#125;let arr=[    &#39;https://www.baidu.com/&#39;,    // &#39;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#39;,]arr.forEach(t =&gt; &#123;    operte(t)&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>pupeteer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pupeteer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx 带/ 的那点事(总是会忘)</title>
    <link href="/2020/04/01/xiegang/"/>
    <url>/2020/04/01/xiegang/</url>
    
    <content type="html"><![CDATA[<p>注意：当location为正则表达式匹配模式时，proxy_pass中的url末尾是不允许有”/“的，因此正则表达式匹配模式不在讨论范围内。</p><p>proxy_pass配置中url末尾带/时，nginx转发时，会将原uri去除location匹配表达式后的内容拼接在proxy_pass中url之后。</p><p>测试地址：<a href="http://192.168.171.129/test/tes.jsp">http://192.168.171.129/test/tes.jsp</a></p><p>场景一：</p><pre><code>location ^~ /test/ &#123;proxy_pass http://192.168.171.129:8080/server/;&#125;</code></pre><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/server/tes.jsp">http://192.168.171.129:8080/server/tes.jsp</a></p><p>场景二：</p><pre><code>location ^~ /test &#123;proxy_pass http://192.168.171.129:8080/server/;&#125;</code></pre><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/server//tes.jsp">http://192.168.171.129:8080/server//tes.jsp</a></p><p>场景三：</p><pre><code>location ^~ /test/ &#123;proxy_pass http://192.168.171.129:8080/;&#125;</code></pre><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/tes.jsp">http://192.168.171.129:8080/tes.jsp</a></p><p>场景四：</p><pre><code>location ^~ /test &#123;proxy_pass http://192.168.171.129:8080/;&#125;</code></pre><p>代理后实际访问地址：<a href="http://192.168.171.129:8080//tes.jsp">http://192.168.171.129:8080//tes.jsp</a></p><p>proxy_pass配置中url末尾不带/时，如url中不包含path，则直接将原uri拼接在proxy_pass中url之后；如url中包含path，则将原uri去除location匹配表达式后的内容拼接在proxy_pass中的url之后。</p><p>测试地址：<a href="http://192.168.171.129/test/tes.jsp">http://192.168.171.129/test/tes.jsp</a></p><p>场景一：</p><pre><code>location ^~ /test/&#123;proxy_pass http://192.168.171.129:8080/server;&#125;</code></pre><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/servertes.jsp">http://192.168.171.129:8080/servertes.jsp</a></p><p>场景二：</p><p>location ^~ /test {<br>proxy_pass <a href="http://192.168.171.129:8080/server">http://192.168.171.129:8080/server</a>;</p><p>}</p><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/server/tes.jsp">http://192.168.171.129:8080/server/tes.jsp</a></p><p>场景三：</p><p>location ^~ /test/ {<br>proxy_pass <a href="http://192.168.171.129:8080/">http://192.168.171.129:8080</a>;</p><p>}</p><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/test/tes.jsp">http://192.168.171.129:8080/test/tes.jsp</a></p><p>场景四：</p><p>location ^~ /test {<br>proxy_pass <a href="http://192.168.171.129:8080/">http://192.168.171.129:8080</a>;</p><p>}</p><p>代理后实际访问地址：<a href="http://192.168.171.129:8080/test/tes.jsp">http://192.168.171.129:8080/test/tes.jsp</a></p><p>总结：</p><p>如果proxy_pass中配置的地址中带/，不论/在不在末尾(即：不论/是不是最后一个字符)，都会把访问链接uri中匹配到location表达式的部分去掉，然后在拼接到proxy_pass的url之后</p>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产环境启用devtool调方法论试</title>
    <link href="/2020/03/13/devtool/"/>
    <url>/2020/03/13/devtool/</url>
    
    <content type="html"><![CDATA[<p>大家开发都适用vue devtool  但是线上临时调试怎办呢</p><p><img src="/2020/03/13/devtool/1635826701342.png" alt="1635826701342"></p><p>自己的代码可以启用后重新打包 记得在new 之前赋值</p><p><img src="/2020/03/13/devtool/1635826816232.png" alt="1635826816232"></p><p>如果是别人的代码如何热操作呢？</p><p><img src="/2020/03/13/devtool/1635826893932.png" alt="1635826893932"></p><p>1 先打开网站 </p><p>f12 打开来源</p><p>ctrl+p 搜索app.js </p><p>然后格式化</p><p><img src="/2020/03/13/devtool/1635826993030.png" alt="1635826993030"></p><p>2 搜索 el: “#app”</p><p>在new 处打断点（i[“default”].config.devtools=flase 默认）</p><p><img src="/2020/03/13/devtool/1635827098751.png" alt="1635827098751"></p><p>3刷新页面 进入断点后 控制台输入 i[“default”].config.devtools=true 回车 </p><p>跳过断点</p><p><img src="/2020/03/13/devtool/1635827241539.png" alt="1635827241539"></p><p>4 f12 关掉控制台   f12  再次打开控制台 就有了vue devtool </p><p><img src="/2020/03/13/devtool/1635827325490.png" alt="1635827325490"></p>]]></content>
    
    
    <categories>
      
      <category>vue js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plop 你值得拥有</title>
    <link href="/2019/11/20/plop/"/>
    <url>/2019/11/20/plop/</url>
    
    <content type="html"><![CDATA[<p>这时代连ctrl+c  ctrl+v 都已经是工作量了<br>能不能简单点<br>再简单点</p><p><img src="/2019/11/20/plop/1635239022410.png" alt="1635239022410"></p><p>基于 Vscode 的 Snippets 自定义代码块<br>通过 Vscode 的 Snippets 我们可以自定义 Snippets，从而实现快捷生成代码片段。</p><p>打开 Vscode，依次点击文件——首选项——用户代码片段</p><pre><code>prefix: 代码片段名字，即输入此名字就可以调用代码片段body: 这个是代码段的主体.需要编写的代码放在这里    $1: 生成代码后光标的初始位置$2: 生成代码后光标的第二个位置,按 tab 键可进行快速切换,还可以有 $3,$4,$5.....$&#123;1,字符&#125;: 生成代码后光标的初始位置（其中 1 表示光标开始的序号，字符表示生成代码后光标会直接选中字符）description: 代码段描述,输入名字后编辑器显示的提示信息tab键制表符:\t换行: \r 或者\n</code></pre><p>plop 解决了静态和动态模板的问题<br>（常见解决方案 1代码段 比较小   2 node fs 模块写文件  3 vscode 插件 4 历史粘贴板 ）<br>plop 更高级</p><p>在日常开发中，我们需要不停的新建页面和组件。以 Vue 项目为例，我们在新建一个页面的时候，需要经历一遍又一遍重复的过程：</p><p>1、先新建一个文件夹</p><p>2、然后新建一个 .vue 文件，写上 </p><pre><code>&lt;template&gt;、&lt;script&gt;、&lt;style&gt;</code></pre><p>3、如果页面涉及多个组件，还要新建 component 文件夹，并重复以上两个步骤</p><p>4、最后才是我们的业务代码</p><p>开始搞</p><pre><code>npm install --save-dev plop</code></pre><ul><li>项目根目录下新建 <code>plopfile.js</code></li></ul><pre><code>const viewGenerator = require(&#39;./plop-templates/view/prompt&#39;)const componentGenerator = require(&#39;./plop-templates/component/prompt&#39;)const storeGenerator = require(&#39;./plop-templates/store/prompt.js&#39;)module.exports = function(plop) &#123;  plop.setGenerator(&#39;view&#39;, viewGenerator)  plop.setGenerator(&#39;component&#39;, componentGenerator)  plop.setGenerator(&#39;store&#39;, storeGenerator)&#125;</code></pre><p>index.hbs</p><pre><code>&#123;&#123;#if template&#125;&#125;&lt;template&gt;  &lt;div /&gt;&lt;/template&gt;&#123;&#123;/if&#125;&#125;&#123;&#123;#if script&#125;&#125;&lt;script&gt;export default &#123;  name: &#39;&#123;&#123; properCase name &#125;&#125;&#39;,  props: &#123;&#125;,  data() &#123;    return &#123;&#125;  &#125;,  created() &#123;&#125;,  mounted() &#123;&#125;,  methods: &#123;&#125;&#125;&lt;/script&gt;&#123;&#123;/if&#125;&#125;&#123;&#123;#if style&#125;&#125;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;&#123;&#123;/if&#125;&#125;</code></pre><p>prompt.js</p><pre><code>const &#123; notEmpty &#125; = require(&#39;../utils.js&#39;)module.exports = &#123;  description: &#39;generate a view&#39;,  prompts: [&#123;    type: &#39;input&#39;,    name: &#39;name&#39;,    message: &#39;view name please&#39;,    validate: notEmpty(&#39;name&#39;)  &#125;,  &#123;    type: &#39;checkbox&#39;,    name: &#39;blocks&#39;,    message: &#39;Blocks:&#39;,    choices: [&#123;      name: &#39;&lt;template&gt;&#39;,      value: &#39;template&#39;,      checked: true    &#125;,    &#123;      name: &#39;&lt;script&gt;&#39;,      value: &#39;script&#39;,      checked: true    &#125;,    &#123;      name: &#39;style&#39;,      value: &#39;style&#39;,      checked: true    &#125;    ],    validate(value) &#123;      if (value.indexOf(&#39;script&#39;) === -1 &amp;&amp; value.indexOf(&#39;template&#39;) === -1) &#123;        return &#39;View require at least a &lt;script&gt; or &lt;template&gt; tag.&#39;      &#125;      return true    &#125;  &#125;  ],  actions: data =&gt; &#123;    const name = &#39;&#123;&#123;name&#125;&#125;&#39;    const actions = [&#123;      type: &#39;add&#39;,      path: `src/views/$&#123;name&#125;/index.vue`,      templateFile: &#39;plop-templates/view/index.hbs&#39;,      data: &#123;        name: name,        template: data.blocks.includes(&#39;template&#39;),        script: data.blocks.includes(&#39;script&#39;),        style: data.blocks.includes(&#39;style&#39;)      &#125;    &#125;]    return actions  &#125;&#125;</code></pre><p><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1635238049&ver=3397&signature=XhxckxmQJbOV8XfbzjKEKwAUVdLu*q0A0CLP2*Hfez12F27UbOx1JtORtmjkHvZvOzswQSicEne7ipw3XXFZy11KQFltNdsHpVLfNXVgOQQwuzAy6fG5uOLpkE*Gxgdr&new=1">政采云这个写的更不错</a></p><p><img src="/2019/11/20/plop/1635239420430.png" alt="1635239420430"></p>]]></content>
    
    
    <categories>
      
      <category>vue  plop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue  plop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 批量自动化</title>
    <link href="/2019/10/10/vue/"/>
    <url>/2019/10/10/vue/</url>
    
    <content type="html"><![CDATA[<p>vue 批量注册全局组件 自动全局注册免去手动操作 早点下班</p><p><img src="/2019/10/10/vue/1634618126400.png" alt="1634618126400"></p><p>代码</p><pre><code>// 引入vueimport Vue from &#39;vue&#39;// 引入同目录下的全部组件const requireCom = require.context(&#39;.&#39;, false, /\.vue$/)// 依次进行注册requireCom.keys().forEach(key =&gt; &#123;  //    字符串首字母大写处理  function strUp(str) &#123;    return str.charAt(0).toUpperCase() + str.slice(1)  &#125;  // 获取单个组件内容  const _component = requireCom(key)  // 获取组件名称  const _componentName = strUp(key.replace(/^\.\//, &#39;&#39;).replace(/\.\w+$/, &#39;&#39;))  // 注册在vue上  Vue.component(_componentName, _component.default || _component)&#125;)</code></pre><p>在一个项目中, 某些过滤器全局都有可能用的到, 统一管理并自动化全局注册是很方便的.</p><p>代码如下, 后续只需要在<strong>src/filters/index.js</strong>中添加方法就可以全局使用过滤器了.</p><pre><code>// src/filters/index.js  //  格式化方法  export function formatNull (val) &#123;    return val ? val : &#39;--&#39;  &#125;</code></pre><pre><code>// mian.js  import Vue from &#39;vue&#39;import * as filters from &#39;./filters&#39;// 全局注册过滤器Object.keys(filters).forEach(k =&gt; Vue.filter(k, filters[k]));</code></pre>]]></content>
    
    
    <categories>
      
      <category>element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>element</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盘点自己发现vscode代码生成插件</title>
    <link href="/2019/08/01/codeRun/"/>
    <url>/2019/08/01/codeRun/</url>
    
    <content type="html"><![CDATA[<p>这里我发现的是vscode插件   当然插件也可以私有化（复制下来 自定义 然后生成自己的插件包）</p><p>本质就是生成部分模板代码  话不多说上图</p><p>1  自己定义模板  <a href="https://marketplace.visualstudio.com/items?itemName=DengSir.template-generator-vscode">地址</a></p><p><img src="/2019/08/01/codeRun/1635755249606.png" alt="1635755249606"></p><p>window 路径  C:\Users\user.vscode\templates  支持部分变量</p><p><img src="/2019/08/01/codeRun/1635755313132.png" alt="1635755313132"></p><p>2 标准vue 代码  不灵活需要改源码  <a href="https://marketplace.visualstudio.com/items?itemName=polo.vue-generator">地址</a></p><p><img src="/2019/08/01/codeRun/1635755425954.png" alt="1635755425954"></p><p>3 同上 标准vue 源码 不灵活需要源码  <a href="https://marketplace.visualstudio.com/items?itemName=lanzhsh.vue-template">地址</a><img src="/2019/08/01/codeRun/1635755510029.png" alt="1635755510029"></p><p>4 代码段转换 （源生代码段转换太费经 换行和空格）这个挺香</p><p><a href="https://marketplace.visualstudio.com/items?itemName=wenfangdu.snippet-generator">地址</a></p><p><img src="/2019/08/01/codeRun/1635755851065.png" alt="1635755851065"></p><p>5 同上 代码json 生成</p><p><a href="https://marketplace.visualstudio.com/items?itemName=fiore57.snippet-generator">地址</a></p><p><img src="/2019/08/01/codeRun/1635756053916.png" alt="1635756053916"></p>]]></content>
    
    
    <categories>
      
      <category>vscode code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形数据的方法论</title>
    <link href="/2019/05/23/tree/"/>
    <url>/2019/05/23/tree/</url>
    
    <content type="html"><![CDATA[<p>数据结构</p><pre><code>var  data2= [         &#123;          id: 1,          label: &#39;一级 1&#39;,          children: [&#123;            id: 4,            label: &#39;二级 1-1&#39;,            children: [&#123;              id: 9,              label: &#39;三级 1-1-1&#39;            &#125;, &#123;              id: 10,              label: &#39;三级 1-1-2&#39;            &#125;]          &#125;]        &#125;,         &#123;          id: 2,          label: &#39;一级 2&#39;,          children: [&#123;            id: 5,            label: &#39;二级 2-1&#39;          &#125;, &#123;            id: 6,            label: &#39;二级 2-2&#39;          &#125;]        &#125;,         &#123;          id: 3,          label: &#39;一级 3&#39;,          children: [&#123;            id: 7,            label: &#39;二级 3-1&#39;          &#125;, &#123;            id: 8,            label: &#39;二级 3-2&#39;          &#125;]        &#125;];    </code></pre><h4 id="根据ID获取该节点的所有父节点的对象"><a href="#根据ID获取该节点的所有父节点的对象" class="headerlink" title="根据ID获取该节点的所有父节点的对象"></a>根据ID获取该节点的所有父节点的对象</h4><pre><code>  function getParentId(list,id) &#123;        for (let i in list) &#123;            if(list[i].id==id)&#123;            return [list[i]]          &#125;          if(list[i].children)&#123;            let node=getParentId(list[i].children,id);            if(node!==undefined)&#123;                return node.concat(list[i])               &#125;          &#125;        &#125;            &#125;           getParentId(data2,10)//打印出来就是想要的数据</code></pre><p><img src="/2019/05/23/tree/1635303387290.png" alt="1635303387290"></p><h4 id="根据ID获取该节点的对象"><a href="#根据ID获取该节点的对象" class="headerlink" title="根据ID获取该节点的对象"></a>根据ID获取该节点的对象</h4><pre><code class="js">function getId(list,id) &#123;        for (let i in list) &#123;            if(list[i].id==id)&#123;            return [list[i]]          &#125;          if(list[i].children)&#123;            let node=getParentId(list[i].children,id);            if(node!==undefined)&#123;                return node;               &#125;          &#125;        &#125;        &#125;      getId(data2,4)//打印出来就是想要的数据</code></pre><p><img src="/2019/05/23/tree/1635303459540.png" alt="1635303459540"></p><h4 id="根据ID获取所有子节点的对象，首先把该节点的对象找出来，上面getId（）这个方法"><a href="#根据ID获取所有子节点的对象，首先把该节点的对象找出来，上面getId（）这个方法" class="headerlink" title="根据ID获取所有子节点的对象，首先把该节点的对象找出来，上面getId（）这个方法"></a>根据ID获取所有子节点的对象，首先把该节点的对象找出来，上面getId（）这个方法</h4><pre><code class="js">  function getNodeId(list,newNodeId=[]) &#123;        for (let i in list) &#123;            newNodeId.push(list[i])          if(list[i].children)&#123;                  getNodeId(list[i].children,newNodeId);            &#125;        &#125;         return newNodeId;          &#125;      //查找id=4的所有子级节点    let objId=getId(data2,4);    let childId=getNodeId(objId);//打印出来就是想要的数据 </code></pre><p><img src="/2019/05/23/tree/1635303550956.png" alt="1635303550956"></p><p><strong>平行结构转树形菜单</strong></p><pre><code class="js">var data = [              &#123;&quot;id&quot;:2,&quot;name&quot;:&quot;第一级1&quot;,&quot;pid&quot;:0&#125;,              &#123;&quot;id&quot;:3,&quot;name&quot;:&quot;第二级1&quot;,&quot;pid&quot;:2&#125;,              &#123;&quot;id&quot;:5,&quot;name&quot;:&quot;第三级1&quot;,&quot;pid&quot;:4&#125;,              &#123;&quot;id&quot;:100,&quot;name&quot;:&quot;第三级2&quot;,&quot;pid&quot;:3&#125;,              &#123;&quot;id&quot;:6,&quot;name&quot;:&quot;第三级2&quot;,&quot;pid&quot;:3&#125;,              &#123;&quot;id&quot;:601,&quot;name&quot;:&quot;第三级2&quot;,&quot;pid&quot;:6&#125;,              &#123;&quot;id&quot;:602,&quot;name&quot;:&quot;第三级2&quot;,&quot;pid&quot;:6&#125;,              &#123;&quot;id&quot;:603,&quot;name&quot;:&quot;第三级2&quot;,&quot;pid&quot;:6&#125;            ];// 数组转树形结构数据（原理即为通过设置id为key值，再通过pid去找这个key是否一样，一样则为这数据的子级数据）            function arrayToJson(treeArray)&#123;                var r = [];                var tmpMap =&#123;&#125;;                for (var i=0, l=treeArray.length; i&lt;l; i++) &#123;                 // 以每条数据的id作为obj的key值，数据作为value值存入到一个临时对象里面                  tmpMap[treeArray[i][&quot;id&quot;]]= treeArray[i];                 &#125;                 console.log(&#39;tmpMap&#39;,tmpMap)                for (i=0, l=treeArray.length; i&lt;l; i++) &#123;                  var key=tmpMap[treeArray[i][&quot;pid&quot;]];                  console.log(&#39;key&#39;,key)                  //循环每一条数据的pid，假如这个临时对象有这个key值，就代表这个key对应的数据有children，需要Push进去                  //如果这一项数据属于哪个数据的子级                  if (key) &#123;                      // 如果这个数据没有children                    if (!key[&quot;children&quot;])&#123;                        key[&quot;children&quot;] = [];                        key[&quot;children&quot;].push(treeArray[i]);                    // 如果这个数据有children                    &#125;else&#123;                      key[&quot;children&quot;].push(treeArray[i]);                    &#125;                         &#125; else &#123;                    //如果没有这个Key值，就代表找不到属于哪个数据，那就代表没有父级,直接放在最外层                    r.push(treeArray[i]);                  &#125;                &#125;                return r               &#125;</code></pre><p> 树形结构数据转单层数组形式数据： </p><pre><code class="js">var jsonarr = [&#123;                id: 1,                name: &#39;北京市&#39;,                ProSort: 1,                remark: &#39;直辖市&#39;,                pid: &#39;&#39;,                isEdit: false,                children: [&#123;                  id: 35,                  name: &#39;朝阳区&#39;,                  pid: 1,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;, &#123;                  id: 36,                  name: &#39;海淀区&#39;,                  pid: 1,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;, &#123;                  id: 37,                  name: &#39;房山区&#39;,                  pid: 1,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;, &#123;                  id: 38,                  name: &#39;丰台区&#39;,                  pid: 1,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;]              &#125;, &#123;                id: 2,                name: &#39;天津市&#39;,                ProSort: 2,                remark: &#39;直辖市&#39;,                pid: &#39;&#39;,                isEdit: false,                children: [&#123;                  id: 41,                  name: &#39;北辰区&#39;,                  pid: 2,                  remark: &#39;&#39;,                  isEdit: false,                  children: [&#123;                  id: 113,                  name: &#39;天津大道&#39;,                  ProSort: 2,                  remark: &#39;道路&#39;,                  pid: &#39;&#39;,                  isEdit: false,                  children:[]&#125;]                &#125;, &#123;                  id: 42,                  name: &#39;河北区&#39;,                  pid: 2,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;, &#123;                  id: 43,                  name: &#39;西青区&#39;,                  pid: 2,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;]              &#125;, &#123;                id: 3,                name: &#39;河北省&#39;,                ProSort: 5,                remark: &#39;省份&#39;,                pid: &#39;&#39;,                isEdit: false,                children: [&#123;                  id: 45,                  name: &#39;衡水市&#39;,                  pid: 3,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;, &#123;                  id: 46,                  name: &#39;张家口市&#39;,                  pid: 3,                  remark: &#39;&#39;,                  isEdit: false,                  children: []                &#125;]              &#125;]// 树形结构数据转单层数组形式            function jsonToArray(nodes) &#123;              var r=[];              if (Array.isArray(nodes)) &#123;                for (var i=0, l=nodes.length; i&lt;l; i++) &#123;                  r.push(nodes[i]); // 取每项数据放入一个新数组                  if (Array.isArray(nodes[i][&quot;children&quot;])&amp;&amp;nodes[i][&quot;children&quot;].length&gt;0)                   // 若存在children则递归调用，把数据拼接到新数组中，并且删除该children                    r = r.concat(jsonToArray(nodes[i][&quot;children&quot;]));                      delete nodes[i][&quot;children&quot;]                &#125;              &#125;               return r;            &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>js vue json</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js vue json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue支持可选链操作符</title>
    <link href="/2019/05/11/kxl/"/>
    <url>/2019/05/11/kxl/</url>
    
    <content type="html"><![CDATA[<h3 id="在开发过程中拿到一个内嵌比较深的值需要做很多的判断，来保证没有数据而报错，比如"><a href="#在开发过程中拿到一个内嵌比较深的值需要做很多的判断，来保证没有数据而报错，比如" class="headerlink" title="在开发过程中拿到一个内嵌比较深的值需要做很多的判断，来保证没有数据而报错，比如"></a>在开发过程中拿到一个内嵌比较深的值需要做很多的判断，来保证没有数据而报错，比如</h3><pre><code> const obj = &#123;            a: &#123;                b: &#123;                    c:&quot;1&quot;                &#125;            &#125;        &#125;取c, 正确的做法是： const cValue = (obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c) || &#39;&#39;; // 需要判断4次，每一层是否有值</code></pre><p> 直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined </p><pre><code>取c const cValue = obj?.a?.b?.c  //1 </code></pre><h1 id="如何在项目中支持可选链"><a href="#如何在项目中支持可选链" class="headerlink" title="如何在项目中支持可选链"></a>如何在项目中支持可选链</h1><pre><code>npm install @babel/plugin-proposal-optional-chaining</code></pre><h4 id="添加至项目-babel-config-js文件中："><a href="#添加至项目-babel-config-js文件中：" class="headerlink" title="添加至项目.babel.config.js文件中："></a>添加至项目.babel.config.js文件中：</h4><pre><code>&#123;  &quot;plugins&quot;: [    &quot;@babel/plugin-proposal-optional-chaining&quot;, ]&#125;</code></pre><p>全局函数</p><pre><code>export default function useOptionChain(target) &#123;    return new Proxy(target, &#123;        get:  (target, propKey)=&gt; &#123;            const proKeyArr = propKey.split(&#39;?.&#39;)            return  proKeyArr.reduce((a,b)=&gt;a?.[b],target)        &#125;    &#125;)&#125;</code></pre><pre><code class="xml">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt; //保留可选链的写法，更直观的展示，想要拿数组的元素直接取下标的数字即可，不需要 []    &lt;h1 v-if=&quot;useOptionChain(arr)[&#39;0?.obj?.a?.b&#39;]&quot;&gt;数组对象&lt;/h1&gt;    &lt;h1 v-if=&quot;useOptionChain(obj)[&#39;arr?.0?.a&#39;]&quot;&gt;对象数组&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入函数import useOptionChain from &quot;@/utils&quot;;export default &#123;  name: &quot;App&quot;,  components: &#123;&#125;,  data() &#123;    return &#123;      arr: [        &#123;          obj: &#123;            a: &#123;              b: &quot;数组对象&quot;,            &#125;,          &#125;,        &#125;,      ],      obj: &#123;        arr: [          &#123;            a: &quot;对象数组&quot;,          &#125;,        ],      &#125;,    &#125;;  &#125;,  methods: &#123;    useOptionChain,  &#125;,&#125;;&lt;/script&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>vue js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npx和cli的那些事</title>
    <link href="/2019/04/20/cli/"/>
    <url>/2019/04/20/cli/</url>
    
    <content type="html"><![CDATA[<h3 id="纸上得来终觉浅-绝知此事要躬行"><a href="#纸上得来终觉浅-绝知此事要躬行" class="headerlink" title="纸上得来终觉浅 绝知此事要躬行"></a><strong>纸上得来终觉浅 绝知此事要躬行</strong></h3><p><img src="/2019/04/20/cli/1618902764339.png" alt="1618902764339"></p><p>备注：gjltestcli 是自己写的命令行工具demo</p><ol><li><strong>因为我没有全局安装gjltestcli 所以调用不了命令行</strong></li><li><strong>我使用npx gjltestcli 能成功是因为npx 临时安装gjltestcli （不会出现在当前目录nodemoudle）</strong></li><li><strong>再次使用gjltestcli 可以执行说明npx 是临时安装 没有全局安装所以不能执行</strong></li></ol><p><img src="/2019/04/20/cli/1618903114752.png" alt="1618903114752"></p><ol><li><strong>本地安装gjltestcli</strong> </li><li><strong>因为是本地安装所以调用失效 （可以使用全局安装 -g）</strong>不是环境变量 也可以加入环境变量 也可以使用npm link</li><li><strong>没有全局安装的可以通过 .\node_modules.bin\gjltestcli  执行</strong>  因为安装后在这个目录</li><li><img src="/2019/04/20/cli/1618903384161.png" alt="1618903384161"></li><li><strong>npx gjltestcli 执行成功是因为 npx 会从nodemoudle 或者本地调用 调用不到就会自己临时安装 不会在你的依赖中安装</strong></li></ol><p>上面说明了什么npx的优点：( 当被下载完，则下载的代码会被擦除。 )</p><ul><li><a href="http://nodejs.cn/learn/the-npx-nodejs-package-runner#%E8%BD%BB%E6%9D%BE%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%9C%AC%E5%9C%B0%E5%91%BD%E4%BB%A4">轻松地运行本地命令</a></li><li><a href="http://nodejs.cn/learn/the-npx-nodejs-package-runner#%E6%97%A0%E9%9C%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">无需安装的命令执行</a></li><li><a href="http://nodejs.cn/learn/the-npx-nodejs-package-runner#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-nodejs-%E7%89%88%E6%9C%AC%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81">使用不同的 Node.js 版本运行代码</a></li><li><a href="http://nodejs.cn/learn/the-npx-nodejs-package-runner#%E7%9B%B4%E6%8E%A5%E4%BB%8E-url-%E8%BF%90%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">直接从 URL 运行任意代码片段</a></li></ul><p>后面两点可以自行简单测试 最后一点代表不发包（npm publish ）也可以使用</p><h2 id="直接从-URL-运行任意代码片段"><a href="#直接从-URL-运行任意代码片段" class="headerlink" title="直接从 URL 运行任意代码片段"></a>直接从 URL 运行任意代码片段</h2><p><code>npx</code> 并不限制使用 npm 仓库上发布的软件包。</p><p>可以运行位于 GitHub gist 中的代码，例如：</p><pre><code class="bash">npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</code></pre><p>当然，当运行不受控制的代码时，需要格外小心，因为强大的功能带来了巨大的责任。</p><p><a href="https://www.ruanyifeng.com/blog/2019/02/npx.html">友情链接</a> </p><p><a href="http://nodejs.cn/learn/the-npx-nodejs-package-runner">npx</a> </p>]]></content>
    
    
    <categories>
      
      <category>npm cli npx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm cli npx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别整虚的,跨域拿来就用的全方案</title>
    <link href="/2019/04/11/cors/"/>
    <url>/2019/04/11/cors/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/11/cors/1635741923432.png" alt="1635741923432"></p><p>直接上手 拿来急用</p><p><img src="/2019/04/11/cors/1635741688753.png" alt="1635741688753"></p><p><img src="/2019/04/11/cors/1635741707584.png" alt="1635741707584"></p><p><img src="/2019/04/11/cors/1635741728340.png" alt="1635741728340"></p><p><img src="/2019/04/11/cors/1635741745712.png" alt="1635741745712"></p><p><a href="https://ask.dcloud.net.cn/article/35267">享用地址</a></p><p><a href="https://juejin.cn/post/6844904063855755271">掘金地址</a></p><p><img src="/2019/04/11/cors/1635741882881.png" alt="1635741882881"></p>]]></content>
    
    
    <categories>
      
      <category>vue  unitapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue  unitapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element form 嵌套校验</title>
    <link href="/2019/04/10/element/"/>
    <url>/2019/04/10/element/</url>
    
    <content type="html"><![CDATA[<h3 id="elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？"><a href="#elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？" class="headerlink" title="elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？"></a>elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？</h3><p><img src="/2019/04/10/element/1.png"><br><img src="/2019/04/10/element/3.png"></p><p>效果如下：</p><p><img src="/2019/04/10/element/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>element</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element树形造成的坑</title>
    <link href="/2019/04/01/treeCheck/"/>
    <url>/2019/04/01/treeCheck/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/01/treeCheck/1635495503238.png" alt="1635495503238"></p><p>element 树形在做菜单权限逻辑的时候</p><p>1选择一个节点  递归所有父级让其选择上</p><p>2取消一个节点  递归所有子集节点让其取消</p><p>这样方便用户操作</p><p>但是</p><p><img src="/2019/04/01/treeCheck/1635495713367.png" alt="1635495713367"></p><p>我之前也是 用  node-click </p><p><img src="/2019/04/01/treeCheck/1635495744301.png" alt="1635495744301"></p><p>会导致点击checkbox 不触发 node click 事件</p><p>自定义节点 加click 事件也会多次触发（无解）</p><p><img src="/2019/04/01/treeCheck/1635495799374.png" alt="1635495799374"></p><p>最终用checked 事件就好了</p><p>核心代码</p><pre><code>  enableParent(t) &#123;      // 启用所有父级      const arr = this.getParentId(this.Treedata, t.menuId)      arr.forEach(m =&gt; &#123;        if (!that.cloneArr.includes(m)) &#123;          that.cloneArr.push(m)        &#125;      &#125;)    &#125;,    disabledChildren(t) &#123;      // 取消      t.forEach(i =&gt; &#123;        if (that.cloneArr.includes(i.menuId)) &#123;          const num = that.cloneArr.indexOf(i.menuId)          that.cloneArr.splice(num, 1)        &#125;        if (i.children.length &gt; 0) &#123;          that.disabledChildren(i.children)        &#125;      &#125;)    &#125;,    customClick(data) &#123;      if (this.cloneArr.includes(data.menuId)) &#123;        // 包含就取消  所有子集取消        that.disabledChildren([data])      &#125; else &#123;        // 不包含  启用所有父级启用        that.enableParent(data)      &#125;      this.$refs.tree.setCheckedKeys(this.cloneArr)    &#125;,</code></pre><pre><code>  &lt;el-tree      ref=&quot;tree&quot;      node-key=&quot;menuId&quot;      :data=&quot;Treedata&quot;      :props=&quot;&#123;        children: &#39;children&#39;,        label: &#39;menuName&#39;,        id:&#39;menuId&#39;      &#125;&quot;      check-strictly      show-checkbox      @check=&quot;customClick&quot;    /&gt;</code></pre><p>注意父级勾选子集不勾选</p><pre><code>check-strictly</code></pre>]]></content>
    
    
    <categories>
      
      <category>vue element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue element</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodecli demo测试</title>
    <link href="/2019/03/20/nodecli/"/>
    <url>/2019/03/20/nodecli/</url>
    
    <content type="html"><![CDATA[<p>整体流程很简单 但是有几个注意事项：</p><pre><code>npm init -y</code></pre><pre><code>&#123;  &quot;name&quot;: &quot;gjltestcli&quot;,  &quot;version&quot;: &quot;1.0.2&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;bin&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: &#123;    &quot;ejs&quot;: &quot;^3.1.6&quot;,    &quot;inquirer&quot;: &quot;^8.0.0&quot;  &#125;&#125;</code></pre><ol><li><p><strong>bin 一定要写因为这里写的是命令行程序</strong></p></li><li><p><strong>dependencies 安装依赖 特别是打包后的依赖需要 npm install  包名  -S  （要不然别人安完短依赖）</strong></p></li><li><p><strong>脚本命令前加 相当于跨平台兼容 让机器识别你的代码</strong></p><pre><code class="javascript">#!/usr/bin/env node</code></pre></li><li><p><strong>当你频繁测试的时候不需要频繁发布包  先进入你的包 npm link (相当于连接到全局)  直接可以执行测试</strong></p></li><li><p><strong>发布可能重名 注意版本号每次更新 和名字不要重复 （可以搜索查询）</strong></p></li><li><p><strong>注册好后登录npm账号。</strong></p><ul><li></li></ul><pre><code>npm login</code></pre><p><strong>依次输入第二步中第一种方法注册的用户名、密码和邮箱。</strong></p><p><strong>登录成功后执行npm发布命令。</strong></p><ul><li></li></ul><pre><code>npm publish</code></pre></li></ol><p><img src="/2019/03/20/nodecli/1618905966155.png" alt="1618905966155"></p><p><strong>demo 就成功了</strong></p><p>补充：</p><p>npm link用来在本地项目和本地npm模块之间建立连接，可以在本地进行模块测试</p><p>具体用法：</p><p><strong>1. 项目和模块在同一个目录下，可以使用相对路径</strong></p><p>npm link ../module</p><p><strong>2. 项目和模块不在同一个目录下</strong></p><p>cd到模块目录，npm link，进行全局link</p><p>cd到项目目录，npm link 模块名(package.json中的name)</p><p><strong>3. 解除link</strong></p><p>解除项目和模块link，项目目录下，npm unlink 模块名</p><p>解除模块全局link，模块目录下，npm unlink 模块名</p>]]></content>
    
    
    <categories>
      
      <category>npm cli node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm cli node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向花裤衩学到的技术(element-admin)</title>
    <link href="/2019/03/20/hkc/"/>
    <url>/2019/03/20/hkc/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/20/hkc/1635234209361.png" alt="1635234209361"></p><p><strong>str  这么高值得我们很多人学习里边的思想</strong></p><p>突然发现</p><p>本地图标他是如何展示的 ？element 团标呢？</p><p><img src="/2019/03/20/hkc/1635234008077.png" alt="1635234008077"></p><p>查看源码发现</p><p><img src="/2019/03/20/hkc/1635234094248.png" alt="1635234094248"></p><p>element 写死的 也可以理解</p><p><img src="/2019/03/20/hkc/1635234123954.png" alt="1635234123954"></p><p>svg 展示就很优秀了（一般只是注册组件使用没想到还可以这么玩）</p><p><img src="/2019/03/20/hkc/1635234147308.png" alt="1635234147308"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组循环删除引发血案 递归删除</title>
    <link href="/2019/02/02/arr/"/>
    <url>/2019/02/02/arr/</url>
    
    <content type="html"><![CDATA[<p>循环中删除元素是危险的 更别说递归删除了</p><p><img src="/2019/02/02/arr/1635741289769.png" alt="1635741289769"></p><pre><code>(function () &#123; var arr = [1,2,2,3,4,5]; var len = arr.length; for(var i=0;i&lt;len;i++)&#123; //打印数组中的情况，便于跟踪数组中数据的变化 console.log(i+&quot;=&quot;+arr[i]); //删除掉所有为2的元素 if(arr[i]==2)&#123;  arr.splice(i,1); &#125; &#125; console.log(arr);&#125;)();</code></pre><p>下标会出问题</p><p>我在动态菜单递归中出现此问题  解决方案（不用foeeach   使用for 循环删除时 操作i–）</p><pre><code>&lt;!-- function removeMenu(arr = [], userMenuId = []) &#123;  arr.forEach((t, i) =&gt; &#123;    if (userMenuId.includes(t.menuId) &amp;&amp; (t.endable == 1)) &#123;      if (t.children &amp;&amp; t.children.length &gt; 0) &#123;        removeMenu(t.children, userMenuId)      &#125;    &#125; else &#123;      arr.splice(i, 1)    &#125;  &#125;)&#125; --&gt;//动态下标删除问题function removeMenu(arr = [], userMenuId = []) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    if (userMenuId.includes(arr[i].menuId) &amp;&amp; (arr[i].endable == 1)) &#123;      if (arr[i].children &amp;&amp; arr[i].children.length &gt; 0) &#123;        removeMenu(arr[i].children, userMenuId)      &#125;    &#125; else &#123;      arr.splice(i, 1)      i--    &#125;  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue 动态菜单那些事</title>
    <link href="/2019/02/01/menu/"/>
    <url>/2019/02/01/menu/</url>
    
    <content type="html"><![CDATA[<p>自己独立搭建vue 动态菜单逻辑</p><p><img src="/2019/02/01/menu/1635496770668.png" alt="1635496770668"></p><p>先在数据库字段的增删改  </p><p><img src="/2019/02/01/menu/1635496838883.png" alt="1635496838883"></p><p>为角色分配菜单</p><p><img src="/2019/02/01/menu/1635496905871.png" alt="1635496905871"></p><p>配置异步菜单本地为对象  名称唯一</p><pre><code>import &#123; asyncRoutes, constantRoutes &#125; from &#39;@/router&#39;import &#123; fetchRoleMenu &#125; from &#39;@/api/equipment/role&#39;import &#123; fetchDetail &#125; from &#39;@/api/equipment/menu&#39;function initMenufield(arr = [], userMenuId = []) &#123;  arr.forEach((t, i) =&gt; &#123;    t.hidden = !t.visible    t.name = t.menuName    t.component = asyncRoutes[t.component]    t.meta = &#123; title: t.name, icon: t.icon &#125;    if (t.children &amp;&amp; t.children.length &gt; 0) &#123;      initMenufield(t.children, userMenuId)    &#125;  &#125;)&#125;// eslint-disable-next-line no-unused-vars&lt;!-- function removeMenu(arr = [], userMenuId = []) &#123;  arr.forEach((t, i) =&gt; &#123;    if (userMenuId.includes(t.menuId) &amp;&amp; (t.endable == 1)) &#123;      if (t.children &amp;&amp; t.children.length &gt; 0) &#123;        removeMenu(t.children, userMenuId)      &#125;    &#125; else &#123;      arr.splice(i, 1)    &#125;  &#125;)&#125; --&gt;//动态下标删除问题function removeMenu(arr = [], userMenuId = []) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    if (userMenuId.includes(arr[i].menuId) &amp;&amp; (arr[i].endable == 1)) &#123;      if (arr[i].children &amp;&amp; arr[i].children.length &gt; 0) &#123;        removeMenu(arr[i].children, userMenuId)      &#125;    &#125; else &#123;      arr.splice(i, 1)      i--    &#125;  &#125;&#125;export async function filterAsyncRoutes(routes, roles, commit, resolve) &#123;  const &#123; data: allMenu &#125; = await fetchDetail(&#123;&#125;)  const &#123; objs &#125; = await fetchRoleMenu(&#123; roleId: localStorage.getItem(&#39;roleIds&#39;) &#125;)  let userMenuId = []  try &#123;    userMenuId = (JSON.parse(objs.cjson))?.menuids || []  &#125; catch (error) &#123;    console.log(error)  &#125;  removeMenu(allMenu, userMenuId)  // 移除路由 知道路径也进不去  // console.table(allMenu)  initMenufield(allMenu, userMenuId)  // console.table(allMenu)  // 生成路由  allMenu.push(    &#123; path: &#39;*&#39;, redirect: &#39;/dashboard&#39;, hidden: true &#125;  )  let res = []  res = allMenu  commit(&#39;SET_ROUTES&#39;, res)  resolve(res)&#125;const state = &#123;  routes: [],  addRoutes: []&#125;const mutations = &#123;  SET_ROUTES: (state, routes) =&gt; &#123;    state.addRoutes = routes    state.routes = constantRoutes.concat(routes)  &#125;&#125;const actions = &#123;  generateRoutes(&#123; commit &#125;, roles) &#123;    return new Promise(resolve =&gt; &#123;      filterAsyncRoutes(asyncRoutes, roles, commit, resolve)    &#125;)  &#125;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions&#125;</code></pre><p>1内部先拉取全部树形菜单   </p><p>2根据角色拉取自己菜单id</p><p>3 移除无用菜单</p><p>4 把剩余菜单对象转换</p><pre><code> t.hidden = !t.visible    t.name = t.menuName    t.component = asyncRoutes[t.component]    t.meta = &#123; title: t.name, icon: t.icon &#125;    if (t.children &amp;&amp; t.children.length &gt; 0) &#123;      initMenufield(t.children, userMenuId)    &#125;</code></pre><p>不启用代表没有此菜单</p><p>不展示代表菜单不展示可以跳转 比如详情类页面需要id</p><p><img src="/2019/02/01/menu/1635497346785.png" alt="1635497346785"></p><p>1级菜单必须配置</p><p><img src="/2019/02/01/menu/1635497383715.png" alt="1635497383715"></p><p>二级菜单配置自己的组件</p><p>内部要包含</p><pre><code>  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;  &lt;router-view&gt;&lt;/router-view&gt;</code></pre><p><img src="/2019/02/01/menu/1635497475678.png" alt="1635497475678"></p>]]></content>
    
    
    <categories>
      
      <category>vue element</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue element</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element table 滚动条原来这么丑</title>
    <link href="/2018/12/20/scoll/"/>
    <url>/2018/12/20/scoll/</url>
    
    <content type="html"><![CDATA[<h3 id="element-table-滚动条是可以出来-但是有两个问题"><a href="#element-table-滚动条是可以出来-但是有两个问题" class="headerlink" title="element table 滚动条是可以出来 但是有两个问题"></a><strong>element table 滚动条是可以出来 但是有两个问题</strong></h3><p><strong>1样式原生太丑</strong><br><strong>2头部是什么鬼</strong></p><p><img src="/2018/12/20/scoll/1635228628657.png" alt="1635228628657"></p><p>直接在app.vue 中</p><p>原生样式修改 1 滚动条   2 表格头部</p><pre><code>  ::-webkit-scrollbar &#123;    width: 6px;    height: 6px;    background-color: #fff;&#125;::-webkit-scrollbar-thumb &#123;    -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);    background-color: rgba(0, 0, 0, .1)&#125;</code></pre><pre><code>.el-table--border th.el-table__cell.gutter:last-of-type&#123;  background-color: rgb(242, 243, 244);  border:0px;&#125; </code></pre><p>效果</p><p><img src="/2018/12/20/scoll/1635228755063.png" alt="1635228755063"></p><p><img src="/2018/12/20/scoll/1635228779784.png" alt="1635228779784"></p>]]></content>
    
    
    <categories>
      
      <category>element  滚动条</category>
      
    </categories>
    
    
    <tags>
      
      <tag>element  滚动条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ele 日历不支持多选？</title>
    <link href="/2018/11/21/dateLine/"/>
    <url>/2018/11/21/dateLine/</url>
    
    <content type="html"><![CDATA[<p><img src="/1635225291762.png" alt="1635225291762"></p><p><img src="/1635225316911.png" alt="1635225316911"></p><p>胡不多说直接上图</p><p><img src="/1635225779138.png" alt="1635225779138"></p><p>百度一波</p><p><img src="/1635225726023.png" alt="1635225726023"></p><p>确实v-model 是单个日期 但是自己实现还是很简单的 我自己的操作方式是</p><p>1 原理就是不需要用他的v-model  自己写个数组 点击的时候  包含就展示  不包含就取消</p><p>效果如下</p><p><img src="/1635225869758.png" alt="1635225869758"></p><p><img src="/1635225929593.png" alt="1635225929593"></p><p><img src="/1635225946194.png" alt="1635225946194"></p><p>2 按钮移入展示 因为日历官方小不了 弹窗又用户操作太麻烦</p><p><img src="/1635226176677.png" alt="1635226176677"></p><p><img src="/1635226203110.png" alt="1635226203110"></p>]]></content>
    
    
    <categories>
      
      <category>element  vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>element  vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作成功提示还在挨个加？</title>
    <link href="/2018/10/21/sucess/"/>
    <url>/2018/10/21/sucess/</url>
    
    <content type="html"><![CDATA[<p>业务中操作失败加全局提示就ok ，但是操作</p><p>业务中很多页面需要加操作提示成功？</p><p>全局增加？</p><p>但是查询列表和详情又不需要！</p><p>挨个增加又太累!!! 后期修改会流泪</p><p><img src="/2018/10/21/sucess/1635224165558.png" alt="1635224165558"></p><p>再封装个方法？</p><p><img src="/2018/10/21/sucess/1635224205609.png" alt="1635224205609"></p><p>element 已经够简单 还怎么破</p><p><img src="/2018/10/21/sucess/1635224247763.png" alt="1635224247763"></p><p>普通人挨个操作是这样</p><p><img src="/2018/10/21/sucess/1635224482675.png" alt="1635224482675"></p><p>我的方案是这样</p><p>1 在全局请求成功增加判断</p><p><img src="/2018/10/21/sucess/1635224594008.png" alt="1635224594008"></p><p>2在接口定义处增加   而不是使用处  </p><p><strong>这样的好处是</strong> </p><p><strong>改动地方少</strong> </p><p><strong>接口 修改 删除等知道改哪了</strong></p><p><strong>只有加这个才提示避免查询提示成功</strong></p><p><strong>提示信息也可每个自定义 把true 改为 内容</strong>  </p><p><strong>不影响parmas  导致后期人员迷惑</strong></p><p><img src="/2018/10/21/sucess/1635224629306.png" alt="1635224629306"></p><p><img src="/2018/10/21/sucess/1635224933548.png" alt="1635224933548"></p>]]></content>
    
    
    <categories>
      
      <category>element  vue axios</category>
      
    </categories>
    
    
    <tags>
      
      <tag>element  vue  axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器文件在线编辑</title>
    <link href="/2018/10/20/serveEdit/"/>
    <url>/2018/10/20/serveEdit/</url>
    
    <content type="html"><![CDATA[<p>突然发现很多人修改服务器文件流程是</p><ol><li>登录服务器下载下来</li><li>本地修改</li><li>上传</li></ol><p>还有些人是使用vim 编辑器 （很多人不会命令，撤销修改，代码提示都是麻烦）</p><p>有没有更好的方法</p><ol><li>不需要下载，在线修改</li><li>有代码提示，高亮，格式化（nginx空格不对会挂掉）</li></ol><p>其实很简单</p><p>使用xhell + vscode 实现</p><p><img src="/2018/10/20/serveEdit/1635154626078.png" alt="1635154626078"></p><p>早早下班 锻炼身体</p><p><img src="/2018/10/20/serveEdit/1635154780722.png" alt="1635154780722"></p>]]></content>
    
    
    <categories>
      
      <category>服务器  nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器  nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>electron 锁定用户版本</title>
    <link href="/2018/05/07/exe/"/>
    <url>/2018/05/07/exe/</url>
    
    <content type="html"><![CDATA[<h2 id="当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢"><a href="#当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢" class="headerlink" title="当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢?"></a>当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢?</h2><ol><li><p>升级用户浏览器 （备份用户数据 书签收藏夹）</p></li><li><p> 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑  数据独立）</p></li><li><p>  使用electron 包装应用 最简单 便捷 </p></li></ol><h3 id="前两种就不说了-这里介绍下第三种electron"><a href="#前两种就不说了-这里介绍下第三种electron" class="headerlink" title="前两种就不说了 这里介绍下第三种electron"></a>前两种就不说了 这里介绍下第三种electron</h3><p>​    先使用 </p><pre><code>yarn create electron-app my-app</code></pre><p> 然后 </p><pre><code>cd my-appyarn start</code></pre><p>接着把这里</p><p><img src="/2018/05/07/exe/1617783333020.png" alt="1617783333020"></p><pre><code>  const mainWindow = new BrowserWindow(&#123;    width: 1920,    height: 1080,    fullscreen:true,//全屏展示    center: true, // 窗口居中    resizable: true, // 窗口大小是否可改变    maximizable: true, // 窗口是否可以最大化    autoHideMenuBar:true  //关掉原始操作 重要  &#125;);  // and load the index.html of the app.  // mainWindow.loadFile(path.join(__dirname, &#39;index.html&#39;));  mainWindow.loadURL(&#39;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#39;)  // Open the DevTools.  开发者工具  // mainWindow.webContents.openDevTools();&#125;;</code></pre><p>最后打包</p><pre><code>npm run publish</code></pre><p>在目录下exe 就生成了</p><p><img src="/2018/05/07/exe/1617783408979.png" alt="1617783408979"></p><p>看下效果</p><p><img src="/2018/05/07/exe/1.gif" alt="1"></p><p>好处呢 不言而喻 直接给客户exe  </p><ol><li>文件简单直接  </li><li>运行默认全屏 干净整洁</li><li> 同时内核版本自己控制</li><li>不会有其他标签页尤其适合大屏演示</li></ol>]]></content>
    
    
    <categories>
      
      <category>谷歌浏览器  electron</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谷歌浏览器  electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好,朋友！</title>
    <link href="/2015/07/13/hellow/"/>
    <url>/2015/07/13/hellow/</url>
    
    <content type="html"><![CDATA[<p>我是GJL,一名前端程序猿</p><p>我的博客园地址  <a href="https://www.cnblogs.com/byksj/">查看</a></p><p>个人vscode 插件开发   <a href="https://marketplace.visualstudio.com/search?term=gjl&target=VSCode&category=All%20categories&sortBy=Relevance/">查看</a></p><p><img src="/2015/07/13/hellow/cj.png"></p><p>个人开发quicker 插件地址</p><p><img src="/2015/07/13/hellow/qk.png"></p><p>自动化部署脚本<a href="https://www.npmjs.com/package/depoly-gjl">查看</a></p><p><img src="/2015/07/13/hellow/1617784176762.png" alt="1617784176762"></p><p>个人小米自动化抢购脚本  <a href="https://www.cnblogs.com/byksj/p/14504972.html">查看</a></p><p><img src="/2015/07/13/hellow/1321821-20210309131947639-1780952264.gif"></p><p>这是一些过往欢快时刻<br><img src="/2015/07/13/hellow/1.png"></p><p><img src="/2015/07/13/hellow/ps2.jpg"></p><p>2020年<br><img src="/2015/07/13/hellow/tq.jpg"><br><img src="/2015/07/13/hellow/rb.jpg"></p><p><img src="/2015/07/13/hellow/ps.jpg"></p><p>2019年</p><p><img src="/2015/07/13/hellow/wl.jpg"><br>2016年</p><p><img src="/2015/07/13/hellow/lw.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>自己</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自己</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
