{"meta":{"title":"一直闭眼看世界博客","subtitle":"一个人的世界","description":"破而后立","author":"gjl","url":"https://gujinlonghaha.github.io"},"pages":[{"title":"about","date":"2015-04-02T05:16:38.000Z","updated":"2021-04-10T10:32:37.102Z","comments":false,"path":"about/index.html","permalink":"https://gujinlonghaha.github.io/about/index.html","excerpt":"","text":"我是一个程序员"}],"posts":[{"title":"公司文档生成利器","slug":"docsify","date":"2021-04-10T08:05:14.000Z","updated":"2021-04-10T10:32:36.938Z","comments":true,"path":"2021/04/10/docsify/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/10/docsify/","excerpt":"","text":"个人使用过hexo 等生成器但是这个是真厉害 因为他不需要把makdown 转化html 的编译过程启动极快 还有几个独特的优势 离线缓存 不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD 支持vue 花了半小时测测试效果如下 真好看 即使是公司的人不会代码也是轻而易举搞定 开始首选全局安装docsify-cli 1npm i docsify-cli -g 初始化初始化会自动生成./docs文件夹 12345docsify init ./docs// 如果不想新建一个文件夹，可以直接进行初始化操作docsify init 建立第一个文档初始化之后目录结构如下 1234|—— docs |—— index.html 入口 |—— README.md 主页 |—— .nojekyll 防止Github忽视下划线开头文件 预览网站执行以下命令，预览网站就在http://localhost:3000网址打开 12cd docsdocsify serve 离线缓存（PWA）1. 创建一个 servieWorker 根目录下创建sw.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* =========================================================== * docsify sw.js * =========================================================== * Copyright 2016 @huxpro * Licensed under Apache 2.0 * Register service worker. * ========================================================== */const RUNTIME = &quot;docsify&quot;;const HOSTNAME_WHITELIST = [self.location.hostname, &quot;fonts.gstatic.com&quot;, &quot;fonts.googleapis.com&quot;, &quot;cdn.jsdelivr.net&quot;];// The Util Function to hack URLs of intercepted requestsconst getFixedUrl = (req) =&gt; &#123; var now = Date.now(); var url = new URL(req.url); // 1. fixed http URL // Just keep syncing with location.protocol // fetch(httpURL) belongs to active mixed content. // And fetch(httpRequest) is not supported yet. url.protocol = self.location.protocol; // 2. add query for caching-busting. // Github Pages served with Cache-Control: max-age=600 // max-age on mutable content is error-prone, with SW life of bugs can even extend. // Until cache mode of Fetch API landed, we have to workaround cache-busting with query string. // Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190 if (url.hostname === self.location.hostname) &#123; url.search += (url.search ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;cache-bust=&quot; + now; &#125; return url.href;&#125;;/** * @Lifecycle Activate * New one activated when old isnt being used. * * waitUntil(): activating ====&gt; activated */self.addEventListener(&quot;activate&quot;, (event) =&gt; &#123; event.waitUntil(self.clients.claim());&#125;);/** * @Functional Fetch * All network requests are being intercepted here. * * void respondWith(Promise&lt;Response&gt; r) */self.addEventListener(&quot;fetch&quot;, (event) =&gt; &#123; // Skip some of cross-origin requests, like those for Google Analytics. if (HOSTNAME_WHITELIST.indexOf(new URL(event.request.url).hostname) &gt; -1) &#123; // Stale-while-revalidate // similar to HTTP&#x27;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale // Upgrade from Jake&#x27;s to Surma&#x27;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1 const cached = caches.match(event.request); const fixedUrl = getFixedUrl(event.request); const fetched = fetch(fixedUrl, &#123; cache: &quot;no-store&quot; &#125;); const fetchedCopy = fetched.then((resp) =&gt; resp.clone()); // Call respondWith() with whatever we get first. // If the fetch fails (e.g disconnected), wait for the cache. // If there’s nothing in cache, wait for the fetch. // If neither yields a response, return offline pages. event.respondWith( Promise.race([fetched.catch((_) =&gt; cached), cached]) .then((resp) =&gt; resp || fetched) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); // Update the cache with the version we fetched (only for ok status) event.waitUntil( Promise.all([fetchedCopy, caches.open(RUNTIME)]) .then(([response, cache]) =&gt; response.ok &amp;&amp; cache.put(event.request, response)) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); &#125;&#125;); 2. 在index.html文件中注册12345&lt;script&gt; if (typeof navigator.serviceWorker !== &quot;undefined&quot;) &#123; navigator.serviceWorker.register(&quot;sw.js&quot;); &#125;&lt;/script&gt;","categories":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/tags/docsify-%E6%96%87%E6%A1%A3/"}],"keywords":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}]},{"title":"简易版exe 打包","slug":"ahk","date":"2021-04-01T07:23:24.000Z","updated":"2021-04-10T10:32:36.922Z","comments":true,"path":"2021/04/01/ahk/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/01/ahk/","excerpt":"","text":"AHK自动热键强大的Windows的终极自动化脚本语言。 键绑定定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！ 什么是自动热键AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等 下载地址 安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器 窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！ 随便编写个脚本如下 12#z::Run https://autohotkey.com ; Win+Z 右键可以编译脚本为exe 如上图 tets.exe 双击启动 按下winow+z 就会自动打开 https://autohotkey.com 网址 其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe 对方得安装ahk 才可以 虽然是exe 可能底层还是需要ahk 的运行环境吧）","categories":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}],"tags":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/tags/ahk-exe/"}],"keywords":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}]},{"title":"安卓应用控件获取方法","slug":"app","date":"2021-03-20T07:23:24.000Z","updated":"2021-04-10T10:32:36.922Z","comments":true,"path":"2021/03/20/app/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/20/app/","excerpt":"","text":"网上随便搜索都是需要java sdk 等安卓adb 工具才能实现要不然就是Appium 手机自动化工具 不懂的人直接头皮发麻 直接劝退 而且有效信息只有一页 差点放弃 之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式） 针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现 特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难 一个知识和工具就是巨大鸿沟1地址 开发者工具简单好用 地址 效果 2手机版quicker 效果如下 从此以后你就可以编写自动化手机脚本无压力了 解放你的双手 自动打卡 自动抢购 自动导航","categories":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/tags/%E5%AE%89%E5%8D%93/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}]},{"title":"Nodejs+Selenium环境搭建以及深坑","slug":"sele","date":"2021-03-09T05:03:22.000Z","updated":"2021-04-10T10:32:37.098Z","comments":true,"path":"2021/03/09/sele/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/09/sele/","excerpt":"","text":"“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”这个sologan 还是够硬的，不过确实如此。 Selenium有以下功能特性: Selenium是一个开源和可移植的Web测试框架。 Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。 它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。 Selenium支持各种操作系统，浏览器和编程语言。如下列表: 编程语言: C# ，Java，Python，PHP，Ruby，Perl和JavaScript 操作系统:Android，iOS，Windows，Linux，Mac，Solaris。 浏览器:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。 它还支持并行测试执行，从而减少了时间并提高了测试效率。 Selenium可以与Ant和Maven等框架集成，用于源代码编译。 Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。 与其他自动化测试工具相比，Selenium需要的资源更少。 WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。 Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。 Selenium命令根据不同的类进行分类，使其更易于理解和实现。 Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。 局限性主要如下： Selenium不支持桌面应用程序的自动化测试。 Selenium需要高技能才能更有效地自动化测试。 由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。 无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。 使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。 它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。 Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。 无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。 与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。 新功能没有人可能少人使用，它们可能会也可能不会正常工作。 Selenium不为测试管理提供任何测试工具集成。 环境搭建1.安装 Nodejs到Nodejs官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。 node -v 2.项目初始化创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令： npm init 3.配置selenium运行环境在上一步相同的命令行下运行以下命令至其运行安装完成。 npm install selenium-webdriver –save 4.安装浏览器驱动 安装Chrome驱动 npm install chromedriver –save 安装Firefox驱动 npm install geckodriver –save 安装IE驱动 npm install iedriver –save 说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：http://www.seleniumhq.org/download/ 可能会碰到问题1）“The ChromeDriver could not be found on the current PATH” 需要将 ChromeDriver 添加到系统的环境变量 Path 中 也是就是你下载的exe 路径 自行更改 我本地还是失败 最终直接把exe 与脚本相同的目录下 运行正常 这个折腾了半天 2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url 解决方案 自己的浏览器和下载版本对应 基本用法一.初始化初始化一个浏览器并打开一个网页，如下： 1var webdriver = require(&#x27;selenium-webdriver&#x27;);var driver = new webdriver.Builder() .forBrowser(&#x27;ie&#x27;) .build();driver.get(&#x27;http://www.baidu.com&#x27;); 二.常用方法1.元素定位 根据id定位 1driver.findElement(By.id(&#x27;ID&#x27;))；//类似于jquery的$(&quot;#id&quot;) 根据className定位 1driver.findElement(By.className(&#x27;Class&#x27;))；//类似于jquery的$(&quot;.class&quot;) 更多定位方式可参考：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html 2.设置元素的值1driver.findElement(By.id(&#x27;ID&#x27;)).sendKeys(&#x27;value&#x27;);//类似于jquery的$(&quot;.id&quot;).val(&quot;value&quot;); 3.清空元素的值1driver.findElement(By.id(&#x27;id&#x27;)).clear(); 4.单击按钮1driver.findElement(By.id(&#x27;id&#x27;)).click(); 5.元素等待有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作： 1var until = webdriver.until;driver.wait(until.elementLocated(By.id(&#x27;id&#x27;), 10000));... 6.程序睡眠睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。 1driver.sleep(500);//毫秒 7.执行JavaScript在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转： 1driver.executeScript(&#x27;location.href=&quot;/xx.html&quot; &#x27;); 或者需要给元素设置值时可以使用： 1driver.executeScript(&#x27;document.getElementById(&quot;id&quot;).value=&quot;value&quot;&#x27;);//$(&quot;#id&quot;).val(&quot;value&quot;); 8.执行JavaScript并获取返回值在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。 1driver.executeScript(&#x27;return $(&quot;#id&quot;).val()&#x27;).then(function(obj)&#123; //obj即为返回值 if(obj&gt;100)&#123; //操作 &#125;else&#123; //其他操作 &#125;&#125;) 9.切换作用域（switchTo） 切换到iframe网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。 1driver.switchTo().frame(driver.findElement(By.id(&quot;iframe-id&quot;))); //iframe-id为iframe元素的id 切换到弹出框有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。 1driver.switchTo().alert().then(function(alert) &#123; //检测到弹出框时执行 //关闭alert return alert.dismiss();&#125;,function()&#123; //没有检测到弹出框时执行&#125;); 切换回主页面 1driver.switchTo().defaultContent(); 10.网页最大化（全屏）1driver.manage().window().maximize(); 11.网页截图(定位)网页截图看上去很简单，就一行代码如下： 1driver.takeScreenshot()； 截图后的结果为base64格式，可自行处理。类似这样： 1driver.takeScreenshot().then(function(d)&#123; //此处d即为截图结果base64字符串，可在此自行处理&#125;); 但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下： 1driver.findElement(By.className(&#x27;yanzheng&#x27;)).then(function(obj)&#123; obj.getSize().then(function(size)&#123; obj.getLocation().then(function(loc)&#123; driver.takeScreenshot().then(function(d)&#123; var data=&#123; d:d, width:size.width, height:size.height, x:loc.x, y:loc.y &#125;; //此处省略以下两步 //1.提交data信息到服务器处理图片 //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置x,y以及长宽width,height截取相应的图片 &#125;) &#125; &#125;&#125;) 12.退出程序（关闭网页）1driver.quit(); 更多详细文档可参考官方文档：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/ 下面是不错的资源中文文档 易百教程","categories":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}],"tags":[{"name":"Nodejs Selenium","slug":"Nodejs-Selenium","permalink":"https://gujinlonghaha.github.io/tags/Nodejs-Selenium/"}],"keywords":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}]},{"title":"pupeteer自动化加版本测试","slug":"pup","date":"2020-04-08T02:57:47.000Z","updated":"2021-04-10T10:32:37.098Z","comments":true,"path":"2020/04/08/pup/","link":"","permalink":"https://gujinlonghaha.github.io/2020/04/08/pup/","excerpt":"","text":"多版本谷歌测试如何进行没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决 puppeteerjs你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例： 生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展。 他其中有个模块 那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的 地址 需要fq 是第二个箭头也就是分支切换出来的版本号码 那他支持哪些版本呢 地址 淘宝给出了镜像地址 下面号码拿来直接用 现在谷歌浏览器都是下载安装器然后在线安装有没离线包 福利 自己写的部分常用脚本 以防忘记 1234567891011121314151617181920212223242526272829303132333435363738394041const puppeteer = require(&#x27;puppeteer&#x27;);let operte=async(t) =&gt; &#123; // 开启 browser const browserFetcher = puppeteer.createBrowserFetcher(); const revisionInfo = await browserFetcher.download(&#x27;533271&#x27;); //指定版本 const vesion= await browserFetcher.localRevisions() console.log(vesion) let browser = await puppeteer.launch(&#123; executablePath: revisionInfo.executablePath, headless: false, defaultViewport: &#123; height: 1080, width: 1920 &#125; &#125;); // 新增分页 console.log(browser) let page = await browser.newPage(); // 到自己的网站 await page.goto(`$&#123;t&#125;`); // 等待订阅按钮出现 // await page.waitForSelector(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // page.type(&#x27;#mytextarea&#x27;, &#x27;Hello&#x27;, &#123; delay: 100 &#125;); // 立即输入 // page.type(&#x27;#mytextarea&#x27;, &#x27;World&#x27;, &#123; delay: 100 &#125;); // 输入变慢，像一个用户 // // 点击订阅按钮 // await page.click(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // 关闭标签页 // page.close() // 关闭浏览器 // await browser.close();&#125;let arr=[ &#x27;https://www.baidu.com/&#x27;, // &#x27;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#x27;,]arr.forEach(t =&gt; &#123; operte(t)&#125;);","categories":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}],"tags":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/tags/pupeteer/"}],"keywords":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}]},{"title":"electron 锁定用户版本","slug":"exe","date":"2018-05-07T08:05:14.000Z","updated":"2021-04-10T10:32:36.938Z","comments":true,"path":"2018/05/07/exe/","link":"","permalink":"https://gujinlonghaha.github.io/2018/05/07/exe/","excerpt":"","text":"当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢? 升级用户浏览器 （备份用户数据 书签收藏夹） 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑 数据独立） 使用electron 包装应用 最简单 便捷 前两种就不说了 这里介绍下第三种electron​ 先使用 1yarn create electron-app my-app 然后 12cd my-appyarn start 接着把这里 1234567891011121314151617 const mainWindow = new BrowserWindow(&#123; width: 1920, height: 1080, fullscreen:true,//全屏展示 center: true, // 窗口居中 resizable: true, // 窗口大小是否可改变 maximizable: true, // 窗口是否可以最大化 autoHideMenuBar:true //关掉原始操作 重要 &#125;); // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;)); mainWindow.loadURL(&#x27;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#x27;) // Open the DevTools. 开发者工具 // mainWindow.webContents.openDevTools();&#125;; 最后打包 1npm run publish 在目录下exe 就生成了 看下效果 好处呢 不言而喻 直接给客户exe 文件简单直接 运行默认全屏 干净整洁 同时内核版本自己控制 不会有其他标签页尤其适合大屏演示","categories":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"tags":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"keywords":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}]},{"title":"你好,朋友！","slug":"hellow","date":"2013-07-13T12:46:25.000Z","updated":"2021-04-10T10:32:37.066Z","comments":true,"path":"2013/07/13/hellow/","link":"","permalink":"https://gujinlonghaha.github.io/2013/07/13/hellow/","excerpt":"","text":"我是GJL,一名前端程序猿 我的博客园地址 查看 个人vscode 插件开发 查看 个人开发quicker 插件地址 自动化部署脚本查看 个人小米自动化抢购脚本 查看 这是一些过往欢快时刻 2020年 2019年 2016年","categories":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/tags/%E8%87%AA%E5%B7%B1/"}],"keywords":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}]}]}