{"meta":{"title":"一直闭眼看世界博客","subtitle":"一个人的世界","description":"破而后立","author":"gjl","url":"https://gujinlonghaha.github.io"},"pages":[{"title":"about","date":"2015-04-02T05:16:38.000Z","updated":"2021-10-19T05:48:05.560Z","comments":false,"path":"about/index.html","permalink":"https://gujinlonghaha.github.io/about/index.html","excerpt":"","text":"我是程序员"}],"posts":[{"title":"人生的思考+追更（2021/8/4）+结更（2021/9/9）","slug":"yudong","date":"2021-06-21T04:23:24.000Z","updated":"2021-10-19T05:48:05.548Z","comments":true,"path":"2021/06/21/yudong/","link":"","permalink":"https://gujinlonghaha.github.io/2021/06/21/yudong/","excerpt":"","text":"关于读书​ 计划一年读12本书的，到目前为止已经读了20本书了。有些超出目标。 ​ 之前认为读书很难，后来发现其实也很简单，8万多字的白话文，在没有干扰的情况下可以两个小时读完，用别人的故事寻找自己的人生。人总是在前行，很少去思考，由于时间，由于精力，由于认知，但是你可以用别人多年专业总结的思考来启发你的人生。 初听不知曲中意，再听已是曲中人 书不是看过就懂了，很多书只有了经历了才明白，哪怕你以前反对的也开始认同了 一千个读者眼里有一千个哈姆雷特 我们能看到同样的东西，也会有不一样的见解，每个人的世界是不一样的 温故而知新 即使旧的东西 也因为时间变化你的感觉在变化 ​ 关于运动​ 你必须承认的身体机能确实开始退化，身体是最宝贵的财富，他是前面的1，其他都是后面的0000，看到很多keep上用户100天挑战计划够的身体变化确实震惊了。 ​ 自己也开始100天锻炼计划，目前是第7天，每天100多个胸部运动 ，100多个肩部运动，100多个腹部运动 读书 运动 饮食休息 情绪健康 是一生的良药，但是他要终身服用，不要想着一劳永逸，靠运气得来的东西，你别去羡慕人是很健忘的 即使是自己亲自做过的事也会忘记，用进废退，只有这样你才有可能超越别人，别人也有可能超越你，一切都是动态的 如果可以，希望自己每年至少锻炼100天和读12本书，多记录现在的自己，当你多年后回头看的时候就可以与现在的自己对话，可以是文字，可以是图片 8年前的自己 现在的自己 期待未来的自己 faq:永远不要忘了去爱你自己的身边人 2021/8/4 追更（50多天过去了）​ 100天计划目前时间过去了一半，三伏天确实够热，呼吸都会出汗的天气，但是还在坚持锻炼，可能是本身体脂率很低，效果不是特别明显，汇报下战况吧，应该做了5000+俯卧撑 10000+卷腹 效果如下 读的书从20本目前到了快40本 如图： 思考：即使目标是对的但是在坚持中也会有迷茫，彷徨，放弃的念头，但是人生就是对抗的过程，需要自我大旗，需要环境鼓励，回首的时候一切都值得 2021/9/9 结更（100天）从6月初到现在100天了，俯卧撑达到了10000+，卷腹达到了20000+，从之前俯卧撑一组10个到20到30到40到50，一天100个到最多时候480个俯卧撑。 书也是越来读的越顺，半天十万左右字的书，一天可以读20万左右的书。目前已经74本了，用几个小时去把作者一生的人生哲学浏览一遍是非常有价值的事情。 感悟：没有繁荣稳定的大环境一切都是空中楼阁，稳定的作息和生活确实是基础条件，否则计划就是空中楼阁","categories":[{"name":"思考 运动","slug":"思考-运动","permalink":"https://gujinlonghaha.github.io/categories/%E6%80%9D%E8%80%83-%E8%BF%90%E5%8A%A8/"}],"tags":[{"name":"思考 运动","slug":"思考-运动","permalink":"https://gujinlonghaha.github.io/tags/%E6%80%9D%E8%80%83-%E8%BF%90%E5%8A%A8/"}],"keywords":[{"name":"思考 运动","slug":"思考-运动","permalink":"https://gujinlonghaha.github.io/categories/%E6%80%9D%E8%80%83-%E8%BF%90%E5%8A%A8/"}]},{"title":"为你插上翅膀的离线文档","slug":"deaddoc","date":"2021-06-14T02:23:24.000Z","updated":"2021-10-19T05:48:05.340Z","comments":true,"path":"2021/06/14/deaddoc/","link":"","permalink":"https://gujinlonghaha.github.io/2021/06/14/deaddoc/","excerpt":"","text":"因为工作或者生活导致脱离互联网比如政府或者内网办公环境和国家防火墙的看不了文档怎么办你失去了地图 大脑善于运算不善于记忆，很多文档你只需要查找不需要记忆的，而且你也记不住 你可已使用离线文档 传送门 本人之前使用如下 基本涵盖的主流文档 如果是一些私有文档可以使用浏览器右键另存为pdf 这样你就可以复制粘贴了 一个小技也许就能让你重新展翅飞翔","categories":[{"name":"w3c doc","slug":"w3c-doc","permalink":"https://gujinlonghaha.github.io/categories/w3c-doc/"}],"tags":[{"name":"w3c doc","slug":"w3c-doc","permalink":"https://gujinlonghaha.github.io/tags/w3c-doc/"}],"keywords":[{"name":"w3c doc","slug":"w3c-doc","permalink":"https://gujinlonghaha.github.io/categories/w3c-doc/"}]},{"title":"亲手搭建node自动发送邮件和祝福语","slug":"eamil","date":"2021-05-20T02:23:24.000Z","updated":"2021-10-19T05:48:05.344Z","comments":true,"path":"2021/05/20/eamil/","link":"","permalink":"https://gujinlonghaha.github.io/2021/05/20/eamil/","excerpt":"","text":"适合场景：node 自动发送邮件 祝福语 日志 授权码 大家可以随意把玩搭建环境 node init -y npm install node-schedule axios nodemailer -D 新建 index.js var nodemailer = require(&#39;nodemailer&#39;); const axios = require(&#39;axios&#39;); const schedule = require(&quot;node-schedule&quot;); var transporter = nodemailer.createTransport(&#123; host: &#39;smtp.qq.com&#39;, auth: &#123; user: &#39;自己邮箱&#39;, pass: &#39;自己邮箱授权码&#39; //授权码,通过QQ获取 &#125; &#125;); var mailOptions = &#123; from: &#39;&#39;, // 发送者 to: &#39;&#39;, // 接受者,可以同时发送多个,以逗号隔开 subject: &#39;邮件发送&#39;, // 标题 text: &#39;Hello world&#39;, // 文本 html: `&lt;h2&gt;nodemailer基本测试:&lt;/h2&gt;&lt;h3&gt;gjl测试` &#125;; // 网上开放api https://api.muxiaoguo.cn/doc/caihongpi.html function getUserAccount() &#123; // 随机文字 return axios.get(&#39;https://api.muxiaoguo.cn/api/caihongpi&#39;); &#125; function getUserPermissions() &#123; // 随机图片 https://api.loli.bj/ return axios.get(&#39;https://api.loli.bj/api/?type=json&#39;); &#125; function init()&#123; axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (response, imgpon) &#123; console.log(response?.data?.data?.comment); console.log(imgpon?.data?.url); // 文本 mailOptions.html=response?.data?.data?.comment // 图片 mailOptions.html= mailOptions.html + &#39;&lt;img src=&quot;cid:ingurl&quot;/&gt;&#39; mailOptions.attachments=[&#123; filename: &#39;image.png&#39;, path: imgpon?.data?.url, cid: &#39;ingurl&#39; //same cid value as in the html img src &#125;, &#123; // filename and content type is derived from path path: &#39;./file.txt&#39; &#125;, ] // 发送邮件 transporter.sendMail(mailOptions, function (err, info) &#123; if (err) &#123; console.log(err); return; &#125; console.log(&#39;发送成功&#39;); &#125;); // 两个请求现在都执行完成 &#125;)).catch(function (error) &#123; console.log(&quot;接口异常&quot;); &#125;);; &#125; // 每格一分钟发送邮件 const job = schedule.scheduleJob(&#39; */1 * * * *&#39;, function()&#123; console.log(&#39;The answer to life, the universe, and everything!&#39;); init() &#125;); // 单词发送 // init() 效果如下 faq :授权码获得 部分想要拓展的配置","categories":[{"name":"nodemailer eamil qq","slug":"nodemailer-eamil-qq","permalink":"https://gujinlonghaha.github.io/categories/nodemailer-eamil-qq/"}],"tags":[{"name":"nodemailer eamil qq","slug":"nodemailer-eamil-qq","permalink":"https://gujinlonghaha.github.io/tags/nodemailer-eamil-qq/"}],"keywords":[{"name":"nodemailer eamil qq","slug":"nodemailer-eamil-qq","permalink":"https://gujinlonghaha.github.io/categories/nodemailer-eamil-qq/"}]},{"title":"前端不知道接口就不能爬到数据吗？直接爬html","slug":"pachong","date":"2021-04-25T06:45:46.000Z","updated":"2021-10-19T05:48:05.516Z","comments":true,"path":"2021/04/25/pachong/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/25/pachong/","excerpt":"","text":"一般前端都是调用接口，但是有时候碰到服务端页面一展示就是页面没有接口，怎么办呢？直接爬今天的主角 比如随便找一个网站测试 分析html 编写代码 const axios = require(&quot;axios&quot;); const cheerio = require(&quot;cheerio&quot;); const fs = require(&quot;fs&quot;); axios.get(&#39;https://www.taptap.com/top/download&#39;,&#123; &#125;).then((res)=&gt;&#123; // console.log(res.data) const $ = cheerio.load(res.data); let hotList = []; // console.log($(&quot;#topList&quot;)) $(&quot;#topList .taptap-top-card&quot;).each(function (index) &#123; if (index !== 0) &#123; const $td = $(this).children(&#39;.top-card-middle&#39;).eq(0); console.log($td) const link = $td.find(&quot;h4&quot;).text(); const text = $td.find(&quot;.card-middle-author&quot;).find(&#39;a&#39;).text(); const hotValue = $td.find(&quot;.card-middle-author&quot;).find(&#39;a&#39;).attr(&#39;herf&#39;); hotList.push(&#123; index, link, text, hotValue, &#125;); &#125; &#125;); fs.writeFileSync( `$&#123;__dirname&#125;/hotSearch.json`, JSON.stringify(hotList), &quot;utf-8&quot; ); &#125;) 结果输出","categories":[{"name":"cheerio html","slug":"cheerio-html","permalink":"https://gujinlonghaha.github.io/categories/cheerio-html/"}],"tags":[{"name":"cheerio html","slug":"cheerio-html","permalink":"https://gujinlonghaha.github.io/tags/cheerio-html/"}],"keywords":[{"name":"cheerio html","slug":"cheerio-html","permalink":"https://gujinlonghaha.github.io/categories/cheerio-html/"}]},{"title":"淘宝auto抢购脚本的逆向解析尝试","slug":"autojs","date":"2021-04-24T07:39:41.000Z","updated":"2021-10-19T05:48:05.300Z","comments":true,"path":"2021/04/24/autojs/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/24/autojs/","excerpt":"","text":"从淘宝搜索抢购脚本发现很多黑产很多都是用auto开发的 auto 的原理他是把js 打包成apk的 咱们可以破解以后二次修改吗? 我搜索了很多方法摸索一些时间进行了尝试 （如果有更好的方法可以联系我（除了付费方案 付费方案一大堆没意义）） 1 先使用开发助手将安装的apk 反编译 （本人使用破解版） 2 使用破解工具导入project目录 传送门 结果我测试了两个软件 一个是基本版的 左侧是破解后基本ok 右侧是源文件 可能打包处理了 看不懂 一个是网上的付费版 破解失败 （毕竟网上靠这个吃饭 ） 结论：流程是OK的 对于未加密和混淆的软件确实可以还原解密 但是对于专业团队研发的确实破解不了 毕竟解密和加密都是在相互博弈","categories":[{"name":"脚本破解","slug":"脚本破解","permalink":"https://gujinlonghaha.github.io/categories/%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3/"}],"tags":[{"name":"脚本 破解","slug":"脚本-破解","permalink":"https://gujinlonghaha.github.io/tags/%E8%84%9A%E6%9C%AC-%E7%A0%B4%E8%A7%A3/"}],"keywords":[{"name":"脚本破解","slug":"脚本破解","permalink":"https://gujinlonghaha.github.io/categories/%E8%84%9A%E6%9C%AC%E7%A0%B4%E8%A7%A3/"}]},{"title":"在线魔改百度和任意定制","slug":"jsrun","date":"2021-04-23T02:40:31.000Z","updated":"2021-10-19T05:48:05.512Z","comments":true,"path":"2021/04/23/jsrun/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/23/jsrun/","excerpt":"","text":"有时候你想改一些网站的样式，当然这个网站不属于你。甚至还向操作一些js。但是大家操作完以后些给丢掉掉。那怎么办呢？ 其实有一款很好的插件已经解决了上述的问题，它可以安装别的依赖库，诸如代码读取页面上的变量。这样的话你就可以魔改任何网站了。当然你也可以发现更多的玩法，比如说演示类的网站在不不改源码的情况下，只对固定客户端页面的展示。 在线编写js css 而且有代码提示 和网站过滤规则 引入第三方库 改完后 目前测试不支持跨域请求 但是需要的话可以使用我博客园推荐的插件去解决页面查询结果修改的问题 我的博客园讲解地址 拓展： 大家都喜欢使用console.log 调试代码 这样代码经常容易丢 可以使用代码段执行比较好","categories":[{"name":"恶搞 演示 好玩","slug":"恶搞-演示-好玩","permalink":"https://gujinlonghaha.github.io/categories/%E6%81%B6%E6%90%9E-%E6%BC%94%E7%A4%BA-%E5%A5%BD%E7%8E%A9/"}],"tags":[{"name":"恶搞 演示 好玩","slug":"恶搞-演示-好玩","permalink":"https://gujinlonghaha.github.io/tags/%E6%81%B6%E6%90%9E-%E6%BC%94%E7%A4%BA-%E5%A5%BD%E7%8E%A9/"}],"keywords":[{"name":"恶搞 演示 好玩","slug":"恶搞-演示-好玩","permalink":"https://gujinlonghaha.github.io/categories/%E6%81%B6%E6%90%9E-%E6%BC%94%E7%A4%BA-%E5%A5%BD%E7%8E%A9/"}]},{"title":"加密你的代码和ctx可以转rar","slug":"ctxFile","date":"2021-04-20T07:23:24.000Z","updated":"2021-10-19T05:48:05.328Z","comments":true,"path":"2021/04/20/ctxFile/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/20/ctxFile/","excerpt":"","text":"虽然自己的电脑装了一大堆谷歌插件，之前也看过谷歌插件的部分文章，但是也没有真真切切的去搞过。当真正去去使用时候还是有很多问题，也花费了很多时间，摸索了。 站在巨人肩膀上虽然资料不是很多常常比较划算的一种方式，毕竟生命有限，且用且珍贵。 本人电脑插件如图：（有时候自己都不知道浏览器能不能抗住 目前我认识的人中还没有见到比我多的） 为了展示全貌，我把它缩小了，看到右边的滚动条处，直到我电脑上装了的插件不少了。 自己编写的脚本如下 一个源文件 一个安装后的效果 脚本作用用来抢购 基于二次封装修改 遇到的问题 网上的文章说这两个文件不支持跨域域的，大家电脑可以自行测试。 content scipt 文件你想要获取页面中原有的变量，比如说windows上面的变量。是获取不到的本人测试， 但是可以通过injected script 可以直接获取到和操作。同时使用的文件需要放到安全区域里边。 这里是动态插入脚本 自己可以打包成ctx文件，但是直接拖入谷歌的话。谷歌为了安全考虑，其实是启用不了的，然后会报红色的错误，咱们的话可以把ctx文件后缀直接改成rar。然后再将RAR文件解压直接拖入就可以解决了。 当人们解压了这个文件的时候，其实你的源码就已经被暴露了。如何处理这个问题呢？咱们可以将关键的核心代码文件进行加密。 传送门","categories":[{"name":"ctx","slug":"ctx","permalink":"https://gujinlonghaha.github.io/categories/ctx/"}],"tags":[{"name":"ctx","slug":"ctx","permalink":"https://gujinlonghaha.github.io/tags/ctx/"}],"keywords":[{"name":"ctx","slug":"ctx","permalink":"https://gujinlonghaha.github.io/categories/ctx/"}]},{"title":"破解和逆向生成谷歌拓展ctx","slug":"ctx","date":"2021-04-18T06:44:40.000Z","updated":"2021-10-19T05:48:05.324Z","comments":true,"path":"2021/04/18/ctx/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/18/ctx/","excerpt":"","text":"当你需要给被人ctx谷歌拓展的时候怎么办 众所周知原因一般人上不去谷歌商店，同时大家也不会保存ctx原文件怎么办？（大家也可以通过国内镜像网站下载） ​ 其实可以使用谷歌的逆向生成 先打开谷歌已安装插件目录一般如下：（不对自行按照路径修改） C:\\Users\\user\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions 这些不是认识的代码不要怕 用我的为例子 其实就是id 代码 点击打包程序 输入对应拓展目录 点击打包就会生成 注意： 目录必须指向内部文件 结果 上层目录crx 文件生成 你找到了插件目录其实就可以魔改别人代码 比如去掉广告等","categories":[{"name":"chrome crx","slug":"chrome-crx","permalink":"https://gujinlonghaha.github.io/categories/chrome-crx/"}],"tags":[{"name":"chrome crx","slug":"chrome-crx","permalink":"https://gujinlonghaha.github.io/tags/chrome-crx/"}],"keywords":[{"name":"chrome crx","slug":"chrome-crx","permalink":"https://gujinlonghaha.github.io/categories/chrome-crx/"}]},{"title":"修改你的ntp服务器","slug":"ntp","date":"2021-04-16T06:45:46.000Z","updated":"2021-10-19T05:48:05.516Z","comments":true,"path":"2021/04/16/ntp/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/16/ntp/","excerpt":"","text":"一、NTP 是什么？网络时间协议，英文名称：Network Time Protocol（NTP）是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源（如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。NTP的目的是在无序的Internet环境中提供精确和健壮的时间服务。 二、NTP 实现什么目的？目的很简单，就是为了提供准确时间。因为我们的手表、手机、电脑等设备，经常会跑着跑着时间就出现了误差，或快或慢的少几秒，时间长了甚至误差过分钟。 三、NTP 服务器列表Windows系统上自带的两个：time.windows.com 和 time.nist.govMacOS上自带的两个：time.apple.com 和 time.asia.apple.comNTP授时快速域名服务：cn.ntp.org.cn 但是上面的基本上同步起来很慢，甚至直接同步超时，毕竟国外的服务器。所以推荐大家用国内的服务器同步。 1、阿里云授时服务器#NTP服务器 ntp.aliyun.com ntp1.aliyun.com ntp2.aliyun.com ntp3.aliyun.com ntp4.aliyun.com ntp5.aliyun.com ntp6.aliyun.com ntp7.aliyun.com #Time服务器 time1.aliyun.com time2.aliyun.com time3.aliyun.com time4.aliyun.com time5.aliyun.com time6.aliyun.com time7.aliyun.com 2、国内大学授时服务器s1c.time.edu.cn 北京大学 s2m.time.edu.cn 北京大学 s1b.time.edu.cn 清华大学 s1e.time.edu.cn 清华大学 s2a.time.edu.cn 清华大学 s2b.time.edu.cn 清华大学 3、国外授时服务器#苹果提供的授时服务器 time1.apple.com time2.apple.com time3.apple.com time4.apple.com time5.apple.com time6.apple.com time7.apple.com #Google提供的授时服务器 time1.google.com time2.google.com time3.google.com window修改ntp 方法 参考百度经验 或者工具直接修 自行搜索 需要同步系统时间，这里分享两个时间服务器接口api给大家： 1.淘宝时间服务器时间接口 http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp 返回json数据 &#123;&quot;api&quot;:&quot;mtop.common.getTimestamp&quot;,&quot;v&quot;:&quot;*&quot;,&quot;ret&quot;:[&quot;SUCCESS::接口调用成功&quot;],&quot;data&quot;:&#123;&quot;t&quot;:&quot;1586519130440&quot;&#125;&#125; 2.苏宁时间服务器接口api： http://quan.suning.com/getSysTime.do 返回json数据 &#123;&quot;sysTime2&quot;:&quot;2020-04-10 19:46:50&quot;,&quot;sysTime1&quot;:&quot;20200410194650&quot;&#125; demo： 自己修改如下","categories":[{"name":"ntp","slug":"ntp","permalink":"https://gujinlonghaha.github.io/categories/ntp/"}],"tags":[{"name":"ntp","slug":"ntp","permalink":"https://gujinlonghaha.github.io/tags/ntp/"}],"keywords":[{"name":"ntp","slug":"ntp","permalink":"https://gujinlonghaha.github.io/categories/ntp/"}]},{"title":"探索地铁行程卡快速通过","slug":"xingcheng","date":"2021-04-16T05:57:24.000Z","updated":"2021-10-19T05:48:05.524Z","comments":true,"path":"2021/04/16/xingcheng/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/16/xingcheng/","excerpt":"","text":"探索地铁行程卡快速通过 程序是方法论的流程化 让你流出更多的时间做重要的事 拓展了生命长度 ** 地铁入口前总是一堆人停下脚步做准备： 低头拿出手机 找到通信行程卡 勾选同意授权 点击查询 走过去排队 展示绿色行程卡 整个过程持续一分钟左右 有没有更好的办法呢 ？ 效果如下 只点击了一次通行图标（通行是自己写的脚本）其他都是自动化 这样你只需点一下不需要停下脚步就可以大步流星快速通过安检 方法： 不会编程不要紧 你可以下载手机版按键精灵 http://www.anjian.com/ 直接把操作录制一遍 就可以播放了 FAQ: 录制虽然简单但是他是基于坐标（x，y）来确定的 也就是说你要保证你的网络环境和图标位置不变 对于小白来说录制确实十分简单粗暴又友好 如果会编程以上问题可以忽略","categories":[{"name":"行程卡","slug":"行程卡","permalink":"https://gujinlonghaha.github.io/categories/%E8%A1%8C%E7%A8%8B%E5%8D%A1/"}],"tags":[{"name":"行程卡","slug":"行程卡","permalink":"https://gujinlonghaha.github.io/tags/%E8%A1%8C%E7%A8%8B%E5%8D%A1/"}],"keywords":[{"name":"行程卡","slug":"行程卡","permalink":"https://gujinlonghaha.github.io/categories/%E8%A1%8C%E7%A8%8B%E5%8D%A1/"}]},{"title":"帮运维快速切换内外网(二网双选一) 另附bat 转exe","slug":"bat","date":"2021-04-12T07:39:41.000Z","updated":"2021-10-19T05:48:05.304Z","comments":true,"path":"2021/04/12/bat/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/12/bat/","excerpt":"","text":"运维同事因为客户环境而发愁 因为客户(政府 电信等)环境是内网， 平时通信查问题是外网 来回切换网线 切换网卡 我想在网上检索个工具应该能解决吧？ 结果却不尽人意 没有合适的工具 不是根本不起作用就是只能切换ip 难道没有办法了吗？ 最终自己编写bat 解决 完美撒花汉字 专网 WLAN 分别是是网卡对应名称 记得修改 @echo off title gjl切换网络脚本 :stillAnswer set /p switch=1切换为专网，2切换为WLAN，3切换为双网卡，4退出： if %switch% == 1 ( netsh interface set interface name=&quot;专网&quot; admin=enabled netsh interface set interface name=&quot;WLAN&quot; admin=disabled echo -------------------当前网络为专网--------------------- goto stillAnswer )else if %switch% == 2 ( netsh interface set interface name=&quot;专网&quot; admin=disabled netsh interface set interface name=&quot;WLAN&quot; admin=enabled echo -------------------当前网络为WLAN--------------------- goto stillAnswer )else if %switch% == 3 ( netsh interface set interface name=&quot;专网&quot; admin=enabled netsh interface set interface name=&quot;WLAN&quot; admin=enabled echo -------------------双网卡同时启动--------------------- goto stillAnswer ) else if %switch% == 4 ( exit ) ::netsh interface set interface name=&quot;WLAN&quot; admin=disabled ::netsh interface set interface name=&quot;专网&quot; admin=enabled ::netsh interface set interface name=&quot;WLAN&quot; admin=enabled ::netsh interface set interface name=&quot;专网&quot; admin=disabled 新建bat文件保存后管理员身份运行 效果如下： 这样还不够完美 我有用bat 转为exe 如何bat转exe? 工具我上传了 下载:https://wws.lanzous.com/iVXwko1hiqb 密码:9qtj 我也发布到了quicker FAQ: 中文乱码解决方案 讲解：","categories":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/categories/%E7%BD%91%E5%8D%A1-bat/"}],"tags":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/tags/%E7%BD%91%E5%8D%A1-bat/"}],"keywords":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/categories/%E7%BD%91%E5%8D%A1-bat/"}]},{"title":"白嫖域名体验之旅","slug":"yuming","date":"2021-04-11T10:03:50.000Z","updated":"2021-10-19T05:48:05.552Z","comments":true,"path":"2021/04/11/yuming/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/11/yuming/","excerpt":"","text":"vercel传送门 登陆完导入仓库就完事了 效果地址 netlify 效果地址 说白了个gitee 差不多 只不过是国外的罢了 都是github 登录 然如导入仓库 next 毕竟多了两个选择彩蛋jsorg 如果你的项目足够优秀可以使用jsorg","categories":[{"name":"netlify vercel","slug":"netlify-vercel","permalink":"https://gujinlonghaha.github.io/categories/netlify-vercel/"}],"tags":[{"name":"域名  测试  netlify vercel","slug":"域名-测试-netlify-vercel","permalink":"https://gujinlonghaha.github.io/tags/%E5%9F%9F%E5%90%8D-%E6%B5%8B%E8%AF%95-netlify-vercel/"}],"keywords":[{"name":"netlify vercel","slug":"netlify-vercel","permalink":"https://gujinlonghaha.github.io/categories/netlify-vercel/"}]},{"title":"搭建自己的图床","slug":"imgurl","date":"2021-04-09T08:53:55.000Z","updated":"2021-10-19T05:48:05.508Z","comments":true,"path":"2021/04/09/imgurl/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/09/imgurl/","excerpt":"","text":"1. 什么是图床简单来说就是存储图片的服务器，将图片上传至该服务器中后，可以在公网中通过指定的URL获取此图片。 2. 图床的意义 减轻服务器带宽压力：图片资源可以由单独的服务器来存储、访问，例如腾讯云的COS、阿里云的OSS、七牛云等产品。 提供CDN加速：可以通过CDN的就近访问原则加快图片的访问速度。 第三条也就是最重要的一条，就是方便写文章。 3. 搭建图床 这里采用gitee作为图片仓库有两点原因，第一点是因为它是免费的，省去了自己维护服务器的费用。第二是因为它是国内的一个网站，所以相比与github来说，访问速度会更快一些。（后来试了一下github感觉也挺快的，差别并不明显，应该是使用了jsdelivr CDN的缘故） 码云图床限制如下 功能特性 社区版 企业版 使用场景 开源项目 个人私有仓库 免费版 协作开发 总计协作人数 不限 ≦ 5 人 ≦ 5 人 20 ~ 100 人+ 仓库总容量 5G 5G 5G 20 ~ 100G 单仓库大小 1G 500M 500M 1 ~ 3G 单文件大小 50M 50M 50M 100 ~ 300M 附件总容量 3G 3G 3G 10 ~ 50G + 创建图片仓库 大部分是用 传送门 我用的是utool的图床 从此你就有了自己的图床了","categories":[],"tags":[{"name":"图床 图片 gitee","slug":"图床-图片-gitee","permalink":"https://gujinlonghaha.github.io/tags/%E5%9B%BE%E5%BA%8A-%E5%9B%BE%E7%89%87-gitee/"}],"keywords":[]},{"title":"多端同步验证方案汇总","slug":"chormeText","date":"2021-04-06T07:13:31.000Z","updated":"2021-10-19T05:48:05.312Z","comments":true,"path":"2021/04/06/chormeText/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/06/chormeText/","excerpt":"","text":"BrowserShots 地址： http://browsershots.org 作为首批跨浏览器测试网站之一，支持多种浏览器，包括一些旧浏览器，如 Lynx、Konqueror 和 Seamonkey。 它会生成屏幕截图，显示你的网站在不同浏览器中的渲染表现，唯一的缺点是需要在线使用该工具。 Browser Sandbox 地址： https://turbo.net/browsers 它是一款可运行在桌面和平板上的应用程序，可以像运行原生浏览器那样运行多种浏览器。 它支持的浏览器种类很多，包括旧版本的 IE、Canary 及开发版的 IE。 MultiBrowser 地址： https://www.multibrowser.com 一款桌面应用程序，支持 IE7 到 IE11、Edge、Firefox 和 Chrome。你可以用它来测试网站的桌面版本和移动版本，可以进行手动测试或自动化测试。 LambdaTest 地址： https://www.lambdatest.com 一个在线服务，可用来进行不同平台的跨浏览器测试。例如，你可以测试网站在 Windows、Linux、macOS 上的不同浏览器（Firefox 或 Chrome）中的表现。 它还提供了一个集成调试工具、地理位置工具，可以用来测试本地站点。 Experitest Cross Browser Testing 地址： https://experitest.com/cross-browser-testing 这个工具可以用来测试网站在不同环境下的兼容性和性能。它还可以与其他服务集成起来，比如 Github、Gitlab、Jenkins、TravisCI 和 CircleCI 等，把网站的部署流程流水线化。 BrowserStack 地址： https://www.browserstack.com 跨浏览器测试领域响当当的一款工具，被一些大型开源项目采用，比如 jQuery 和 React.js。BrowserStack 列出了数百种浏览器、设备和测试策略，确保你的网站可以在尽可能多的环境中正常运行。 SauceLabs 地址： https://saucelabs.com SauceLabs 为各种规模的网站提供了完整的浏览器兼容性测试工具，不管是企业级的、中小型公司还是开源项目。 CrossBrowserTesting 地址： https://crossbrowsertesting.com 使用这个工具，可以不写代码进行自动化浏览器兼容性测试，可以测试线上或本地站点，还可以截取屏幕快照和视频。 TestingBot 地址： https://testingbot.com TestingBot 为网站和原生移动 App 提供了完整的测试策略，可以在真实的 iOS 或 Android 设备上运行测试。 Browserling 地址： https://www.browserling.com 如果你想要在 IE 上进行快速测试，BrowserLing 或许是个不错的选择。 你可以用它进行简单的交互式测试，支持一些旧浏览器，比如 IE 10、IE 11 和 Safari 4、Safari 5。 Comparium 地址： https://comparium.app Comparium 提供了一个免费的工具，可以截取不同环境下的屏幕快照，并进行比对。 Puppeteer 地址： https://github.com/puppeteer/puppeteer Puppeteer 是一个 Node.js 模块，提供了与 Chrome 和 Firefox 交互的 API。 你可以用它提供的 API 来截取屏幕快照、生成 PDF、进行自动化交互式测试（比如自动填写表单、键盘输入），整体上可以进行自动化网站测试。 Playwright 地址： https://github.com/microsoft/playwright Playwright 是微软设计的一个项目，用于执行自动化浏览器测试。它提供了一个简单的 API。除了可以模拟用户交互，还可以拦截网络请求、模拟移动设备、支持地理位置数据和权限控制。 Playwright 支持基于 Chromium 的浏览器、Firefox 和 Webkit（比如 Safari）。 Nightwatch.js 地址： https://nightwatchjs.org NightWatch.js 是一个用于进行端到端侧二十的 Node.js 模块。它提供了简单易用的 API，可用它检查某个元素是否包含了特定的文本或是否可见，甚至是可以用来测试 CSS 类、CSS ID 和属性。 Cypress 地址： https://www.cypress.io Cypress 是一个端到端测试套件，可用来测试和调试现代 Web 应用程序。 它在执行测试的同时还能记录下每一个测试的状态。你可以回溯每一个状态，并比较状态之间都发生了什么变化，这让 Web 应用程序的调试变得很直观。 WebDriverIO 地址： https://webdriver.io 这是一款 Node.js 自动化测试框架，支持很多 JavaScript 库，比如 React.js、Vue 和 Angular。 因为它是基于 W3C WebDriver 和 Chrome DevTools 的，所以可以在本地运行，也可以在云端运行，就像 SauceLab、BrowserStack 和 TestingBot 那样。 Selenium 地址： https://www.selenium.dev Selenium 是一款浏览器自动化测试工具。实际上，它并没有提供现成的测试框架，但可以通过扩展来实现。 很多测试框架、App 或服务，包括上述的一些工具都是基于 Selenium 的。","categories":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/categories/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/tags/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"keywords":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/categories/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"公司文档生成利器","slug":"docsify","date":"2021-04-04T08:05:14.000Z","updated":"2021-10-19T05:48:05.344Z","comments":true,"path":"2021/04/04/docsify/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/04/docsify/","excerpt":"","text":"个人使用过hexo 等生成器但是这个是真厉害 因为他不需要把makdown 转化html 的编译过程启动极快 还有几个独特的优势 离线缓存 不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD 支持vue 花了半小时测测试效果如下 真好看 即使是公司的人不会代码也是轻而易举搞定 开始首选全局安装docsify-cli npm i docsify-cli -g 初始化初始化会自动生成./docs文件夹 docsify init ./docs // 如果不想新建一个文件夹，可以直接进行初始化操作 docsify init 建立第一个文档初始化之后目录结构如下 |—— docs |—— index.html 入口 |—— README.md 主页 |—— .nojekyll 防止Github忽视下划线开头文件 预览网站执行以下命令，预览网站就在http://localhost:3000网址打开 cd docs docsify serve 离线缓存（PWA）1. 创建一个 servieWorker 根目录下创建sw.js文件 /* =========================================================== * docsify sw.js * =========================================================== * Copyright 2016 @huxpro * Licensed under Apache 2.0 * Register service worker. * ========================================================== */ const RUNTIME = &quot;docsify&quot;; const HOSTNAME_WHITELIST = [self.location.hostname, &quot;fonts.gstatic.com&quot;, &quot;fonts.googleapis.com&quot;, &quot;cdn.jsdelivr.net&quot;]; // The Util Function to hack URLs of intercepted requests const getFixedUrl = (req) =&gt; &#123; var now = Date.now(); var url = new URL(req.url); // 1. fixed http URL // Just keep syncing with location.protocol // fetch(httpURL) belongs to active mixed content. // And fetch(httpRequest) is not supported yet. url.protocol = self.location.protocol; // 2. add query for caching-busting. // Github Pages served with Cache-Control: max-age=600 // max-age on mutable content is error-prone, with SW life of bugs can even extend. // Until cache mode of Fetch API landed, we have to workaround cache-busting with query string. // Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190 if (url.hostname === self.location.hostname) &#123; url.search += (url.search ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;cache-bust=&quot; + now; &#125; return url.href; &#125;; /** * @Lifecycle Activate * New one activated when old isnt being used. * * waitUntil(): activating ====&gt; activated */ self.addEventListener(&quot;activate&quot;, (event) =&gt; &#123; event.waitUntil(self.clients.claim()); &#125;); /** * @Functional Fetch * All network requests are being intercepted here. * * void respondWith(Promise&lt;Response&gt; r) */ self.addEventListener(&quot;fetch&quot;, (event) =&gt; &#123; // Skip some of cross-origin requests, like those for Google Analytics. if (HOSTNAME_WHITELIST.indexOf(new URL(event.request.url).hostname) &gt; -1) &#123; // Stale-while-revalidate // similar to HTTP&#39;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale // Upgrade from Jake&#39;s to Surma&#39;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1 const cached = caches.match(event.request); const fixedUrl = getFixedUrl(event.request); const fetched = fetch(fixedUrl, &#123; cache: &quot;no-store&quot; &#125;); const fetchedCopy = fetched.then((resp) =&gt; resp.clone()); // Call respondWith() with whatever we get first. // If the fetch fails (e.g disconnected), wait for the cache. // If there’s nothing in cache, wait for the fetch. // If neither yields a response, return offline pages. event.respondWith( Promise.race([fetched.catch((_) =&gt; cached), cached]) .then((resp) =&gt; resp || fetched) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); // Update the cache with the version we fetched (only for ok status) event.waitUntil( Promise.all([fetchedCopy, caches.open(RUNTIME)]) .then(([response, cache]) =&gt; response.ok &amp;&amp; cache.put(event.request, response)) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); &#125; &#125;); 2. 在index.html文件中注册&lt;script&gt; if (typeof navigator.serviceWorker !== &quot;undefined&quot;) &#123; navigator.serviceWorker.register(&quot;sw.js&quot;); &#125; &lt;/script&gt;","categories":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/tags/docsify-%E6%96%87%E6%A1%A3/"}],"keywords":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}]},{"title":"简易版exe 打包","slug":"ahk","date":"2021-04-01T07:23:24.000Z","updated":"2021-10-19T05:48:05.288Z","comments":true,"path":"2021/04/01/ahk/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/01/ahk/","excerpt":"","text":"AHK自动热键强大的Windows的终极自动化脚本语言。 键绑定定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！ 什么是自动热键AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等 下载地址 安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器 窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！ 随便编写个脚本如下 #z::Run https://autohotkey.com ; Win+Z 右键可以编译脚本为exe 如上图 tets.exe 双击启动 按下winow+z 就会自动打开 https://autohotkey.com 网址 其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe 对方得安装ahk 才可以 虽然是exe 可能底层还是需要ahk 的运行环境吧）","categories":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}],"tags":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/tags/ahk-exe/"}],"keywords":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}]},{"title":"小记：网页调用app 启动并打开固定地址","slug":"qidong","date":"2021-03-30T08:46:15.000Z","updated":"2021-10-19T05:48:05.520Z","comments":true,"path":"2021/03/30/qidong/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/30/qidong/","excerpt":"","text":"我们能在浏览器内跳转网页是http、https协议，能打开本地文件是file协议，调用APP用的是scheme协议或者intent协议，其实都是发送请求，获得响应，只是网页和APP是使用这两个协议通信的。scheme协议不仅仅用于ios端，也适用于安卓。但intent只适用于安卓。 1、scheme协议在 iOS 里，程序之间都是相互隔离，目前并没有一个有效的方式来做程序间通信，幸好 iOS 程序可以很方便的注册自己的 URL Scheme，这样就可以通过打开特定 URL 的方式来传递参数给另外一个程序。原生的APP和网页通过这种协议可以互相通信，safari或者APP的webView都可以识别该协议（一些浏览器如微信内置浏览器和QQ浏览器不支持，据后台技术哥哥介绍这是腾讯有意屏蔽，默认的webview控件是支持的）. 如果是自己的APP想被网页调用，需要自己在app中注册scheme，这不是我研究的范畴。。。 我们一般是调用别人的APP，会使用scheme协议就行,其实特简单，通过链接就可以。 常用APP的schemeQQ mqq://微信 weixin://淘宝 taobao://大众点评 dianping:// dianping://search新浪微博 sinaweibo://支付宝 alipay://豆瓣fm doubanradio://美团 imeituan://1号店 wccbyihaodian://有道词典yddictproapp://知乎 zhihu://优酷 youku:// 见知乎上的整理：http://www.zhihu.com/question/19907735 2、intent协议“在一个Android应用中，主要是由四种组件组成的，这四种组件可参考“Android应用的构成”。而这四种组件是独立的，它们之间可以互相调用，协调工作，最终组成一个真正的Android应用。在这些组件之间的通讯中，主要是由Intent协助完成的。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。因此，Intent在这里起着一个媒体中介的作用，专门提供组件互相调用的相关信息，实现调用者与被调用者之间的解耦。”所以说intent是协议是不准确的，intent实际上是一种在不同组件之间传递的请求信息。 示例：网页调取百度地图、高德地图官方文档： 1、高德地图：http://lbs.amap.com/api/uri-api/ios-uri-explain/ 2、百度地图：http://developer.baidu.com/map/index.php?title=uri/api/ios 测试： &lt;a href=&quot;taobao://detail.m.tmall.com/item.htm?spm=a2141.8971817.50003458.1&amp;id=612053462785&amp;scm=1007.15522.117270.cat:50003458_industry:_cattype:cat_id:612053462785&amp;pvid=0982d09f-d63f-438f-af91-5434a11305f4&amp;scene=5522&quot;&gt;大萨达撒&lt;/a&gt; 手机端调用页面 页面地址获取","categories":[{"name":"app","slug":"app","permalink":"https://gujinlonghaha.github.io/categories/app/"}],"tags":[{"name":"app","slug":"app","permalink":"https://gujinlonghaha.github.io/tags/app/"}],"keywords":[{"name":"app","slug":"app","permalink":"https://gujinlonghaha.github.io/categories/app/"}]},{"title":"安卓应用控件获取方法","slug":"app","date":"2021-03-20T07:23:24.000Z","updated":"2021-10-19T05:48:05.288Z","comments":true,"path":"2021/03/20/app/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/20/app/","excerpt":"","text":"网上随便搜索都是需要java sdk 等安卓adb 工具才能实现要不然就是Appium 手机自动化工具 不懂的人直接头皮发麻 直接劝退 而且有效信息只有一页 差点放弃 之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式） 针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现 特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难 一个知识和工具就是巨大鸿沟1地址 开发者工具简单好用 地址 效果 2手机版quicker 效果如下 从此以后你就可以编写自动化手机脚本无压力了 解放你的双手 自动打卡 自动抢购 自动导航","categories":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/tags/%E5%AE%89%E5%8D%93/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}]},{"title":"Nodejs+Selenium环境搭建以及深坑","slug":"sele","date":"2021-03-09T05:03:22.000Z","updated":"2021-10-19T05:48:05.520Z","comments":true,"path":"2021/03/09/sele/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/09/sele/","excerpt":"","text":"“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”这个sologan 还是够硬的，不过确实如此。 Selenium有以下功能特性: Selenium是一个开源和可移植的Web测试框架。 Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。 它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。 Selenium支持各种操作系统，浏览器和编程语言。如下列表: 编程语言: C# ，Java，Python，PHP，Ruby，Perl和JavaScript 操作系统:Android，iOS，Windows，Linux，Mac，Solaris。 浏览器:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。 它还支持并行测试执行，从而减少了时间并提高了测试效率。 Selenium可以与Ant和Maven等框架集成，用于源代码编译。 Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。 与其他自动化测试工具相比，Selenium需要的资源更少。 WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。 Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。 Selenium命令根据不同的类进行分类，使其更易于理解和实现。 Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。 局限性主要如下： Selenium不支持桌面应用程序的自动化测试。 Selenium需要高技能才能更有效地自动化测试。 由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。 无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。 使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。 它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。 Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。 无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。 与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。 新功能没有人可能少人使用，它们可能会也可能不会正常工作。 Selenium不为测试管理提供任何测试工具集成。 环境搭建1.安装 Nodejs到Nodejs官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。 node -v 2.项目初始化创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令： npm init 3.配置selenium运行环境在上一步相同的命令行下运行以下命令至其运行安装完成。 npm install selenium-webdriver –save 4.安装浏览器驱动 安装Chrome驱动 npm install chromedriver –save 安装Firefox驱动 npm install geckodriver –save 安装IE驱动 npm install iedriver –save 说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：http://www.seleniumhq.org/download/ 可能会碰到问题1）“The ChromeDriver could not be found on the current PATH” 需要将 ChromeDriver 添加到系统的环境变量 Path 中 也是就是你下载的exe 路径 自行更改 我本地还是失败 最终直接把exe 与脚本相同的目录下 运行正常 这个折腾了半天 2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url 解决方案 自己的浏览器和下载版本对应 基本用法一.初始化初始化一个浏览器并打开一个网页，如下： var webdriver = require(&#39;selenium-webdriver&#39;);var driver = new webdriver.Builder() .forBrowser(&#39;ie&#39;) .build();driver.get(&#39;http://www.baidu.com&#39;); 二.常用方法1.元素定位 根据id定位 driver.findElement(By.id(&#39;ID&#39;))；//类似于jquery的$(&quot;#id&quot;) 根据className定位 driver.findElement(By.className(&#39;Class&#39;))；//类似于jquery的$(&quot;.class&quot;) 更多定位方式可参考：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html 2.设置元素的值driver.findElement(By.id(&#39;ID&#39;)).sendKeys(&#39;value&#39;);//类似于jquery的$(&quot;.id&quot;).val(&quot;value&quot;); 3.清空元素的值driver.findElement(By.id(&#39;id&#39;)).clear(); 4.单击按钮driver.findElement(By.id(&#39;id&#39;)).click(); 5.元素等待有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作： var until = webdriver.until;driver.wait(until.elementLocated(By.id(&#39;id&#39;), 10000));... 6.程序睡眠睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。 driver.sleep(500);//毫秒 7.执行JavaScript在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转： driver.executeScript(&#39;location.href=&quot;/xx.html&quot; &#39;); 或者需要给元素设置值时可以使用： driver.executeScript(&#39;document.getElementById(&quot;id&quot;).value=&quot;value&quot;&#39;);//$(&quot;#id&quot;).val(&quot;value&quot;); 8.执行JavaScript并获取返回值在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。 driver.executeScript(&#39;return $(&quot;#id&quot;).val()&#39;).then(function(obj)&#123; //obj即为返回值 if(obj&gt;100)&#123; //操作 &#125;else&#123; //其他操作 &#125;&#125;) 9.切换作用域（switchTo） 切换到iframe网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。 driver.switchTo().frame(driver.findElement(By.id(&quot;iframe-id&quot;))); //iframe-id为iframe元素的id 切换到弹出框有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。 driver.switchTo().alert().then(function(alert) &#123; //检测到弹出框时执行 //关闭alert return alert.dismiss();&#125;,function()&#123; //没有检测到弹出框时执行&#125;); 切换回主页面 driver.switchTo().defaultContent(); 10.网页最大化（全屏）driver.manage().window().maximize(); 11.网页截图(定位)网页截图看上去很简单，就一行代码如下： driver.takeScreenshot()； 截图后的结果为base64格式，可自行处理。类似这样： driver.takeScreenshot().then(function(d)&#123; //此处d即为截图结果base64字符串，可在此自行处理&#125;); 但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下： driver.findElement(By.className(&#39;yanzheng&#39;)).then(function(obj)&#123; obj.getSize().then(function(size)&#123; obj.getLocation().then(function(loc)&#123; driver.takeScreenshot().then(function(d)&#123; var data=&#123; d:d, width:size.width, height:size.height, x:loc.x, y:loc.y &#125;; //此处省略以下两步 //1.提交data信息到服务器处理图片 //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置x,y以及长宽width,height截取相应的图片 &#125;) &#125; &#125;&#125;) 12.退出程序（关闭网页）driver.quit(); 更多详细文档可参考官方文档：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/ 下面是不错的资源中文文档 易百教程","categories":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}],"tags":[{"name":"Nodejs Selenium","slug":"Nodejs-Selenium","permalink":"https://gujinlonghaha.github.io/tags/Nodejs-Selenium/"}],"keywords":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}]},{"title":"文档中代码编辑加预览","slug":"code","date":"2020-10-13T06:27:43.000Z","updated":"2021-10-19T05:48:05.324Z","comments":true,"path":"2020/10/13/code/","link":"","permalink":"https://gujinlonghaha.github.io/2020/10/13/code/","excerpt":"","text":"好文档是什么呢？（其实有人已经回答）我一直在思考 🤔 怎么的 Vue 文档交互才是好的 👍, 后来得出的结论是: 能看代码 能看效果 能在线编辑代码, 并实时预览结果 能做到前 2 点的 Vue 组件不少, 但能做到第 3 点, 并对文档的 DEMO 编写做优化处理的并不多 找了好久功夫不负有心人 还是有大神造就出了轮子 轮子总是能效率提升百倍 以 docsify 为例子 （v-charts 展示源码同时 可预览 编辑 就是用的这个做的文档 虽然线上目前出故障了到是 ） 地址 原理使用vuep 这是个好东西 随后又找到另一个类似网站 ve-charts 有源码 有demo 源码编辑 demo 联动 以上都是vuep 技术实现 还没有没别的方式呢vue-run-sfc 你值得拥有🍎 使用&lt;script&gt; window.$docsify = &#123; // 配置, 更多属性解释请往下面翻 ↓ run: &#123; themeColor: &#39;green&#39;, themeBorderColor: &#39;#eee&#39;, reverse: true, // ... &#125; &#125; &lt;/script&gt; &lt;!-- 引入Vue --&gt; &lt;script src=&quot;//unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入 vue-run-sfc --&gt; &lt;script src=&quot;//unpkg.com/vue-run-sfc&quot;&gt;&lt;/script&gt; &lt;!-- 引入 docsify-plugin-run --&gt; &lt;script src=&quot;https://unpkg.com/docsify-plugin-run/src/index.js&quot;&gt;&lt;/script&gt; &lt;!-- 指定版本 --&gt; &lt;!-- &lt;script src=&quot;https://unpkg.com/docsify-plugin-run@xx.xx.xx/src/index.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- docsify --&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; 🍊示例全局配置: 运行 element-ui&lt;script&gt; window.$docsify = &#123; run: &#123; jsLabs: [&#39;https://unpkg.com/element-ui/lib/index.js&#39;], cssLabs: [&#39;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#39;], &#125; &#125; &lt;/script&gt; ``html run &lt;template&gt; &lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/template&gt; `` &lt;== 这里和上面的 ` 有 3 个 最终效果我放在了码云地址简单测试效果如图","categories":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}],"tags":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/tags/docsify-vuepres-code-run/"}],"keywords":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}]},{"title":"小试尤大大vuepress vue 文档神器","slug":"vuepress","date":"2020-08-01T03:15:12.000Z","updated":"2021-10-19T05:48:05.524Z","comments":true,"path":"2020/08/01/vuepress/","link":"","permalink":"https://gujinlonghaha.github.io/2020/08/01/vuepress/","excerpt":"","text":"没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)简洁至上以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 Vue 驱动享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。 高性能VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。 #为什么不是…?#NuxtVuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。 #Docsify / Docute这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！ #HexoHexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。 #GitBook我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。 个人小试如下 很快就搭建了架子 部署在了gitee 上 配置如下 注意配置这才会展示 官方文档有介绍 和部署域名后缀一样就ok了 测试效果如下 彩蛋codepen 如何引入到文档显得高大上？？？如下 See the Pen QWdaRMR by gujinlong (@gujinlonghaha) on CodePen. 步骤先保存 然后获取iframe 最后直接放在md 源文件","categories":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}],"tags":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/tags/vuepress/"}],"keywords":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}]},{"title":"pupeteer自动化加版本测试","slug":"pup","date":"2020-04-08T02:57:47.000Z","updated":"2021-10-19T05:48:05.516Z","comments":true,"path":"2020/04/08/pup/","link":"","permalink":"https://gujinlonghaha.github.io/2020/04/08/pup/","excerpt":"","text":"多版本谷歌测试如何进行没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决 puppeteerjs你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例： 生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展。 他其中有个模块 那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的 地址 需要fq 是第二个箭头也就是分支切换出来的版本号码 那他支持哪些版本呢 地址 淘宝给出了镜像地址 下面号码拿来直接用 现在谷歌浏览器都是下载安装器然后在线安装有没离线包 福利 自己写的部分常用脚本 以防忘记 const puppeteer = require(&#39;puppeteer&#39;); let operte=async(t) =&gt; &#123; // 开启 browser const browserFetcher = puppeteer.createBrowserFetcher(); const revisionInfo = await browserFetcher.download(&#39;533271&#39;); //指定版本 const vesion= await browserFetcher.localRevisions() console.log(vesion) let browser = await puppeteer.launch(&#123; executablePath: revisionInfo.executablePath, headless: false, defaultViewport: &#123; height: 1080, width: 1920 &#125; &#125;); // 新增分页 console.log(browser) let page = await browser.newPage(); // 到自己的网站 await page.goto(`$&#123;t&#125;`); // 等待订阅按钮出现 // await page.waitForSelector(&quot;button[class=&#39;subscribe-button pill-button&#39;]&quot;); // page.type(&#39;#mytextarea&#39;, &#39;Hello&#39;, &#123; delay: 100 &#125;); // 立即输入 // page.type(&#39;#mytextarea&#39;, &#39;World&#39;, &#123; delay: 100 &#125;); // 输入变慢，像一个用户 // // 点击订阅按钮 // await page.click(&quot;button[class=&#39;subscribe-button pill-button&#39;]&quot;); // 关闭标签页 // page.close() // 关闭浏览器 // await browser.close(); &#125; let arr=[ &#39;https://www.baidu.com/&#39;, // &#39;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#39;, ] arr.forEach(t =&gt; &#123; operte(t) &#125;);","categories":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}],"tags":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/tags/pupeteer/"}],"keywords":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}]},{"title":"vue 批量自动化","slug":"vue","date":"2019-10-10T10:03:50.000Z","updated":"2021-10-19T05:48:05.520Z","comments":true,"path":"2019/10/10/vue/","link":"","permalink":"https://gujinlonghaha.github.io/2019/10/10/vue/","excerpt":"","text":"vue 批量注册全局组件 自动全局注册免去手动操作 早点下班 代码 // 引入vue import Vue from &#39;vue&#39; // 引入同目录下的全部组件 const requireCom = require.context(&#39;.&#39;, false, /\\.vue$/) // 依次进行注册 requireCom.keys().forEach(key =&gt; &#123; // 字符串首字母大写处理 function strUp(str) &#123; return str.charAt(0).toUpperCase() + str.slice(1) &#125; // 获取单个组件内容 const _component = requireCom(key) // 获取组件名称 const _componentName = strUp(key.replace(/^\\.\\//, &#39;&#39;).replace(/\\.\\w+$/, &#39;&#39;)) // 注册在vue上 Vue.component(_componentName, _component.default || _component) &#125;) 在一个项目中, 某些过滤器全局都有可能用的到, 统一管理并自动化全局注册是很方便的. 代码如下, 后续只需要在src/filters/index.js中添加方法就可以全局使用过滤器了. // src/filters/index.js // 格式化方法 export function formatNull (val) &#123; return val ? val : &#39;--&#39; &#125; // mian.js import Vue from &#39;vue&#39; import * as filters from &#39;./filters&#39; // 全局注册过滤器 Object.keys(filters).forEach(k =&gt; Vue.filter(k, filters[k]));","categories":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/categories/element/"}],"tags":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/tags/element/"}],"keywords":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/categories/element/"}]},{"title":"vue支持可选链操作符","slug":"kxl","date":"2019-05-11T10:03:50.000Z","updated":"2021-10-19T05:48:05.516Z","comments":true,"path":"2019/05/11/kxl/","link":"","permalink":"https://gujinlonghaha.github.io/2019/05/11/kxl/","excerpt":"","text":"在开发过程中拿到一个内嵌比较深的值需要做很多的判断，来保证没有数据而报错，比如 const obj = &#123; a: &#123; b: &#123; c:&quot;1&quot; &#125; &#125; &#125; 取c, 正确的做法是： const cValue = (obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c) || &#39;&#39;; // 需要判断4次，每一层是否有值 直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined 取c const cValue = obj?.a?.b?.c //1 如何在项目中支持可选链npm install @babel/plugin-proposal-optional-chaining 添加至项目.babel.config.js文件中：&#123; &quot;plugins&quot;: [ &quot;@babel/plugin-proposal-optional-chaining&quot;, ] &#125; 全局函数 export default function useOptionChain(target) &#123; return new Proxy(target, &#123; get: (target, propKey)=&gt; &#123; const proKeyArr = propKey.split(&#39;?.&#39;) return proKeyArr.reduce((a,b)=&gt;a?.[b],target) &#125; &#125;) &#125; &lt;template&gt; &lt;div id=&quot;app&quot;&gt; //保留可选链的写法，更直观的展示，想要拿数组的元素直接取下标的数字即可，不需要 [] &lt;h1 v-if=&quot;useOptionChain(arr)[&#39;0?.obj?.a?.b&#39;]&quot;&gt;数组对象&lt;/h1&gt; &lt;h1 v-if=&quot;useOptionChain(obj)[&#39;arr?.0?.a&#39;]&quot;&gt;对象数组&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //引入函数 import useOptionChain from &quot;@/utils&quot;; export default &#123; name: &quot;App&quot;, components: &#123;&#125;, data() &#123; return &#123; arr: [ &#123; obj: &#123; a: &#123; b: &quot;数组对象&quot;, &#125;, &#125;, &#125;, ], obj: &#123; arr: [ &#123; a: &quot;对象数组&quot;, &#125;, ], &#125;, &#125;; &#125;, methods: &#123; useOptionChain, &#125;, &#125;; &lt;/script&gt;","categories":[{"name":"vue js","slug":"vue-js","permalink":"https://gujinlonghaha.github.io/categories/vue-js/"}],"tags":[{"name":"vue js","slug":"vue-js","permalink":"https://gujinlonghaha.github.io/tags/vue-js/"}],"keywords":[{"name":"vue js","slug":"vue-js","permalink":"https://gujinlonghaha.github.io/categories/vue-js/"}]},{"title":"npx和cli的那些事","slug":"cli","date":"2019-04-20T06:58:53.000Z","updated":"2021-10-19T05:48:05.320Z","comments":true,"path":"2019/04/20/cli/","link":"","permalink":"https://gujinlonghaha.github.io/2019/04/20/cli/","excerpt":"","text":"纸上得来终觉浅 绝知此事要躬行 备注：gjltestcli 是自己写的命令行工具demo 因为我没有全局安装gjltestcli 所以调用不了命令行 我使用npx gjltestcli 能成功是因为npx 临时安装gjltestcli （不会出现在当前目录nodemoudle） 再次使用gjltestcli 可以执行说明npx 是临时安装 没有全局安装所以不能执行 本地安装gjltestcli 因为是本地安装所以调用失效 （可以使用全局安装 -g）不是环境变量 也可以加入环境变量 也可以使用npm link 没有全局安装的可以通过 .\\node_modules.bin\\gjltestcli 执行 因为安装后在这个目录 npx gjltestcli 执行成功是因为 npx 会从nodemoudle 或者本地调用 调用不到就会自己临时安装 不会在你的依赖中安装 上面说明了什么npx的优点：( 当被下载完，则下载的代码会被擦除。 ) 轻松地运行本地命令 无需安装的命令执行 使用不同的 Node.js 版本运行代码 直接从 URL 运行任意代码片段 后面两点可以自行简单测试 最后一点代表不发包（npm publish ）也可以使用 直接从 URL 运行任意代码片段npx 并不限制使用 npm 仓库上发布的软件包。 可以运行位于 GitHub gist 中的代码，例如： npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32 当然，当运行不受控制的代码时，需要格外小心，因为强大的功能带来了巨大的责任。 友情链接 npx","categories":[{"name":"npm cli npx","slug":"npm-cli-npx","permalink":"https://gujinlonghaha.github.io/categories/npm-cli-npx/"}],"tags":[{"name":"npm cli npx","slug":"npm-cli-npx","permalink":"https://gujinlonghaha.github.io/tags/npm-cli-npx/"}],"keywords":[{"name":"npm cli npx","slug":"npm-cli-npx","permalink":"https://gujinlonghaha.github.io/categories/npm-cli-npx/"}]},{"title":"element form 嵌套校验","slug":"element","date":"2019-04-10T10:03:50.000Z","updated":"2021-10-19T05:48:05.348Z","comments":true,"path":"2019/04/10/element/","link":"","permalink":"https://gujinlonghaha.github.io/2019/04/10/element/","excerpt":"","text":"elementUI对表单的校验有自己的方法，要求传入model的必须为一个对象。但如果数据结构比较复杂，对象里面又嵌套对象，该如何校验？ 效果如下：","categories":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/categories/element/"}],"tags":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/tags/element/"}],"keywords":[{"name":"element","slug":"element","permalink":"https://gujinlonghaha.github.io/categories/element/"}]},{"title":"nodecli demo测试","slug":"nodecli","date":"2019-03-20T08:58:53.000Z","updated":"2021-10-19T05:48:05.516Z","comments":true,"path":"2019/03/20/nodecli/","link":"","permalink":"https://gujinlonghaha.github.io/2019/03/20/nodecli/","excerpt":"","text":"整体流程很简单 但是有几个注意事项： npm init -y &#123; &quot;name&quot;: &quot;gjltestcli&quot;, &quot;version&quot;: &quot;1.0.2&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bin&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;ejs&quot;: &quot;^3.1.6&quot;, &quot;inquirer&quot;: &quot;^8.0.0&quot; &#125; &#125; bin 一定要写因为这里写的是命令行程序 dependencies 安装依赖 特别是打包后的依赖需要 npm install 包名 -S （要不然别人安完短依赖） 脚本命令前加 相当于跨平台兼容 让机器识别你的代码 #!/usr/bin/env node 当你频繁测试的时候不需要频繁发布包 先进入你的包 npm link (相当于连接到全局) 直接可以执行测试 发布可能重名 注意版本号每次更新 和名字不要重复 （可以搜索查询） 注册好后登录npm账号。 npm login 依次输入第二步中第一种方法注册的用户名、密码和邮箱。 登录成功后执行npm发布命令。 npm publish demo 就成功了 补充： npm link用来在本地项目和本地npm模块之间建立连接，可以在本地进行模块测试 具体用法： 1. 项目和模块在同一个目录下，可以使用相对路径 npm link ../module 2. 项目和模块不在同一个目录下 cd到模块目录，npm link，进行全局link cd到项目目录，npm link 模块名(package.json中的name) 3. 解除link 解除项目和模块link，项目目录下，npm unlink 模块名 解除模块全局link，模块目录下，npm unlink 模块名","categories":[{"name":"npm cli node","slug":"npm-cli-node","permalink":"https://gujinlonghaha.github.io/categories/npm-cli-node/"}],"tags":[{"name":"npm cli node","slug":"npm-cli-node","permalink":"https://gujinlonghaha.github.io/tags/npm-cli-node/"}],"keywords":[{"name":"npm cli node","slug":"npm-cli-node","permalink":"https://gujinlonghaha.github.io/categories/npm-cli-node/"}]},{"title":"electron 锁定用户版本","slug":"exe","date":"2018-05-07T08:05:14.000Z","updated":"2021-10-19T05:48:05.348Z","comments":true,"path":"2018/05/07/exe/","link":"","permalink":"https://gujinlonghaha.github.io/2018/05/07/exe/","excerpt":"","text":"当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢? 升级用户浏览器 （备份用户数据 书签收藏夹） 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑 数据独立） 使用electron 包装应用 最简单 便捷 前两种就不说了 这里介绍下第三种electron​ 先使用 yarn create electron-app my-app 然后 cd my-app yarn start 接着把这里 const mainWindow = new BrowserWindow(&#123; width: 1920, height: 1080, fullscreen:true,//全屏展示 center: true, // 窗口居中 resizable: true, // 窗口大小是否可改变 maximizable: true, // 窗口是否可以最大化 autoHideMenuBar:true //关掉原始操作 重要 &#125;); // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#39;index.html&#39;)); mainWindow.loadURL(&#39;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#39;) // Open the DevTools. 开发者工具 // mainWindow.webContents.openDevTools(); &#125;; 最后打包 npm run publish 在目录下exe 就生成了 看下效果 好处呢 不言而喻 直接给客户exe 文件简单直接 运行默认全屏 干净整洁 同时内核版本自己控制 不会有其他标签页尤其适合大屏演示","categories":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"tags":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"keywords":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}]},{"title":"你好,朋友！","slug":"hellow","date":"2015-07-13T12:46:25.000Z","updated":"2021-10-19T05:48:05.480Z","comments":true,"path":"2015/07/13/hellow/","link":"","permalink":"https://gujinlonghaha.github.io/2015/07/13/hellow/","excerpt":"","text":"我是GJL,一名前端程序猿 我的博客园地址 查看 个人vscode 插件开发 查看 个人开发quicker 插件地址 自动化部署脚本查看 个人小米自动化抢购脚本 查看 这是一些过往欢快时刻 2020年 2019年 2016年","categories":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/tags/%E8%87%AA%E5%B7%B1/"}],"keywords":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}]}]}