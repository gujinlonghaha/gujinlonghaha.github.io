{"meta":{"title":"一直闭眼看世界博客","subtitle":"一个人的世界","description":"破而后立","author":"gjl","url":"https://gujinlonghaha.github.io"},"pages":[{"title":"about","date":"2015-04-02T05:16:38.000Z","updated":"2021-04-13T06:53:13.053Z","comments":false,"path":"about/index.html","permalink":"https://gujinlonghaha.github.io/about/index.html","excerpt":"","text":"我是一个程序员"}],"posts":[{"title":"公司文档生成利器","slug":"docsify","date":"2021-04-10T08:05:14.000Z","updated":"2021-04-13T06:53:12.877Z","comments":true,"path":"2021/04/10/docsify/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/10/docsify/","excerpt":"","text":"个人使用过hexo 等生成器但是这个是真厉害 因为他不需要把makdown 转化html 的编译过程启动极快 还有几个独特的优势 离线缓存 不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD 支持vue 花了半小时测测试效果如下 真好看 即使是公司的人不会代码也是轻而易举搞定 开始首选全局安装docsify-cli 1npm i docsify-cli -g 初始化初始化会自动生成./docs文件夹 12345docsify init ./docs// 如果不想新建一个文件夹，可以直接进行初始化操作docsify init 建立第一个文档初始化之后目录结构如下 1234|—— docs |—— index.html 入口 |—— README.md 主页 |—— .nojekyll 防止Github忽视下划线开头文件 预览网站执行以下命令，预览网站就在http://localhost:3000网址打开 12cd docsdocsify serve 离线缓存（PWA）1. 创建一个 servieWorker 根目录下创建sw.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* =========================================================== * docsify sw.js * =========================================================== * Copyright 2016 @huxpro * Licensed under Apache 2.0 * Register service worker. * ========================================================== */const RUNTIME = &quot;docsify&quot;;const HOSTNAME_WHITELIST = [self.location.hostname, &quot;fonts.gstatic.com&quot;, &quot;fonts.googleapis.com&quot;, &quot;cdn.jsdelivr.net&quot;];// The Util Function to hack URLs of intercepted requestsconst getFixedUrl = (req) =&gt; &#123; var now = Date.now(); var url = new URL(req.url); // 1. fixed http URL // Just keep syncing with location.protocol // fetch(httpURL) belongs to active mixed content. // And fetch(httpRequest) is not supported yet. url.protocol = self.location.protocol; // 2. add query for caching-busting. // Github Pages served with Cache-Control: max-age=600 // max-age on mutable content is error-prone, with SW life of bugs can even extend. // Until cache mode of Fetch API landed, we have to workaround cache-busting with query string. // Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190 if (url.hostname === self.location.hostname) &#123; url.search += (url.search ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;cache-bust=&quot; + now; &#125; return url.href;&#125;;/** * @Lifecycle Activate * New one activated when old isnt being used. * * waitUntil(): activating ====&gt; activated */self.addEventListener(&quot;activate&quot;, (event) =&gt; &#123; event.waitUntil(self.clients.claim());&#125;);/** * @Functional Fetch * All network requests are being intercepted here. * * void respondWith(Promise&lt;Response&gt; r) */self.addEventListener(&quot;fetch&quot;, (event) =&gt; &#123; // Skip some of cross-origin requests, like those for Google Analytics. if (HOSTNAME_WHITELIST.indexOf(new URL(event.request.url).hostname) &gt; -1) &#123; // Stale-while-revalidate // similar to HTTP&#x27;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale // Upgrade from Jake&#x27;s to Surma&#x27;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1 const cached = caches.match(event.request); const fixedUrl = getFixedUrl(event.request); const fetched = fetch(fixedUrl, &#123; cache: &quot;no-store&quot; &#125;); const fetchedCopy = fetched.then((resp) =&gt; resp.clone()); // Call respondWith() with whatever we get first. // If the fetch fails (e.g disconnected), wait for the cache. // If there’s nothing in cache, wait for the fetch. // If neither yields a response, return offline pages. event.respondWith( Promise.race([fetched.catch((_) =&gt; cached), cached]) .then((resp) =&gt; resp || fetched) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); // Update the cache with the version we fetched (only for ok status) event.waitUntil( Promise.all([fetchedCopy, caches.open(RUNTIME)]) .then(([response, cache]) =&gt; response.ok &amp;&amp; cache.put(event.request, response)) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); &#125;&#125;); 2. 在index.html文件中注册12345&lt;script&gt; if (typeof navigator.serviceWorker !== &quot;undefined&quot;) &#123; navigator.serviceWorker.register(&quot;sw.js&quot;); &#125;&lt;/script&gt;","categories":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/tags/docsify-%E6%96%87%E6%A1%A3/"}],"keywords":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}]},{"title":"简易版exe 打包","slug":"ahk","date":"2021-04-01T07:23:24.000Z","updated":"2021-04-13T06:53:12.861Z","comments":true,"path":"2021/04/01/ahk/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/01/ahk/","excerpt":"","text":"AHK自动热键强大的Windows的终极自动化脚本语言。 键绑定定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！ 什么是自动热键AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等 下载地址 安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器 窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！ 随便编写个脚本如下 12#z::Run https://autohotkey.com ; Win+Z 右键可以编译脚本为exe 如上图 tets.exe 双击启动 按下winow+z 就会自动打开 https://autohotkey.com 网址 其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe 对方得安装ahk 才可以 虽然是exe 可能底层还是需要ahk 的运行环境吧）","categories":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}],"tags":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/tags/ahk-exe/"}],"keywords":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}]},{"title":"安卓应用控件获取方法","slug":"app","date":"2021-03-20T07:23:24.000Z","updated":"2021-04-13T06:53:12.861Z","comments":true,"path":"2021/03/20/app/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/20/app/","excerpt":"","text":"网上随便搜索都是需要java sdk 等安卓adb 工具才能实现要不然就是Appium 手机自动化工具 不懂的人直接头皮发麻 直接劝退 而且有效信息只有一页 差点放弃 之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式） 针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现 特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难 一个知识和工具就是巨大鸿沟1地址 开发者工具简单好用 地址 效果 2手机版quicker 效果如下 从此以后你就可以编写自动化手机脚本无压力了 解放你的双手 自动打卡 自动抢购 自动导航","categories":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/tags/%E5%AE%89%E5%8D%93/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}]},{"title":"Nodejs+Selenium环境搭建以及深坑","slug":"sele","date":"2021-03-09T05:03:22.000Z","updated":"2021-04-13T06:53:13.049Z","comments":true,"path":"2021/03/09/sele/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/09/sele/","excerpt":"","text":"“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”这个sologan 还是够硬的，不过确实如此。 Selenium有以下功能特性: Selenium是一个开源和可移植的Web测试框架。 Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。 它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。 Selenium支持各种操作系统，浏览器和编程语言。如下列表: 编程语言: C# ，Java，Python，PHP，Ruby，Perl和JavaScript 操作系统:Android，iOS，Windows，Linux，Mac，Solaris。 浏览器:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。 它还支持并行测试执行，从而减少了时间并提高了测试效率。 Selenium可以与Ant和Maven等框架集成，用于源代码编译。 Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。 与其他自动化测试工具相比，Selenium需要的资源更少。 WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。 Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。 Selenium命令根据不同的类进行分类，使其更易于理解和实现。 Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。 局限性主要如下： Selenium不支持桌面应用程序的自动化测试。 Selenium需要高技能才能更有效地自动化测试。 由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。 无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。 使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。 它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。 Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。 无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。 与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。 新功能没有人可能少人使用，它们可能会也可能不会正常工作。 Selenium不为测试管理提供任何测试工具集成。 环境搭建1.安装 Nodejs到Nodejs官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。 node -v 2.项目初始化创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令： npm init 3.配置selenium运行环境在上一步相同的命令行下运行以下命令至其运行安装完成。 npm install selenium-webdriver –save 4.安装浏览器驱动 安装Chrome驱动 npm install chromedriver –save 安装Firefox驱动 npm install geckodriver –save 安装IE驱动 npm install iedriver –save 说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：http://www.seleniumhq.org/download/ 可能会碰到问题1）“The ChromeDriver could not be found on the current PATH” 需要将 ChromeDriver 添加到系统的环境变量 Path 中 也是就是你下载的exe 路径 自行更改 我本地还是失败 最终直接把exe 与脚本相同的目录下 运行正常 这个折腾了半天 2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url 解决方案 自己的浏览器和下载版本对应 基本用法一.初始化初始化一个浏览器并打开一个网页，如下： 1var webdriver = require(&#x27;selenium-webdriver&#x27;);var driver = new webdriver.Builder() .forBrowser(&#x27;ie&#x27;) .build();driver.get(&#x27;http://www.baidu.com&#x27;); 二.常用方法1.元素定位 根据id定位 1driver.findElement(By.id(&#x27;ID&#x27;))；//类似于jquery的$(&quot;#id&quot;) 根据className定位 1driver.findElement(By.className(&#x27;Class&#x27;))；//类似于jquery的$(&quot;.class&quot;) 更多定位方式可参考：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html 2.设置元素的值1driver.findElement(By.id(&#x27;ID&#x27;)).sendKeys(&#x27;value&#x27;);//类似于jquery的$(&quot;.id&quot;).val(&quot;value&quot;); 3.清空元素的值1driver.findElement(By.id(&#x27;id&#x27;)).clear(); 4.单击按钮1driver.findElement(By.id(&#x27;id&#x27;)).click(); 5.元素等待有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作： 1var until = webdriver.until;driver.wait(until.elementLocated(By.id(&#x27;id&#x27;), 10000));... 6.程序睡眠睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。 1driver.sleep(500);//毫秒 7.执行JavaScript在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转： 1driver.executeScript(&#x27;location.href=&quot;/xx.html&quot; &#x27;); 或者需要给元素设置值时可以使用： 1driver.executeScript(&#x27;document.getElementById(&quot;id&quot;).value=&quot;value&quot;&#x27;);//$(&quot;#id&quot;).val(&quot;value&quot;); 8.执行JavaScript并获取返回值在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。 1driver.executeScript(&#x27;return $(&quot;#id&quot;).val()&#x27;).then(function(obj)&#123; //obj即为返回值 if(obj&gt;100)&#123; //操作 &#125;else&#123; //其他操作 &#125;&#125;) 9.切换作用域（switchTo） 切换到iframe网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。 1driver.switchTo().frame(driver.findElement(By.id(&quot;iframe-id&quot;))); //iframe-id为iframe元素的id 切换到弹出框有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。 1driver.switchTo().alert().then(function(alert) &#123; //检测到弹出框时执行 //关闭alert return alert.dismiss();&#125;,function()&#123; //没有检测到弹出框时执行&#125;); 切换回主页面 1driver.switchTo().defaultContent(); 10.网页最大化（全屏）1driver.manage().window().maximize(); 11.网页截图(定位)网页截图看上去很简单，就一行代码如下： 1driver.takeScreenshot()； 截图后的结果为base64格式，可自行处理。类似这样： 1driver.takeScreenshot().then(function(d)&#123; //此处d即为截图结果base64字符串，可在此自行处理&#125;); 但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下： 1driver.findElement(By.className(&#x27;yanzheng&#x27;)).then(function(obj)&#123; obj.getSize().then(function(size)&#123; obj.getLocation().then(function(loc)&#123; driver.takeScreenshot().then(function(d)&#123; var data=&#123; d:d, width:size.width, height:size.height, x:loc.x, y:loc.y &#125;; //此处省略以下两步 //1.提交data信息到服务器处理图片 //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置x,y以及长宽width,height截取相应的图片 &#125;) &#125; &#125;&#125;) 12.退出程序（关闭网页）1driver.quit(); 更多详细文档可参考官方文档：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/ 下面是不错的资源中文文档 易百教程","categories":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}],"tags":[{"name":"Nodejs Selenium","slug":"Nodejs-Selenium","permalink":"https://gujinlonghaha.github.io/tags/Nodejs-Selenium/"}],"keywords":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}]},{"title":"文档中操作组件和展示组件源码","slug":"doc","date":"2021-02-01T07:23:24.000Z","updated":"2021-04-13T06:53:12.877Z","comments":true,"path":"2021/02/01/doc/","link":"","permalink":"https://gujinlonghaha.github.io/2021/02/01/doc/","excerpt":"","text":"什么是组件示例文档？当你使用 Vue、React 或者其他语言编写了一个组件库，如 Element UI、Ant Design Vue 或是基于它们开发的业务封装库，都需要使用文档来支撑，而使用文档必然会包含代码与示例，这部分就是组件示例文档。 举个例子，Element 文档，其中就包含了多份示例代码，假设我们现在完成了组件开发，需要使用 Vuepress 写一份和它一样的使用文档，该怎么做呢？ ​ vuepress 官方解决方案是这样 导入代码段 beta你可以通过下述的语法导入已经存在的文件中的代码段： 1&lt;&lt;&lt; @/filepath 它也支持 行高亮： 1&lt;&lt;&lt; @/filepath&#123;highlightLines&#125; 输入 1&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet.js&#123;2&#125; 输出 123export default function () &#123; // ..&#125; 注意 由于代码段的导入将在 webpack 编译之前执行，因此你无法使用 webpack 中的路径别名，此处的 @ 默认值是 process.cwd()。 为了只导入对应部分的代码，你也可运用 VS Code region (opens new window)。你可以在文件路径后方的 # 紧接着提供一个自定义的区域名称（预设为 snippet ） 输入 1&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet-with-region.js#snippet&#123;1&#125; 代码文件 1234567891011121314151617181920212223242526272829303132// #region snippetfunction foo () &#123; return (&#123; dest: &#x27;../../vuepress&#x27;, locales: &#123; &#x27;/&#x27;: &#123; lang: &#x27;en-US&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue-powered Static Site Generator&#x27; &#125;, &#x27;/zh/&#x27;: &#123; lang: &#x27;zh-CN&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue 驱动的静态网站生成器&#x27; &#125; &#125;, head: [ [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: `/logo.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;manifest&#x27;, href: &#x27;/manifest.json&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;theme-color&#x27;, content: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-capable&#x27;, content: &#x27;yes&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-status-bar-style&#x27;, content: &#x27;black&#x27; &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;apple-touch-icon&#x27;, href: `/icons/apple-touch-icon-152x152.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;mask-icon&#x27;, href: &#x27;/icons/safari-pinned-tab.svg&#x27;, color: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileImage&#x27;, content: &#x27;/icons/msapplication-icon-144x144.png&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileColor&#x27;, content: &#x27;#000000&#x27; &#125;] ] &#125;)&#125;// #endregion snippetexport default foo 输出 12345678910111213141516171819202122232425262728function foo () &#123; return (&#123; dest: &#x27;../../vuepress&#x27;, locales: &#123; &#x27;/&#x27;: &#123; lang: &#x27;en-US&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue-powered Static Site Generator&#x27; &#125;, &#x27;/zh/&#x27;: &#123; lang: &#x27;zh-CN&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue 驱动的静态网站生成器&#x27; &#125; &#125;, head: [ [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: `/logo.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;manifest&#x27;, href: &#x27;/manifest.json&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;theme-color&#x27;, content: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-capable&#x27;, content: &#x27;yes&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-status-bar-style&#x27;, content: &#x27;black&#x27; &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;apple-touch-icon&#x27;, href: `/icons/apple-touch-icon-152x152.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;mask-icon&#x27;, href: &#x27;/icons/safari-pinned-tab.svg&#x27;, color: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileImage&#x27;, content: &#x27;/icons/msapplication-icon-144x144.png&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileColor&#x27;, content: &#x27;#000000&#x27; &#125;] ] &#125;)&#125; 如果使用组件的话想到那个于引入一次组件展示一次 源码展示一次 写两遍 有没有一次的方法呢？（意外发现） 工具总是提高人们效率的法宝之一 使用 npm 安装它： 1npm i vuepress-plugin-demo-container --save-dev 如果你的网络环境不佳，推荐使用 cnpm。 #配置插件打开 .vuepress/config.js 文件，然后在合适的位置引用插件： 12345module.exports = &#123; ... plugins: [&#x27;demo-container&#x27;] ...&#125; 在 Markdown 文件中编写以下代码： 12345678910111213141516171819202122232425::: demo 此处放置代码示例的描述信息，支持 `Markdown` 语法，**描述信息只支持单行**```html&lt;template&gt; &lt;div class=&quot;red-center-text&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;Input something...&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: &#x27;Hello Vue&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.red-center-text &#123; color: #ff7875; text-align: center;&#125;&lt;/style&gt;` ` ` &lt;= 删除左侧空格::: 运行效果如下 个人demo 地址","categories":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/categories/vuepress-plugin-demo-container/"}],"tags":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/tags/vuepress-plugin-demo-container/"}],"keywords":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/categories/vuepress-plugin-demo-container/"}]},{"title":"文档中代码编辑加预览","slug":"code","date":"2020-10-13T06:27:43.000Z","updated":"2021-04-13T06:53:12.877Z","comments":true,"path":"2020/10/13/code/","link":"","permalink":"https://gujinlonghaha.github.io/2020/10/13/code/","excerpt":"","text":"好文档是什么呢？（其实有人已经回答）我一直在思考 🤔 怎么的 Vue 文档交互才是好的 👍, 后来得出的结论是: 能看代码 能看效果 能在线编辑代码, 并实时预览结果 能做到前 2 点的 Vue 组件不少, 但能做到第 3 点, 并对文档的 DEMO 编写做优化处理的并不多 找了好久功夫不负有心人 还是有大神造就出了轮子 轮子总是能效率提升百倍 以 docsify 为例子 （v-charts 展示源码同时 可预览 编辑 就是用的这个做的文档 虽然线上目前出故障了到是 ） 地址 原理使用vuep 这是个好东西 随后又找到另一个类似网站 ve-charts 有源码 有demo 源码编辑 demo 联动 以上都是vuep 技术实现 还没有没别的方式呢vue-run-sfc 你值得拥有🍎 使用12345678910111213141516171819202122&lt;script&gt; window.$docsify = &#123; // 配置, 更多属性解释请往下面翻 ↓ run: &#123; themeColor: &#x27;green&#x27;, themeBorderColor: &#x27;#eee&#x27;, reverse: true, // ... &#125; &#125;&lt;/script&gt;&lt;!-- 引入Vue --&gt;&lt;script src=&quot;//unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入 vue-run-sfc --&gt;&lt;script src=&quot;//unpkg.com/vue-run-sfc&quot;&gt;&lt;/script&gt;&lt;!-- 引入 docsify-plugin-run --&gt;&lt;script src=&quot;https://unpkg.com/docsify-plugin-run/src/index.js&quot;&gt;&lt;/script&gt;&lt;!-- 指定版本 --&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/docsify-plugin-run@xx.xx.xx/src/index.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- docsify --&gt;&lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; 🍊示例全局配置: 运行 element-ui123456789101112131415161718&lt;script&gt; window.$docsify = &#123; run: &#123; jsLabs: [&#x27;https://unpkg.com/element-ui/lib/index.js&#x27;], cssLabs: [&#x27;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#x27;], &#125; &#125;&lt;/script&gt;``html run&lt;template&gt; &lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt; &lt;/el-tabs&gt;&lt;/template&gt;`` &lt;== 这里和上面的 ` 有 3 个 最终效果我放在了码云地址简单测试效果如图","categories":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}],"tags":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/tags/docsify-vuepres-code-run/"}],"keywords":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}]},{"title":"小试尤大大vuepress vue 文档神器","slug":"vuepress","date":"2020-08-01T03:15:12.000Z","updated":"2021-04-13T06:53:13.049Z","comments":true,"path":"2020/08/01/vuepress/","link":"","permalink":"https://gujinlonghaha.github.io/2020/08/01/vuepress/","excerpt":"","text":"没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)简洁至上以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 Vue 驱动享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。 高性能VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。 #为什么不是…?#NuxtVuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。 #Docsify / Docute这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！ #HexoHexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。 #GitBook我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。 个人小试如下 很快就搭建了架子 部署在了gitee 上 配置如下 注意配置这才会展示 官方文档有介绍 和部署域名后缀一样就ok了 测试效果如下 彩蛋codepen 如何引入到文档显得高大上？？？如下 See the Pen QWdaRMR by gujinlong (@gujinlonghaha) on CodePen. 步骤先保存 然后获取iframe 最后直接放在md 源文件","categories":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}],"tags":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/tags/vuepress/"}],"keywords":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}]},{"title":"pupeteer自动化加版本测试","slug":"pup","date":"2020-04-08T02:57:47.000Z","updated":"2021-04-13T06:53:13.045Z","comments":true,"path":"2020/04/08/pup/","link":"","permalink":"https://gujinlonghaha.github.io/2020/04/08/pup/","excerpt":"","text":"多版本谷歌测试如何进行没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决 puppeteerjs你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例： 生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展。 他其中有个模块 那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的 地址 需要fq 是第二个箭头也就是分支切换出来的版本号码 那他支持哪些版本呢 地址 淘宝给出了镜像地址 下面号码拿来直接用 现在谷歌浏览器都是下载安装器然后在线安装有没离线包 福利 自己写的部分常用脚本 以防忘记 1234567891011121314151617181920212223242526272829303132333435363738394041const puppeteer = require(&#x27;puppeteer&#x27;);let operte=async(t) =&gt; &#123; // 开启 browser const browserFetcher = puppeteer.createBrowserFetcher(); const revisionInfo = await browserFetcher.download(&#x27;533271&#x27;); //指定版本 const vesion= await browserFetcher.localRevisions() console.log(vesion) let browser = await puppeteer.launch(&#123; executablePath: revisionInfo.executablePath, headless: false, defaultViewport: &#123; height: 1080, width: 1920 &#125; &#125;); // 新增分页 console.log(browser) let page = await browser.newPage(); // 到自己的网站 await page.goto(`$&#123;t&#125;`); // 等待订阅按钮出现 // await page.waitForSelector(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // page.type(&#x27;#mytextarea&#x27;, &#x27;Hello&#x27;, &#123; delay: 100 &#125;); // 立即输入 // page.type(&#x27;#mytextarea&#x27;, &#x27;World&#x27;, &#123; delay: 100 &#125;); // 输入变慢，像一个用户 // // 点击订阅按钮 // await page.click(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // 关闭标签页 // page.close() // 关闭浏览器 // await browser.close();&#125;let arr=[ &#x27;https://www.baidu.com/&#x27;, // &#x27;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#x27;,]arr.forEach(t =&gt; &#123; operte(t)&#125;);","categories":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}],"tags":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/tags/pupeteer/"}],"keywords":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}]},{"title":"electron 锁定用户版本","slug":"exe","date":"2018-05-07T08:05:14.000Z","updated":"2021-04-13T06:53:12.877Z","comments":true,"path":"2018/05/07/exe/","link":"","permalink":"https://gujinlonghaha.github.io/2018/05/07/exe/","excerpt":"","text":"当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢? 升级用户浏览器 （备份用户数据 书签收藏夹） 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑 数据独立） 使用electron 包装应用 最简单 便捷 前两种就不说了 这里介绍下第三种electron​ 先使用 1yarn create electron-app my-app 然后 12cd my-appyarn start 接着把这里 1234567891011121314151617 const mainWindow = new BrowserWindow(&#123; width: 1920, height: 1080, fullscreen:true,//全屏展示 center: true, // 窗口居中 resizable: true, // 窗口大小是否可改变 maximizable: true, // 窗口是否可以最大化 autoHideMenuBar:true //关掉原始操作 重要 &#125;); // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;)); mainWindow.loadURL(&#x27;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#x27;) // Open the DevTools. 开发者工具 // mainWindow.webContents.openDevTools();&#125;; 最后打包 1npm run publish 在目录下exe 就生成了 看下效果 好处呢 不言而喻 直接给客户exe 文件简单直接 运行默认全屏 干净整洁 同时内核版本自己控制 不会有其他标签页尤其适合大屏演示","categories":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"tags":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"keywords":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}]},{"title":"你好,朋友！","slug":"hellow","date":"2015-07-13T12:46:25.000Z","updated":"2021-04-13T06:53:13.013Z","comments":true,"path":"2015/07/13/hellow/","link":"","permalink":"https://gujinlonghaha.github.io/2015/07/13/hellow/","excerpt":"","text":"我是GJL,一名前端程序猿 我的博客园地址 查看 个人vscode 插件开发 查看 个人开发quicker 插件地址 自动化部署脚本查看 个人小米自动化抢购脚本 查看 这是一些过往欢快时刻 2020年 2019年 2016年","categories":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/tags/%E8%87%AA%E5%B7%B1/"}],"keywords":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}]}]}