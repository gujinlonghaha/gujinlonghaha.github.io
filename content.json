{"meta":{"title":"一直闭眼看世界博客","subtitle":"一个人的世界","description":"破而后立","author":"gjl","url":"https://gujinlonghaha.github.io"},"pages":[{"title":"about","date":"2015-04-02T05:16:38.000Z","updated":"2021-04-14T08:38:35.773Z","comments":false,"path":"about/index.html","permalink":"https://gujinlonghaha.github.io/about/index.html","excerpt":"","text":"我是程序员"}],"posts":[{"title":"帮运维快速切换内外网(二网双选一) 另附bat 转exe","slug":"bat","date":"2021-04-12T07:39:41.000Z","updated":"2021-04-14T08:38:35.581Z","comments":true,"path":"2021/04/12/bat/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/12/bat/","excerpt":"","text":"运维同事因为客户环境而发愁 因为客户(政府 电信等)环境是内网， 平时通信查问题是外网 来回切换网线 切换网卡 我想在网上检索个工具应该能解决吧？ 结果却不尽人意 没有合适的工具 不是根本不起作用就是只能切换ip 难道没有办法了吗？ 最终自己编写bat 解决 完美撒花汉字 专网 WLAN 分别是是网卡对应名称 记得修改 12345678910111213141516171819202122232425262728293031@echo offtitle gjl切换网络脚本:stillAnswerset /p switch=1切换为专网，2切换为WLAN，3切换为双网卡，4退出：if %switch% == 1 (netsh interface set interface name=&quot;专网&quot; admin=enablednetsh interface set interface name=&quot;WLAN&quot; admin=disabledecho -------------------当前网络为专网---------------------goto stillAnswer)else if %switch% == 2 (netsh interface set interface name=&quot;专网&quot; admin=disablednetsh interface set interface name=&quot;WLAN&quot; admin=enabledecho -------------------当前网络为WLAN---------------------goto stillAnswer)else if %switch% == 3 (netsh interface set interface name=&quot;专网&quot; admin=enablednetsh interface set interface name=&quot;WLAN&quot; admin=enabledecho -------------------双网卡同时启动---------------------goto stillAnswer)else if %switch% == 4 (exit)::netsh interface set interface name=&quot;WLAN&quot; admin=disabled::netsh interface set interface name=&quot;专网&quot; admin=enabled::netsh interface set interface name=&quot;WLAN&quot; admin=enabled::netsh interface set interface name=&quot;专网&quot; admin=disabled 新建bat文件保存后管理员身份运行 效果如下： 这样还不够完美 我有用bat 转为exe 如何bat转exe? 工具我上传了 下载:https://wws.lanzous.com/iVXwko1hiqb 密码:9qtj 我也发布到了quicker","categories":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/categories/%E7%BD%91%E5%8D%A1-bat/"}],"tags":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/tags/%E7%BD%91%E5%8D%A1-bat/"}],"keywords":[{"name":"网卡 bat","slug":"网卡-bat","permalink":"https://gujinlonghaha.github.io/categories/%E7%BD%91%E5%8D%A1-bat/"}]},{"title":"白嫖域名体验之旅","slug":"yuming","date":"2021-04-11T10:03:50.000Z","updated":"2021-04-14T08:38:35.765Z","comments":true,"path":"2021/04/11/yuming/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/11/yuming/","excerpt":"","text":"vercel传送门 登陆完导入仓库就完事了 效果地址 netlify 效果地址 说白了个gitee 差不多 只不过是国外的罢了 都是github 登录 然如导入仓库 next 毕竟多了两个选择彩蛋jsorg 如果你的项目足够优秀可以使用jsorg","categories":[{"name":"netlify vercel","slug":"netlify-vercel","permalink":"https://gujinlonghaha.github.io/categories/netlify-vercel/"}],"tags":[{"name":"域名  测试  netlify vercel","slug":"域名-测试-netlify-vercel","permalink":"https://gujinlonghaha.github.io/tags/%E5%9F%9F%E5%90%8D-%E6%B5%8B%E8%AF%95-netlify-vercel/"}],"keywords":[{"name":"netlify vercel","slug":"netlify-vercel","permalink":"https://gujinlonghaha.github.io/categories/netlify-vercel/"}]},{"title":"搭建自己的图床","slug":"imgurl","date":"2021-04-09T08:53:55.000Z","updated":"2021-04-14T08:38:35.753Z","comments":true,"path":"2021/04/09/imgurl/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/09/imgurl/","excerpt":"","text":"1. 什么是图床简单来说就是存储图片的服务器，将图片上传至该服务器中后，可以在公网中通过指定的URL获取此图片。 2. 图床的意义 减轻服务器带宽压力：图片资源可以由单独的服务器来存储、访问，例如腾讯云的COS、阿里云的OSS、七牛云等产品。 提供CDN加速：可以通过CDN的就近访问原则加快图片的访问速度。 第三条也就是最重要的一条，就是方便写文章。 3. 搭建图床 这里采用gitee作为图片仓库有两点原因，第一点是因为它是免费的，省去了自己维护服务器的费用。第二是因为它是国内的一个网站，所以相比与github来说，访问速度会更快一些。（后来试了一下github感觉也挺快的，差别并不明显，应该是使用了jsdelivr CDN的缘故） 码云图床限制如下 功能特性 社区版 企业版 使用场景 开源项目 个人私有仓库 免费版 协作开发 总计协作人数 不限 ≦ 5 人 ≦ 5 人 20 ~ 100 人+ 仓库总容量 5G 5G 5G 20 ~ 100G 单仓库大小 1G 500M 500M 1 ~ 3G 单文件大小 50M 50M 50M 100 ~ 300M 附件总容量 3G 3G 3G 10 ~ 50G + 创建图片仓库 大部分是用 传送门 我用的是utool的图床 从此你就有了自己的图床了","categories":[],"tags":[{"name":"图床 图片 gitee","slug":"图床-图片-gitee","permalink":"https://gujinlonghaha.github.io/tags/%E5%9B%BE%E5%BA%8A-%E5%9B%BE%E7%89%87-gitee/"}],"keywords":[]},{"title":"多端同步验证方案汇总","slug":"chormeText","date":"2021-04-06T07:13:31.000Z","updated":"2021-04-14T08:38:35.585Z","comments":true,"path":"2021/04/06/chormeText/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/06/chormeText/","excerpt":"","text":"BrowserShots 地址： http://browsershots.org 作为首批跨浏览器测试网站之一，支持多种浏览器，包括一些旧浏览器，如 Lynx、Konqueror 和 Seamonkey。 它会生成屏幕截图，显示你的网站在不同浏览器中的渲染表现，唯一的缺点是需要在线使用该工具。 Browser Sandbox 地址： https://turbo.net/browsers 它是一款可运行在桌面和平板上的应用程序，可以像运行原生浏览器那样运行多种浏览器。 它支持的浏览器种类很多，包括旧版本的 IE、Canary 及开发版的 IE。 MultiBrowser 地址： https://www.multibrowser.com 一款桌面应用程序，支持 IE7 到 IE11、Edge、Firefox 和 Chrome。你可以用它来测试网站的桌面版本和移动版本，可以进行手动测试或自动化测试。 LambdaTest 地址： https://www.lambdatest.com 一个在线服务，可用来进行不同平台的跨浏览器测试。例如，你可以测试网站在 Windows、Linux、macOS 上的不同浏览器（Firefox 或 Chrome）中的表现。 它还提供了一个集成调试工具、地理位置工具，可以用来测试本地站点。 Experitest Cross Browser Testing 地址： https://experitest.com/cross-browser-testing 这个工具可以用来测试网站在不同环境下的兼容性和性能。它还可以与其他服务集成起来，比如 Github、Gitlab、Jenkins、TravisCI 和 CircleCI 等，把网站的部署流程流水线化。 BrowserStack 地址： https://www.browserstack.com 跨浏览器测试领域响当当的一款工具，被一些大型开源项目采用，比如 jQuery 和 React.js。BrowserStack 列出了数百种浏览器、设备和测试策略，确保你的网站可以在尽可能多的环境中正常运行。 SauceLabs 地址： https://saucelabs.com SauceLabs 为各种规模的网站提供了完整的浏览器兼容性测试工具，不管是企业级的、中小型公司还是开源项目。 CrossBrowserTesting 地址： https://crossbrowsertesting.com 使用这个工具，可以不写代码进行自动化浏览器兼容性测试，可以测试线上或本地站点，还可以截取屏幕快照和视频。 TestingBot 地址： https://testingbot.com TestingBot 为网站和原生移动 App 提供了完整的测试策略，可以在真实的 iOS 或 Android 设备上运行测试。 Browserling 地址： https://www.browserling.com 如果你想要在 IE 上进行快速测试，BrowserLing 或许是个不错的选择。 你可以用它进行简单的交互式测试，支持一些旧浏览器，比如 IE 10、IE 11 和 Safari 4、Safari 5。 Comparium 地址： https://comparium.app Comparium 提供了一个免费的工具，可以截取不同环境下的屏幕快照，并进行比对。 Puppeteer 地址： https://github.com/puppeteer/puppeteer Puppeteer 是一个 Node.js 模块，提供了与 Chrome 和 Firefox 交互的 API。 你可以用它提供的 API 来截取屏幕快照、生成 PDF、进行自动化交互式测试（比如自动填写表单、键盘输入），整体上可以进行自动化网站测试。 Playwright 地址： https://github.com/microsoft/playwright Playwright 是微软设计的一个项目，用于执行自动化浏览器测试。它提供了一个简单的 API。除了可以模拟用户交互，还可以拦截网络请求、模拟移动设备、支持地理位置数据和权限控制。 Playwright 支持基于 Chromium 的浏览器、Firefox 和 Webkit（比如 Safari）。 Nightwatch.js 地址： https://nightwatchjs.org NightWatch.js 是一个用于进行端到端侧二十的 Node.js 模块。它提供了简单易用的 API，可用它检查某个元素是否包含了特定的文本或是否可见，甚至是可以用来测试 CSS 类、CSS ID 和属性。 Cypress 地址： https://www.cypress.io Cypress 是一个端到端测试套件，可用来测试和调试现代 Web 应用程序。 它在执行测试的同时还能记录下每一个测试的状态。你可以回溯每一个状态，并比较状态之间都发生了什么变化，这让 Web 应用程序的调试变得很直观。 WebDriverIO 地址： https://webdriver.io 这是一款 Node.js 自动化测试框架，支持很多 JavaScript 库，比如 React.js、Vue 和 Angular。 因为它是基于 W3C WebDriver 和 Chrome DevTools 的，所以可以在本地运行，也可以在云端运行，就像 SauceLab、BrowserStack 和 TestingBot 那样。 Selenium 地址： https://www.selenium.dev Selenium 是一款浏览器自动化测试工具。实际上，它并没有提供现成的测试框架，但可以通过扩展来实现。 很多测试框架、App 或服务，包括上述的一些工具都是基于 Selenium 的。","categories":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/categories/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/tags/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"keywords":[{"name":"展示  预览  浏览器","slug":"展示-预览-浏览器","permalink":"https://gujinlonghaha.github.io/categories/%E5%B1%95%E7%A4%BA-%E9%A2%84%E8%A7%88-%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"公司文档生成利器","slug":"docsify","date":"2021-04-04T08:05:14.000Z","updated":"2021-04-14T08:38:35.593Z","comments":true,"path":"2021/04/04/docsify/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/04/docsify/","excerpt":"","text":"个人使用过hexo 等生成器但是这个是真厉害 因为他不需要把makdown 转化html 的编译过程启动极快 还有几个独特的优势 离线缓存 不需要编译直接部署 可以使用gitee 搭配使用 不需要CL/CD 支持vue 花了半小时测测试效果如下 真好看 即使是公司的人不会代码也是轻而易举搞定 开始首选全局安装docsify-cli 1npm i docsify-cli -g 初始化初始化会自动生成./docs文件夹 12345docsify init ./docs// 如果不想新建一个文件夹，可以直接进行初始化操作docsify init 建立第一个文档初始化之后目录结构如下 1234|—— docs |—— index.html 入口 |—— README.md 主页 |—— .nojekyll 防止Github忽视下划线开头文件 预览网站执行以下命令，预览网站就在http://localhost:3000网址打开 12cd docsdocsify serve 离线缓存（PWA）1. 创建一个 servieWorker 根目录下创建sw.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* =========================================================== * docsify sw.js * =========================================================== * Copyright 2016 @huxpro * Licensed under Apache 2.0 * Register service worker. * ========================================================== */const RUNTIME = &quot;docsify&quot;;const HOSTNAME_WHITELIST = [self.location.hostname, &quot;fonts.gstatic.com&quot;, &quot;fonts.googleapis.com&quot;, &quot;cdn.jsdelivr.net&quot;];// The Util Function to hack URLs of intercepted requestsconst getFixedUrl = (req) =&gt; &#123; var now = Date.now(); var url = new URL(req.url); // 1. fixed http URL // Just keep syncing with location.protocol // fetch(httpURL) belongs to active mixed content. // And fetch(httpRequest) is not supported yet. url.protocol = self.location.protocol; // 2. add query for caching-busting. // Github Pages served with Cache-Control: max-age=600 // max-age on mutable content is error-prone, with SW life of bugs can even extend. // Until cache mode of Fetch API landed, we have to workaround cache-busting with query string. // Cache-Control-Bug: https://bugs.chromium.org/p/chromium/issues/detail?id=453190 if (url.hostname === self.location.hostname) &#123; url.search += (url.search ? &quot;&amp;&quot; : &quot;?&quot;) + &quot;cache-bust=&quot; + now; &#125; return url.href;&#125;;/** * @Lifecycle Activate * New one activated when old isnt being used. * * waitUntil(): activating ====&gt; activated */self.addEventListener(&quot;activate&quot;, (event) =&gt; &#123; event.waitUntil(self.clients.claim());&#125;);/** * @Functional Fetch * All network requests are being intercepted here. * * void respondWith(Promise&lt;Response&gt; r) */self.addEventListener(&quot;fetch&quot;, (event) =&gt; &#123; // Skip some of cross-origin requests, like those for Google Analytics. if (HOSTNAME_WHITELIST.indexOf(new URL(event.request.url).hostname) &gt; -1) &#123; // Stale-while-revalidate // similar to HTTP&#x27;s stale-while-revalidate: https://www.mnot.net/blog/2007/12/12/stale // Upgrade from Jake&#x27;s to Surma&#x27;s: https://gist.github.com/surma/eb441223daaedf880801ad80006389f1 const cached = caches.match(event.request); const fixedUrl = getFixedUrl(event.request); const fetched = fetch(fixedUrl, &#123; cache: &quot;no-store&quot; &#125;); const fetchedCopy = fetched.then((resp) =&gt; resp.clone()); // Call respondWith() with whatever we get first. // If the fetch fails (e.g disconnected), wait for the cache. // If there’s nothing in cache, wait for the fetch. // If neither yields a response, return offline pages. event.respondWith( Promise.race([fetched.catch((_) =&gt; cached), cached]) .then((resp) =&gt; resp || fetched) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); // Update the cache with the version we fetched (only for ok status) event.waitUntil( Promise.all([fetchedCopy, caches.open(RUNTIME)]) .then(([response, cache]) =&gt; response.ok &amp;&amp; cache.put(event.request, response)) .catch((_) =&gt; &#123; /* eat any errors */ &#125;) ); &#125;&#125;); 2. 在index.html文件中注册12345&lt;script&gt; if (typeof navigator.serviceWorker !== &quot;undefined&quot;) &#123; navigator.serviceWorker.register(&quot;sw.js&quot;); &#125;&lt;/script&gt;","categories":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/tags/docsify-%E6%96%87%E6%A1%A3/"}],"keywords":[{"name":"docsify  文档","slug":"docsify-文档","permalink":"https://gujinlonghaha.github.io/categories/docsify-%E6%96%87%E6%A1%A3/"}]},{"title":"简易版exe 打包","slug":"ahk","date":"2021-04-01T07:23:24.000Z","updated":"2021-04-14T08:38:35.565Z","comments":true,"path":"2021/04/01/ahk/","link":"","permalink":"https://gujinlonghaha.github.io/2021/04/01/ahk/","excerpt":"","text":"AHK自动热键强大的Windows的终极自动化脚本语言。 键绑定定义鼠标和键盘的热键，重新映射键或按钮以及类似自动更正的替换。创建简单的热键从未如此简单。您只需几行或更少的时间就可以完成！ 什么是自动热键AutoHotkey是Windows的一种免费的开放源代码脚本语言，它使用户可以轻松地为各种任务创建小型到复杂的脚本，例如：表格填充，自动单击，宏等 下载地址 安装完之后 目录有个这个脚本 这是非常有用的脚本 类似手机端的控件选择器 窗口的信息会被抓取到我经常使用 （经纬度 标题等 自动化脚本经常会用到）很赞！！！ 随便编写个脚本如下 12#z::Run https://autohotkey.com ; Win+Z 右键可以编译脚本为exe 如上图 tets.exe 双击启动 按下winow+z 就会自动打开 https://autohotkey.com 网址 其实功能很多 自己可以折腾着玩 很多软件都是ahk 开发的 （如果发给别人exe 对方得安装ahk 才可以 虽然是exe 可能底层还是需要ahk 的运行环境吧）","categories":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}],"tags":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/tags/ahk-exe/"}],"keywords":[{"name":"ahk exe","slug":"ahk-exe","permalink":"https://gujinlonghaha.github.io/categories/ahk-exe/"}]},{"title":"安卓应用控件获取方法","slug":"app","date":"2021-03-20T07:23:24.000Z","updated":"2021-04-14T08:38:35.565Z","comments":true,"path":"2021/03/20/app/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/20/app/","excerpt":"","text":"网上随便搜索都是需要java sdk 等安卓adb 工具才能实现要不然就是Appium 手机自动化工具 不懂的人直接头皮发麻 直接劝退 而且有效信息只有一页 差点放弃 之前我购买了auto.js 手机付费版本 里面大部分都是基于控件操作 最终实现了手机自动飞书打卡功能 （有的直接通过坐标实现 不是最好方式） 针对前端活着吧小白难道真的没办法实现了吗？这个一度困扰了我几天后来才发现真有小众的东西可以实现 特此记录 （踏破铁鞋无匿处） 真是难者不会 会者不难 一个知识和工具就是巨大鸿沟1地址 开发者工具简单好用 地址 效果 2手机版quicker 效果如下 从此以后你就可以编写自动化手机脚本无压力了 解放你的双手 自动打卡 自动抢购 自动导航","categories":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/tags/%E5%AE%89%E5%8D%93/"}],"keywords":[{"name":"安卓","slug":"安卓","permalink":"https://gujinlonghaha.github.io/categories/%E5%AE%89%E5%8D%93/"}]},{"title":"Nodejs+Selenium环境搭建以及深坑","slug":"sele","date":"2021-03-09T05:03:22.000Z","updated":"2021-04-14T08:38:35.757Z","comments":true,"path":"2021/03/09/sele/","link":"","permalink":"https://gujinlonghaha.github.io/2021/03/09/sele/","excerpt":"","text":"“Selenium测试直接运行在浏览器中，就像真正的用户在操作一样”这个sologan 还是够硬的，不过确实如此。 Selenium有以下功能特性: Selenium是一个开源和可移植的Web测试框架。 Selenium IDE为创作测试提供了回放和录制功能，而无需学习测试脚本语言。 它可以被视为领先的基于云的测试平台，可帮助测试人员记录他们的操作并将其导出为可重复使用的脚本，并具有易于理解且易于使用的界面。 Selenium支持各种操作系统，浏览器和编程语言。如下列表: 编程语言: C# ，Java，Python，PHP，Ruby，Perl和JavaScript 操作系统:Android，iOS，Windows，Linux，Mac，Solaris。 浏览器:谷歌浏览器，Mozilla Firefox，Internet Explorer，Edge，Opera，Safari等。 它还支持并行测试执行，从而减少了时间并提高了测试效率。 Selenium可以与Ant和Maven等框架集成，用于源代码编译。 Selenium还可以与TestNG等测试框架集成，以进行应用程序测试和生成报告。 与其他自动化测试工具相比，Selenium需要的资源更少。 WebDriver API已经尝试集于Selenium中，这是对Selenium进行的最重要的修改之一。 Selenium Web驱动程序不需要服务器安装，测试脚本直接与浏览器交互。 Selenium命令根据不同的类进行分类，使其更易于理解和实现。 Selenium Remote Control(RC)与WebDriver API一起被称为Selenium 2.0。 此版本旨在支持充满活力的网页和Ajax。 局限性主要如下： Selenium不支持桌面应用程序的自动化测试。 Selenium需要高技能才能更有效地自动化测试。 由于Selenium是开源软件，因此您必须依靠社区论坛来解决技术问题。 无法使用Selenium对Web服务(如SOAP或REST)执行自动化测试。 使用者应该至少知道或熟悉一种受支持的编程语言，以便在Selenium WebDriver中创建测试脚本。 它没有像UTF/QTP这样的内置对象存储库来维护集中位置的对象/元素。 但是，可以使用Page Object Model克服此限制。 Selenium没有任何内置的报告功能; 必须依赖JUnit和TestNG等插件来获取测试报告。 无法对图像执行测试。需要将Selenium与Sikuli集成以进行基于图像的测试。 与UFT，RFT，Silk测试等供应商工具相比，在Selenium中创建测试环境需要更多时间。 新功能没有人可能少人使用，它们可能会也可能不会正常工作。 Selenium不为测试管理提供任何测试工具集成。 环境搭建1.安装 Nodejs到Nodejs官方下载地址下载最新稳定版本Nodejs后安装。安装成功后在命令行模式使用以下命令查看是否成功。成功后会显示相应的版本信息。 node -v 2.项目初始化创建一个文件夹（用户存放项目文件）后命令行模式进入到该文件夹下执行命令： npm init 3.配置selenium运行环境在上一步相同的命令行下运行以下命令至其运行安装完成。 npm install selenium-webdriver –save 4.安装浏览器驱动 安装Chrome驱动 npm install chromedriver –save 安装Firefox驱动 npm install geckodriver –save 安装IE驱动 npm install iedriver –save 说明：出现安装驱动后运行脚本提示驱动不正常之类的问题时可自行下载驱动放到与脚本相同的目录下试试。驱动下载地址：http://www.seleniumhq.org/download/ 可能会碰到问题1）“The ChromeDriver could not be found on the current PATH” 需要将 ChromeDriver 添加到系统的环境变量 Path 中 也是就是你下载的exe 路径 自行更改 我本地还是失败 最终直接把exe 与脚本相同的目录下 运行正常 这个折腾了半天 2）浏览器打开时，地址栏显示 data; 而不是预期的指定的 url 解决方案 自己的浏览器和下载版本对应 基本用法一.初始化初始化一个浏览器并打开一个网页，如下： 1var webdriver = require(&#x27;selenium-webdriver&#x27;);var driver = new webdriver.Builder() .forBrowser(&#x27;ie&#x27;) .build();driver.get(&#x27;http://www.baidu.com&#x27;); 二.常用方法1.元素定位 根据id定位 1driver.findElement(By.id(&#x27;ID&#x27;))；//类似于jquery的$(&quot;#id&quot;) 根据className定位 1driver.findElement(By.className(&#x27;Class&#x27;))；//类似于jquery的$(&quot;.class&quot;) 更多定位方式可参考：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/index_exports_By.html 2.设置元素的值1driver.findElement(By.id(&#x27;ID&#x27;)).sendKeys(&#x27;value&#x27;);//类似于jquery的$(&quot;.id&quot;).val(&quot;value&quot;); 3.清空元素的值1driver.findElement(By.id(&#x27;id&#x27;)).clear(); 4.单击按钮1driver.findElement(By.id(&#x27;id&#x27;)).click(); 5.元素等待有时对一些元素需要等待页面跳转或操作完成才会显示，如果操作耗时或者网络原因，如果该元素还没出现就进行操作可能会跑出异常，这是我们需要设置一些等待，等待该元素出现在页面上时才能进行操作： 1var until = webdriver.until;driver.wait(until.elementLocated(By.id(&#x27;id&#x27;), 10000));... 6.程序睡眠睡眠功能解决的问题和元素等待类似，更推荐使用元素等待方法。 1driver.sleep(500);//毫秒 7.执行JavaScript在网页上运行一段javascript,此方法在selenium的使用中非常有用，当有些时候某个元素是在难以获取时，可使用该方法直接触发该元素本身的操作，例如某个按钮点击后执行网页跳转，但是我们难以定位该元素时可以直接使用以下方式跳转： 1driver.executeScript(&#x27;location.href=&quot;/xx.html&quot; &#x27;); 或者需要给元素设置值时可以使用： 1driver.executeScript(&#x27;document.getElementById(&quot;id&quot;).value=&quot;value&quot;&#x27;);//$(&quot;#id&quot;).val(&quot;value&quot;); 8.执行JavaScript并获取返回值在网页上运行JavaScript还可返回值，以供我们自动运行程序调用做出一些判断，比如可以检查网页上的某个值大于100做某种操作，小于100做另外一种操作。 1driver.executeScript(&#x27;return $(&quot;#id&quot;).val()&#x27;).then(function(obj)&#123; //obj即为返回值 if(obj&gt;100)&#123; //操作 &#125;else&#123; //其他操作 &#125;&#125;) 9.切换作用域（switchTo） 切换到iframe网页中常常会嵌入一些iframe，或者是标签页面或者是弹窗的形式。这是要操作iframe里面的元素前就需把当前的作用域切换到iframe，切换后在切换会主页面前所有的操作都是针对iframe，在iframe内的操作结束后需切换回主页面。 1driver.switchTo().frame(driver.findElement(By.id(&quot;iframe-id&quot;))); //iframe-id为iframe元素的id 切换到弹出框有时候一些网页会弹出一些操作提示，提示框会堵塞整个任务的执行，需将其关闭(只针对原生的js弹出框)。 1driver.switchTo().alert().then(function(alert) &#123; //检测到弹出框时执行 //关闭alert return alert.dismiss();&#125;,function()&#123; //没有检测到弹出框时执行&#125;); 切换回主页面 1driver.switchTo().defaultContent(); 10.网页最大化（全屏）1driver.manage().window().maximize(); 11.网页截图(定位)网页截图看上去很简单，就一行代码如下： 1driver.takeScreenshot()； 截图后的结果为base64格式，可自行处理。类似这样： 1driver.takeScreenshot().then(function(d)&#123; //此处d即为截图结果base64字符串，可在此自行处理&#125;); 但是往往在实际应用中可能我们不需要一整个网页图片，我们值需要某部分的图片，这时候就需要换种方式了。在网上找到了一些信息（已不记得出处）后做了整理和亲测后记录如下： 1driver.findElement(By.className(&#x27;yanzheng&#x27;)).then(function(obj)&#123; obj.getSize().then(function(size)&#123; obj.getLocation().then(function(loc)&#123; driver.takeScreenshot().then(function(d)&#123; var data=&#123; d:d, width:size.width, height:size.height, x:loc.x, y:loc.y &#125;; //此处省略以下两步 //1.提交data信息到服务器处理图片 //2.先根据d获取整张图片信息，再根据需要截取的元素的其实位置x,y以及长宽width,height截取相应的图片 &#125;) &#125; &#125;&#125;) 12.退出程序（关闭网页）1driver.quit(); 更多详细文档可参考官方文档：http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/ 下面是不错的资源中文文档 易百教程","categories":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}],"tags":[{"name":"Nodejs Selenium","slug":"Nodejs-Selenium","permalink":"https://gujinlonghaha.github.io/tags/Nodejs-Selenium/"}],"keywords":[{"name":"Selenium","slug":"Selenium","permalink":"https://gujinlonghaha.github.io/categories/Selenium/"}]},{"title":"文档中操作组件和展示组件源码","slug":"doc","date":"2021-02-01T07:23:24.000Z","updated":"2021-04-14T08:38:35.593Z","comments":true,"path":"2021/02/01/doc/","link":"","permalink":"https://gujinlonghaha.github.io/2021/02/01/doc/","excerpt":"","text":"什么是组件示例文档？当你使用 Vue、React 或者其他语言编写了一个组件库，如 Element UI、Ant Design Vue 或是基于它们开发的业务封装库，都需要使用文档来支撑，而使用文档必然会包含代码与示例，这部分就是组件示例文档。 举个例子，Element 文档，其中就包含了多份示例代码，假设我们现在完成了组件开发，需要使用 Vuepress 写一份和它一样的使用文档，该怎么做呢？ ​ vuepress 官方解决方案是这样 导入代码段 beta你可以通过下述的语法导入已经存在的文件中的代码段： 1&lt;&lt;&lt; @/filepath 它也支持 行高亮： 1&lt;&lt;&lt; @/filepath&#123;highlightLines&#125; 输入 1&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet.js&#123;2&#125; 输出 123export default function () &#123; // ..&#125; 注意 由于代码段的导入将在 webpack 编译之前执行，因此你无法使用 webpack 中的路径别名，此处的 @ 默认值是 process.cwd()。 为了只导入对应部分的代码，你也可运用 VS Code region (opens new window)。你可以在文件路径后方的 # 紧接着提供一个自定义的区域名称（预设为 snippet ） 输入 1&lt;&lt;&lt; @/../@vuepress/markdown/__tests__/fragments/snippet-with-region.js#snippet&#123;1&#125; 代码文件 1234567891011121314151617181920212223242526272829303132// #region snippetfunction foo () &#123; return (&#123; dest: &#x27;../../vuepress&#x27;, locales: &#123; &#x27;/&#x27;: &#123; lang: &#x27;en-US&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue-powered Static Site Generator&#x27; &#125;, &#x27;/zh/&#x27;: &#123; lang: &#x27;zh-CN&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue 驱动的静态网站生成器&#x27; &#125; &#125;, head: [ [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: `/logo.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;manifest&#x27;, href: &#x27;/manifest.json&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;theme-color&#x27;, content: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-capable&#x27;, content: &#x27;yes&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-status-bar-style&#x27;, content: &#x27;black&#x27; &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;apple-touch-icon&#x27;, href: `/icons/apple-touch-icon-152x152.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;mask-icon&#x27;, href: &#x27;/icons/safari-pinned-tab.svg&#x27;, color: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileImage&#x27;, content: &#x27;/icons/msapplication-icon-144x144.png&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileColor&#x27;, content: &#x27;#000000&#x27; &#125;] ] &#125;)&#125;// #endregion snippetexport default foo 输出 12345678910111213141516171819202122232425262728function foo () &#123; return (&#123; dest: &#x27;../../vuepress&#x27;, locales: &#123; &#x27;/&#x27;: &#123; lang: &#x27;en-US&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue-powered Static Site Generator&#x27; &#125;, &#x27;/zh/&#x27;: &#123; lang: &#x27;zh-CN&#x27;, title: &#x27;VuePress&#x27;, description: &#x27;Vue 驱动的静态网站生成器&#x27; &#125; &#125;, head: [ [&#x27;link&#x27;, &#123; rel: &#x27;icon&#x27;, href: `/logo.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;manifest&#x27;, href: &#x27;/manifest.json&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;theme-color&#x27;, content: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-capable&#x27;, content: &#x27;yes&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;apple-mobile-web-app-status-bar-style&#x27;, content: &#x27;black&#x27; &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;apple-touch-icon&#x27;, href: `/icons/apple-touch-icon-152x152.png` &#125;], [&#x27;link&#x27;, &#123; rel: &#x27;mask-icon&#x27;, href: &#x27;/icons/safari-pinned-tab.svg&#x27;, color: &#x27;#3eaf7c&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileImage&#x27;, content: &#x27;/icons/msapplication-icon-144x144.png&#x27; &#125;], [&#x27;meta&#x27;, &#123; name: &#x27;msapplication-TileColor&#x27;, content: &#x27;#000000&#x27; &#125;] ] &#125;)&#125; 如果使用组件的话想到那个于引入一次组件展示一次 源码展示一次 写两遍 有没有一次的方法呢？（意外发现） 工具总是提高人们效率的法宝之一 使用 npm 安装它： 1npm i vuepress-plugin-demo-container --save-dev 如果你的网络环境不佳，推荐使用 cnpm。 #配置插件打开 .vuepress/config.js 文件，然后在合适的位置引用插件： 12345module.exports = &#123; ... plugins: [&#x27;demo-container&#x27;] ...&#125; 在 Markdown 文件中编写以下代码： 12345678910111213141516171819202122232425::: demo 此处放置代码示例的描述信息，支持 `Markdown` 语法，**描述信息只支持单行**```html&lt;template&gt; &lt;div class=&quot;red-center-text&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;Input something...&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; message: &#x27;Hello Vue&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.red-center-text &#123; color: #ff7875; text-align: center;&#125;&lt;/style&gt;` ` ` &lt;= 删除左侧空格::: 运行效果如下 个人demo 地址","categories":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/categories/vuepress-plugin-demo-container/"}],"tags":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/tags/vuepress-plugin-demo-container/"}],"keywords":[{"name":"vuepress-plugin-demo-container","slug":"vuepress-plugin-demo-container","permalink":"https://gujinlonghaha.github.io/categories/vuepress-plugin-demo-container/"}]},{"title":"文档中代码编辑加预览","slug":"code","date":"2020-10-13T06:27:43.000Z","updated":"2021-04-14T08:38:35.593Z","comments":true,"path":"2020/10/13/code/","link":"","permalink":"https://gujinlonghaha.github.io/2020/10/13/code/","excerpt":"","text":"好文档是什么呢？（其实有人已经回答）我一直在思考 🤔 怎么的 Vue 文档交互才是好的 👍, 后来得出的结论是: 能看代码 能看效果 能在线编辑代码, 并实时预览结果 能做到前 2 点的 Vue 组件不少, 但能做到第 3 点, 并对文档的 DEMO 编写做优化处理的并不多 找了好久功夫不负有心人 还是有大神造就出了轮子 轮子总是能效率提升百倍 以 docsify 为例子 （v-charts 展示源码同时 可预览 编辑 就是用的这个做的文档 虽然线上目前出故障了到是 ） 地址 原理使用vuep 这是个好东西 随后又找到另一个类似网站 ve-charts 有源码 有demo 源码编辑 demo 联动 以上都是vuep 技术实现 还没有没别的方式呢vue-run-sfc 你值得拥有🍎 使用12345678910111213141516171819202122&lt;script&gt; window.$docsify = &#123; // 配置, 更多属性解释请往下面翻 ↓ run: &#123; themeColor: &#x27;green&#x27;, themeBorderColor: &#x27;#eee&#x27;, reverse: true, // ... &#125; &#125;&lt;/script&gt;&lt;!-- 引入Vue --&gt;&lt;script src=&quot;//unpkg.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入 vue-run-sfc --&gt;&lt;script src=&quot;//unpkg.com/vue-run-sfc&quot;&gt;&lt;/script&gt;&lt;!-- 引入 docsify-plugin-run --&gt;&lt;script src=&quot;https://unpkg.com/docsify-plugin-run/src/index.js&quot;&gt;&lt;/script&gt;&lt;!-- 指定版本 --&gt;&lt;!-- &lt;script src=&quot;https://unpkg.com/docsify-plugin-run@xx.xx.xx/src/index.js&quot;&gt;&lt;/script&gt; --&gt;&lt;!-- docsify --&gt;&lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; 🍊示例全局配置: 运行 element-ui123456789101112131415161718&lt;script&gt; window.$docsify = &#123; run: &#123; jsLabs: [&#x27;https://unpkg.com/element-ui/lib/index.js&#x27;], cssLabs: [&#x27;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#x27;], &#125; &#125;&lt;/script&gt;``html run&lt;template&gt; &lt;el-tabs type=&quot;border-card&quot;&gt; &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;配置管理&quot;&gt;配置管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt; &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt; &lt;/el-tabs&gt;&lt;/template&gt;`` &lt;== 这里和上面的 ` 有 3 个 最终效果我放在了码云地址简单测试效果如图","categories":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}],"tags":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/tags/docsify-vuepres-code-run/"}],"keywords":[{"name":"docsify vuepres code run","slug":"docsify-vuepres-code-run","permalink":"https://gujinlonghaha.github.io/categories/docsify-vuepres-code-run/"}]},{"title":"小试尤大大vuepress vue 文档神器","slug":"vuepress","date":"2020-08-01T03:15:12.000Z","updated":"2021-04-14T08:38:35.761Z","comments":true,"path":"2020/08/01/vuepress/","link":"","permalink":"https://gujinlonghaha.github.io/2020/08/01/vuepress/","excerpt":"","text":"没听过vuepress？它可是新的vue全家桶成员之一，尤雨溪大神于2018年4月12日推出。个人觉得如果是vue 组件文档应该是最优选择(毕竟是vue文档工具 深度定制)简洁至上以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 Vue 驱动享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。 高性能VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。 #为什么不是…?#NuxtVuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。 #Docsify / Docute这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！ #HexoHexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。 #GitBook我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。 个人小试如下 很快就搭建了架子 部署在了gitee 上 配置如下 注意配置这才会展示 官方文档有介绍 和部署域名后缀一样就ok了 测试效果如下 彩蛋codepen 如何引入到文档显得高大上？？？如下 See the Pen QWdaRMR by gujinlong (@gujinlonghaha) on CodePen. 步骤先保存 然后获取iframe 最后直接放在md 源文件","categories":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}],"tags":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/tags/vuepress/"}],"keywords":[{"name":"vuepress","slug":"vuepress","permalink":"https://gujinlonghaha.github.io/categories/vuepress/"}]},{"title":"pupeteer自动化加版本测试","slug":"pup","date":"2020-04-08T02:57:47.000Z","updated":"2021-04-14T08:38:35.757Z","comments":true,"path":"2020/04/08/pup/","link":"","permalink":"https://gujinlonghaha.github.io/2020/04/08/pup/","excerpt":"","text":"多版本谷歌测试如何进行没必要不更换谷歌浏览器吧？ 对答案是肯定的！今天主角帮你解决 puppeteerjs你可以在浏览器中手动执行的绝大多数操作都可以使用 Puppeteer 来完成！ 下面是一些示例： 生成页面 PDF。 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））。 自动提交表单，进行 UI 测试，键盘输入等。 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试。 捕获网站的 timeline trace，用来帮助分析性能问题。 测试浏览器扩展。 他其中有个模块 那个就是版本号 其实你发现和咱们版本号不一样 后来我研究发现是这样的 地址 需要fq 是第二个箭头也就是分支切换出来的版本号码 那他支持哪些版本呢 地址 淘宝给出了镜像地址 下面号码拿来直接用 现在谷歌浏览器都是下载安装器然后在线安装有没离线包 福利 自己写的部分常用脚本 以防忘记 1234567891011121314151617181920212223242526272829303132333435363738394041const puppeteer = require(&#x27;puppeteer&#x27;);let operte=async(t) =&gt; &#123; // 开启 browser const browserFetcher = puppeteer.createBrowserFetcher(); const revisionInfo = await browserFetcher.download(&#x27;533271&#x27;); //指定版本 const vesion= await browserFetcher.localRevisions() console.log(vesion) let browser = await puppeteer.launch(&#123; executablePath: revisionInfo.executablePath, headless: false, defaultViewport: &#123; height: 1080, width: 1920 &#125; &#125;); // 新增分页 console.log(browser) let page = await browser.newPage(); // 到自己的网站 await page.goto(`$&#123;t&#125;`); // 等待订阅按钮出现 // await page.waitForSelector(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // page.type(&#x27;#mytextarea&#x27;, &#x27;Hello&#x27;, &#123; delay: 100 &#125;); // 立即输入 // page.type(&#x27;#mytextarea&#x27;, &#x27;World&#x27;, &#123; delay: 100 &#125;); // 输入变慢，像一个用户 // // 点击订阅按钮 // await page.click(&quot;button[class=&#x27;subscribe-button pill-button&#x27;]&quot;); // 关闭标签页 // page.close() // 关闭浏览器 // await browser.close();&#125;let arr=[ &#x27;https://www.baidu.com/&#x27;, // &#x27;https://cn.bing.com/search?q=b%E6%A1%88&amp;PC=U316&amp;FORM=CHROMN&#x27;,]arr.forEach(t =&gt; &#123; operte(t)&#125;);","categories":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}],"tags":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/tags/pupeteer/"}],"keywords":[{"name":"pupeteer","slug":"pupeteer","permalink":"https://gujinlonghaha.github.io/categories/pupeteer/"}]},{"title":"electron 锁定用户版本","slug":"exe","date":"2018-05-07T08:05:14.000Z","updated":"2021-04-14T08:38:35.597Z","comments":true,"path":"2018/05/07/exe/","link":"","permalink":"https://gujinlonghaha.github.io/2018/05/07/exe/","excerpt":"","text":"当我们碰到客户环境下谷歌浏览器版本导致我们的问题时怎么办呢? 升级用户浏览器 （备份用户数据 书签收藏夹） 安装便捷版谷歌浏览器 （连个谷歌浏览器同时存在用户电脑 数据独立） 使用electron 包装应用 最简单 便捷 前两种就不说了 这里介绍下第三种electron​ 先使用 1yarn create electron-app my-app 然后 12cd my-appyarn start 接着把这里 1234567891011121314151617 const mainWindow = new BrowserWindow(&#123; width: 1920, height: 1080, fullscreen:true,//全屏展示 center: true, // 窗口居中 resizable: true, // 窗口大小是否可改变 maximizable: true, // 窗口是否可以最大化 autoHideMenuBar:true //关掉原始操作 重要 &#125;); // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;)); mainWindow.loadURL(&#x27;https://share.arena.360.cn/view/5bb1fbd0a438e17f394e284c2aa0bdac&#x27;) // Open the DevTools. 开发者工具 // mainWindow.webContents.openDevTools();&#125;; 最后打包 1npm run publish 在目录下exe 就生成了 看下效果 好处呢 不言而喻 直接给客户exe 文件简单直接 运行默认全屏 干净整洁 同时内核版本自己控制 不会有其他标签页尤其适合大屏演示","categories":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"tags":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/tags/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}],"keywords":[{"name":"谷歌浏览器  electron","slug":"谷歌浏览器-electron","permalink":"https://gujinlonghaha.github.io/categories/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8-electron/"}]},{"title":"你好,朋友！","slug":"hellow","date":"2015-07-13T12:46:25.000Z","updated":"2021-04-14T08:38:35.725Z","comments":true,"path":"2015/07/13/hellow/","link":"","permalink":"https://gujinlonghaha.github.io/2015/07/13/hellow/","excerpt":"","text":"我是GJL,一名前端程序猿 我的博客园地址 查看 个人vscode 插件开发 查看 个人开发quicker 插件地址 自动化部署脚本查看 个人小米自动化抢购脚本 查看 这是一些过往欢快时刻 2020年 2019年 2016年","categories":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}],"tags":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/tags/%E8%87%AA%E5%B7%B1/"}],"keywords":[{"name":"自己","slug":"自己","permalink":"https://gujinlonghaha.github.io/categories/%E8%87%AA%E5%B7%B1/"}]}]}